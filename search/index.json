[{"content":"吃豆人 连上环境后f12,发现脚本game.js:\nfunction startGame() { document.getElementById(\u0026#34;start-screen\u0026#34;).style.display = \u0026#34;none\u0026#34;; document.getElementById(\u0026#34;game\u0026#34;).style.display = \u0026#34;block\u0026#34;; initGame(); } const canvas = document.getElementById(\u0026#34;game\u0026#34;); const ctx = canvas.getContext(\u0026#34;2d\u0026#34;); const box = 20; let people, balls, score, dx, dy, isGameOver, game; let redBallCount, blueBallCount; let hasGotFlag = false; function initGame() { people = [{ x: 200, y: 200 }]; dx = box; dy = 0; score = 0; isGameOver = false; hasGotFlag = false; redBallCount = 1000; blueBallCount = 1; balls = []; spawnBalls(); if (game) clearInterval(game); game = setInterval(draw, 150); } document.addEventListener(\u0026#34;keydown\u0026#34;, dir); function dir(e) { if (e.key === \u0026#34;ArrowUp\u0026#34; \u0026amp;\u0026amp; dy === 0) { dx = 0; dy = -box; } else if (e.key === \u0026#34;ArrowDown\u0026#34; \u0026amp;\u0026amp; dy === 0) { dx = 0; dy = box; } else if (e.key === \u0026#34;ArrowLeft\u0026#34; \u0026amp;\u0026amp; dx === 0) { dx = -box; dy = 0; } else if (e.key === \u0026#34;ArrowRight\u0026#34; \u0026amp;\u0026amp; dx === 0) { dx = box; dy = 0; } else if (e.key === \u0026#34; \u0026#34;) { // 空格重开 initGame(); } } function draw() { if (isGameOver) return; ctx.clearRect(0, 0, 400, 400); ctx.strokeStyle = \u0026#34;white\u0026#34;; ctx.lineWidth = 2; ctx.strokeRect(0, 0, 400, 400); // ren ctx.fillStyle = \u0026#34;lime\u0026#34;; ctx.fillRect(people[0].x, people[0].y, box, box); // 画球 balls.forEach(ball =\u0026gt; { ctx.fillStyle = ball.color; ctx.beginPath(); ctx.arc(ball.x + box / 2, ball.y + box / 2, box / 2 - 2, 0, Math.PI * 2); ctx.fill(); }); // 人移动 let head = { x: people[0].x + dx, y: people[0].y + dy }; // 碰撞判断 if (head.x \u0026lt; 0 || head.x \u0026gt;= 400 || head.y \u0026lt; 0 || head.y \u0026gt;= 400) { gameOver(); return; } // 吃球逻辑 let ateIndex = balls.findIndex(b =\u0026gt; b.x === head.x \u0026amp;\u0026amp; b.y === head.y); if (ateIndex !== -1) { const eaten = balls[ateIndex]; if (eaten.color === \u0026#34;red\u0026#34;) { score += 1; redBallCount--; } else if (eaten.color === \u0026#34;blue\u0026#34;) { score = score * 5; blueBallCount--; } balls.splice(ateIndex, 1); } people[0] = head; // 胜利检测 if (score \u0026gt;= 5000 \u0026amp;\u0026amp; !hasGotFlag) { fetch(\u0026#39;/submit_score\u0026#39;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ score: score }) }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { if (data.flag) { alert(\u0026#34;🎉 恭喜！你的flag是：\u0026#34; + data.flag); } else { alert(\u0026#34;未达到指定分数！\u0026#34;); } }); hasGotFlag = true; } // 球吃光了 if (balls.length === 0) { if (redBallCount === 0 \u0026amp;\u0026amp; blueBallCount === 0) { if (score \u0026gt;= 5000) { alert(\u0026#34;你赢了！\u0026#34;); } else { alert(\u0026#34;球全吃完了，但分数不足，游戏失败！\u0026#34;); } isGameOver = true; return; } else { spawnBalls(); } } if ( redBallCount \u0026gt; 0 \u0026amp;\u0026amp; balls.every(b =\u0026gt; b.color !== \u0026#34;red\u0026#34;) \u0026amp;\u0026amp; balls.length \u0026gt; 0 ) { spawnBalls(); } ctx.fillStyle = \u0026#34;white\u0026#34;; ctx.fillText(\u0026#34;Score: \u0026#34; + score, 10, 20); ctx.fillText(\u0026#34;Red left: \u0026#34; + redBallCount, 10, 40); ctx.fillText(\u0026#34;Blue left: \u0026#34; + blueBallCount, 10, 60); } function spawnBalls() { let num = Math.floor(Math.random() * 5) + 1; // 即使红球或蓝球库存为 0，也要刷新蓝球位置（如果还在场上） const blueIndex = balls.findIndex(b =\u0026gt; b.color === \u0026#34;blue\u0026#34;); if (blueIndex !== -1) { balls.splice(blueIndex, 1); } if (redBallCount \u0026lt;= 0 \u0026amp;\u0026amp; blueBallCount \u0026lt;= 0) return; // 特例：只生成一个球 if (num === 1) { if (redBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;red\u0026#34;)); } else if (blueBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;blue\u0026#34;)); } return; } // 多于1个球时，先加蓝球（前提：蓝球还未被吃掉） if (blueBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;blue\u0026#34;)); num--; } // 加红球（前提：库存足够） while (num \u0026gt; 0 \u0026amp;\u0026amp; redBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;red\u0026#34;)); num--; } } function createBall(color) { let x, y; do { x = box * Math.floor(Math.random() * 20); y = box * Math.floor(Math.random() * 20); } while (balls.some(b =\u0026gt; b.x === x \u0026amp;\u0026amp; b.y === y) || (people[0].x === x \u0026amp;\u0026amp; people[0].y === y)); return { x, y, color }; } function gameOver() { alert(\u0026#34;你撞墙了，游戏失败！得分：\u0026#34; + score + \u0026#34;\\n按空格键重新开始\u0026#34;); isGameOver = true; } // 启动 //initGame(); 看下面这一段：\nif (score \u0026gt;= 5000 \u0026amp;\u0026amp; !hasGotFlag) { fetch(\u0026#39;/submit_score\u0026#39;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ score: score }) }) 只要满足score\u0026gt;=5000就能获取 flag\n控制台输入以下命令即可：\nscore = 5000; 麦霸评分 审查代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;f4k3 KTY 评分系统\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; } .container { background-color: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); } .header { text-align: center; margin-bottom: 30px; } .header h1 { color: #e74c3c; margin-bottom: 10px; } .controls { display: flex; flex-direction: column; align-items: center; gap: 20px; margin-bottom: 30px; } .button { padding: 12px 25px; font-size: 16px; background-color: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; } .button:hover { background-color: #c0392b; } .button:disabled { background-color: #95a5a6; cursor: not-allowed; } .result { margin-top: 20px; padding: 15px; border-radius: 4px; text-align: center; } .result-low { background-color: #d6eaf8; color: #2980b9; } .result-medium { background-color: #fdebd0; color: #e67e22; } .result-high { background-color: #d5f5e3; color: #27ae60; } .result-perfect { background-color: #ebdef0; color: #8e44ad; } .audio-container { margin: 20px 0; display: flex; flex-direction: column; align-items: center; } .audio-container h3 { margin-bottom: 10px; } .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); } .modal-content { position: relative; background-color: #fefefe; margin: 15% auto; padding: 30px; border-radius: 8px; width: 70%; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.2); animation: modalopen 0.4s; } @keyframes modalopen { from {opacity: 0; transform: translateY(-30px);} to {opacity: 1; transform: translateY(0);} } .close-button { position: absolute; top: 10px; right: 15px; color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; } .close-button:hover { color: #333; } .flag { margin: 30px 0; padding: 15px; font-size: 20px; font-weight: bold; color: #e74c3c; background-color: #f9ebea; border: 2px dashed #e74c3c; border-radius: 5px; } .timer { font-size: 24px; font-weight: bold; margin: 10px 0; color: #e74c3c; } .visualizer { width: 100%; height: 60px; margin: 20px 0; background-color: #f5f5f5; border-radius: 4px; } .similarity-meter { width: 100%; height: 20px; background-color: #ecf0f1; border-radius: 10px; margin: 15px 0; overflow: hidden; } .similarity-value { height: 100%; width: 0%; background: linear-gradient(to right, #3498db, #2ecc71, #f1c40f, #e74c3c); border-radius: 10px; transition: width 0.5s ease-in-out; } .loader { border: 5px solid #f3f3f3; border-top: 5px solid #e74c3c; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; display: none; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } .cooldown { font-size: 18px; margin-top: 10px; color: #e74c3c; font-weight: bold; } .warning { background-color: #fadbd8; padding: 10px; border-radius: 5px; margin: 10px 0; color: #c0392b; } /* 添加退出确认对话框样式 */ .exit-confirm-modal { display: none; position: fixed; z-index: 2; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); } .exit-confirm-content { position: relative; background-color: #fff2cc; margin: 15% auto; padding: 30px; border-radius: 8px; width: 70%; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.2); animation: modalopen 0.4s; border-left: 5px solid #e74c3c; } .exit-confirm-title { color: #e74c3c; font-size: 20px; margin-bottom: 15px; } .exit-confirm-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 20px; } .exit-confirm-buttons button { padding: 10px 20px; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; } .exit-confirm-stay { background-color: #3498db; color: white; } .exit-confirm-leave { background-color: #e74c3c; color: white; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;KTV 录音评分系统\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;大家都会逆战吧, have a try \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;audio-container\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;逆战\u0026amp;张杰:\u0026lt;/h3\u0026gt; \u0026lt;audio id=\u0026#34;originalAudio\u0026#34; controls\u0026gt; \u0026lt;source id=\u0026#34;originalAudioSource\u0026#34; src=\u0026#34;/original.wav\u0026#34; type=\u0026#34;audio/wav\u0026#34;\u0026gt; 您的浏览器不支持音频播放 \u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;warningMessage\u0026#34; class=\u0026#34;warning\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;timer\u0026#34; class=\u0026#34;timer\u0026#34;\u0026gt;00:00\u0026lt;/div\u0026gt; \u0026lt;canvas id=\u0026#34;visualizer\u0026#34; class=\u0026#34;visualizer\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div class=\u0026#34;similarity-meter\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;similarityValue\u0026#34; class=\u0026#34;similarity-value\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;recordButton\u0026#34; class=\u0026#34;button\u0026#34;\u0026gt;开始录音\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;cooldownTimer\u0026#34; class=\u0026#34;cooldown\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;loader\u0026#34; class=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34; class=\u0026#34;result\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 录音预览 --\u0026gt; \u0026lt;div class=\u0026#34;audio-container\u0026#34; id=\u0026#34;recordingContainer\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;你的录音:\u0026lt;/h3\u0026gt; \u0026lt;audio id=\u0026#34;recordedAudio\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- FLAG弹窗 --\u0026gt; \u0026lt;div id=\u0026#34;flagModal\u0026#34; class=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-content\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;close-button\u0026#34; onclick=\u0026#34;closeModal()\u0026#34;\u0026gt;\u0026amp;times;\u0026lt;/span\u0026gt; \u0026lt;h2\u0026gt;恭喜你！歌神级别！\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;你的演唱简直完美，获得了最高评价！\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;flag\u0026#34; id=\u0026#34;flagContent\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; onclick=\u0026#34;closeModal()\u0026#34;\u0026gt;谢谢\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;exitConfirmModal\u0026#34; class=\u0026#34;exit-confirm-modal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-title\u0026#34;\u0026gt;⚠️ 警告\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;若您退出当下页面，所有录制的录音都会被删除！\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-buttons\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;stayButton\u0026#34; class=\u0026#34;exit-confirm-stay\u0026#34;\u0026gt;留在页面\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;leaveButton\u0026#34; class=\u0026#34;exit-confirm-leave\u0026#34;\u0026gt;确认退出\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let audioContext; let analyser; let microphone; let mediaRecorder; let audioChunks = []; let isRecording = false; let startTime; let timerInterval; let visualizerContext; // 时间 let lastRequestTime = 0; const MIN_REQUEST_INTERVAL = 10000; // 10秒，与服务器端保持一致 let cooldownInterval = null; // DOM元素 const recordButton = document.getElementById(\u0026#39;recordButton\u0026#39;); const timer = document.getElementById(\u0026#39;timer\u0026#39;); const visualizer = document.getElementById(\u0026#39;visualizer\u0026#39;); const recordingContainer = document.getElementById(\u0026#39;recordingContainer\u0026#39;); const recordedAudio = document.getElementById(\u0026#39;recordedAudio\u0026#39;); const result = document.getElementById(\u0026#39;result\u0026#39;); const loader = document.getElementById(\u0026#39;loader\u0026#39;); const similarityValue = document.getElementById(\u0026#39;similarityValue\u0026#39;); const flagModal = document.getElementById(\u0026#39;flagModal\u0026#39;); const flagContent = document.getElementById(\u0026#39;flagContent\u0026#39;); const cooldownTimer = document.getElementById(\u0026#39;cooldownTimer\u0026#39;); const warningMessage = document.getElementById(\u0026#39;warningMessage\u0026#39;); const originalAudio = document.getElementById(\u0026#39;originalAudio\u0026#39;); const originalAudioSource = document.getElementById(\u0026#39;originalAudioSource\u0026#39;); originalAudio.addEventListener(\u0026#39;error\u0026#39;, function(e) { console.error(\u0026#39;音频加载失败:\u0026#39;, e); warningMessage.textContent = \u0026#39;原始音频加载失败，请刷新页面重试\u0026#39;; warningMessage.style.display = \u0026#39;block\u0026#39;; fetch(\u0026#39;/get-original-audio\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { if (data \u0026amp;\u0026amp; data.url) { console.log(\u0026#39;从API获取音频URL:\u0026#39;, data.url); originalAudioSource.src = data.url + \u0026#39;?t=\u0026#39; + new Date().getTime(); // 添加时间戳防止缓存 originalAudio.load(); } }) .catch(err =\u0026gt; { console.error(\u0026#39;获取音频URL失败:\u0026#39;, err); }); }); // 添加退出确认对话框元素 const exitConfirmModal = document.getElementById(\u0026#39;exitConfirmModal\u0026#39;); const stayButton = document.getElementById(\u0026#39;stayButton\u0026#39;); const leaveButton = document.getElementById(\u0026#39;leaveButton\u0026#39;); let currentRecordingFilename = null; visualizerContext = visualizer.getContext(\u0026#39;2d\u0026#39;); visualizer.width = visualizer.offsetWidth; visualizer.height = visualizer.offsetHeight; recordButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (!isRecording) { if (!canMakeRequest()) { showCooldownMessage(); return; } // 如果有上一段录音，先清理 if (currentRecordingFilename) { cleanRecording(currentRecordingFilename); currentRecordingFilename = null; } startRecording(); } else { stopRecording(); } }); // 检查是否可以发送请求 function canMakeRequest() { const now = Date.now(); return now - lastRequestTime \u0026gt;= MIN_REQUEST_INTERVAL; } // 限时，避免过度请求 function showCooldownMessage() { const now = Date.now(); const remainingTime = Math.ceil((MIN_REQUEST_INTERVAL - (now - lastRequestTime)) / 1000); cooldownTimer.textContent = `请等待 ${remainingTime} 秒后再试`; cooldownTimer.style.display = \u0026#39;block\u0026#39;; if (cooldownInterval) { clearInterval(cooldownInterval); } cooldownInterval = setInterval(() =\u0026gt; { const currentTime = Date.now(); const remaining = Math.ceil((MIN_REQUEST_INTERVAL - (currentTime - lastRequestTime)) / 1000); if (remaining \u0026lt;= 0) { clearInterval(cooldownInterval); cooldownTimer.style.display = \u0026#39;none\u0026#39;; cooldownTimer.textContent = \u0026#39;\u0026#39;; } else { cooldownTimer.textContent = `请等待 ${remaining} 秒后再试`; } }, 1000); } function updateTimer() { const elapsedTime = Math.floor((Date.now() - startTime) / 1000); const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, \u0026#39;0\u0026#39;); const seconds = (elapsedTime % 60).toString().padStart(2, \u0026#39;0\u0026#39;); timer.textContent = `${minutes}:${seconds}`; } // 可视化音频输入 function visualize() { if (!audioContext || audioContext.state === \u0026#39;closed\u0026#39;) return; const bufferLength = analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); const draw = () =\u0026gt; { if (!isRecording) return; requestAnimationFrame(draw); analyser.getByteFrequencyData(dataArray); visualizerContext.clearRect(0, 0, visualizer.width, visualizer.height); const barWidth = (visualizer.width / bufferLength) * 2.5; let x = 0; for (let i = 0; i \u0026lt; bufferLength; i++) { const barHeight = (dataArray[i] / 255) * visualizer.height; // 使用彩色渐变效果 const hue = i / bufferLength * 360; visualizerContext.fillStyle = `hsl(${hue}, 100%, 50%)`; visualizerContext.fillRect(x, visualizer.height - barHeight, barWidth, barHeight); x += barWidth + 1; } }; draw(); } async function startRecording() { try { result.style.display = \u0026#39;none\u0026#39;; recordingContainer.style.display = \u0026#39;none\u0026#39;; warningMessage.style.display = \u0026#39;none\u0026#39;; try { const prepareResponse = await fetch(\u0026#39;/prepare-recording\u0026#39;); if (!prepareResponse.ok) { console.warn(\u0026#39;预清理请求失败，继续录音:\u0026#39;, prepareResponse.statusText); } else { // 检查内容类型 const contentType = prepareResponse.headers.get(\u0026#39;content-type\u0026#39;); if (contentType \u0026amp;\u0026amp; contentType.includes(\u0026#39;application/json\u0026#39;)) { const data = await prepareResponse.json(); console.log(\u0026#39;预清理结果:\u0026#39;, data.message); } else { console.warn(\u0026#39;预清理响应不是JSON格式，继续录音\u0026#39;); } } } catch (cleanError) { console.warn(\u0026#39;预清理出错，继续录音:\u0026#39;, cleanError); } if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { throw new Error(\u0026#39;您的浏览器不支持录音功能。请使用Chrome, Firefox或Edge的最新版本。\u0026#39;); } try { // 获取录音权限 const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); audioContext = new (window.AudioContext || window.webkitAudioContext)(); analyser = audioContext.createAnalyser(); microphone = audioContext.createMediaStreamSource(stream); microphone.connect(analyser); analyser.fftSize = 256; const bufferLength = analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); if (typeof MediaRecorder === \u0026#39;undefined\u0026#39;) { throw new Error(\u0026#39;您的浏览器不支持MediaRecorder API。请使用Chrome, Firefox或Edge的最新版本。\u0026#39;); } // 创建媒体记录器 let mimeType = \u0026#39;audio/wav\u0026#39;; // 检查浏览器是否支持指定的MIME类型 if (!MediaRecorder.isTypeSupported(mimeType)) { console.warn(\u0026#39;浏览器不支持audio/wav格式，使用默认格式\u0026#39;); mimeType = \u0026#39;\u0026#39;; } const mediaRecorderOptions = mimeType ? { mimeType: mimeType, audioBitsPerSecond: 16000 } : { audioBitsPerSecond: 16000 }; mediaRecorder = new MediaRecorder(stream, mediaRecorderOptions); audioChunks = []; // 收集录音数据 mediaRecorder.ondataavailable = (event) =\u0026gt; { audioChunks.push(event.data); }; // 录音停止后的处理 mediaRecorder.onstop = () =\u0026gt; { const audioBlob = new Blob(audioChunks, { type: \u0026#39;audio/wav\u0026#39; }); const audioUrl = URL.createObjectURL(audioBlob); recordedAudio.src = audioUrl; recordingContainer.style.display = \u0026#39;block\u0026#39;; uploadRecording(audioBlob); }; mediaRecorder.start(); isRecording = true; recordButton.textContent = \u0026#39;停止录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#c0392b\u0026#39;; startTime = Date.now(); updateTimer(); timerInterval = setInterval(updateTimer, 1000); visualize(); } catch (mediaError) { handleMediaError(mediaError); } } catch (error) { console.error(\u0026#39;录音功能错误:\u0026#39;, error); showErrorMessage(error.message || \u0026#39;无法访问麦克风，请确保您已授予录音权限。\u0026#39;); } } // 停止录音 function stopRecording() { console.log(\u0026#39;停止录音函数被调用，当前状态:\u0026#39;, { isRecording: isRecording, mediaRecorderExists: !!mediaRecorder, mediaRecorderState: mediaRecorder ? mediaRecorder.state : \u0026#39;undefined\u0026#39; }); try { if (!mediaRecorder) { console.error(\u0026#39;MediaRecorder对象不存在，无法停止录音\u0026#39;); showErrorMessage(\u0026#39;录音设备异常，请刷新页面重试\u0026#39;); isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; return; } if (!isRecording) { console.warn(\u0026#39;状态显示未在录音中，但停止录音按钮被点击\u0026#39;); return; } // 确保MediaRecorder处于录音状态才能停止 if (mediaRecorder.state === \u0026#39;recording\u0026#39; || mediaRecorder.state === \u0026#39;paused\u0026#39;) { // 请求数据 mediaRecorder.requestData(); // 停止录音 mediaRecorder.stop(); console.log(\u0026#39;MediaRecorder已停止\u0026#39;); } else { console.warn(`MediaRecorder状态异常: ${mediaRecorder.state}`); } //UI更新 isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; // 停止计时器 if (timerInterval) { clearInterval(timerInterval); console.log(\u0026#39;计时器已停止\u0026#39;); } // 关闭音频流 if (audioContext \u0026amp;\u0026amp; audioContext.state !== \u0026#39;closed\u0026#39;) { if (microphone) { microphone.disconnect(); console.log(\u0026#39;麦克风已断开连接\u0026#39;); } } if (audioChunks.length \u0026gt; 0 \u0026amp;\u0026amp; mediaRecorder.state !== \u0026#39;recording\u0026#39;) { console.log(\u0026#39;手动处理录音数据\u0026#39;); const audioBlob = new Blob(audioChunks, { type: \u0026#39;audio/wav\u0026#39; }); const audioUrl = URL.createObjectURL(audioBlob); recordedAudio.src = audioUrl; recordingContainer.style.display = \u0026#39;block\u0026#39;; // 上传录音 uploadRecording(audioBlob); } } catch (error) { console.error(\u0026#39;停止录音时出错:\u0026#39;, error); showErrorMessage(\u0026#39;停止录音时出错，请刷新页面重试\u0026#39;); isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; } } // 处理媒体访问错误 function handleMediaError(error) { console.error(\u0026#39;麦克风访问错误:\u0026#39;, error); let errorMessage = \u0026#39;无法访问麦克风，请确保您已授予录音权限。\u0026#39;; // 根据错误类型提供具体的错误信息 if (error.name === \u0026#39;NotAllowedError\u0026#39; || error.name === \u0026#39;PermissionDeniedError\u0026#39;) { errorMessage = \u0026#39;您已拒绝麦克风访问权限。请点击浏览器地址栏的锁图标，更改麦克风权限设置，然后刷新页面。\u0026#39;; } else if (error.name === \u0026#39;NotFoundError\u0026#39; || error.name === \u0026#39;DevicesNotFoundError\u0026#39;) { errorMessage = \u0026#39;未检测到麦克风设备。请确认您的麦克风已正确连接，并且没有被系统禁用。\u0026#39;; } else if (error.name === \u0026#39;NotReadableError\u0026#39; || error.name === \u0026#39;TrackStartError\u0026#39;) { errorMessage = \u0026#39;麦克风正在被其他应用程序使用。请关闭可能正在使用麦克风的其他应用，然后刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;OverconstrainedError\u0026#39;) { errorMessage = \u0026#39;麦克风设置约束条件无法满足。请使用其他麦克风设备重试。\u0026#39;; } else if (error.name === \u0026#39;TypeError\u0026#39;) { errorMessage = \u0026#39;录音参数错误。请刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;AbortError\u0026#39;) { errorMessage = \u0026#39;麦克风访问请求被中断。请刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;SecurityError\u0026#39;) { errorMessage = \u0026#39;浏览器安全设置阻止了麦克风访问。请使用HTTPS连接或localhost访问本站点。\u0026#39;; } showErrorMessage(errorMessage); } // 清理录音 function cleanRecording(filename) { if (!filename) return; fetch(`/clean-recording/${filename}`, { method: \u0026#39;DELETE\u0026#39; }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(\u0026#39;清理录音结果:\u0026#39;, data.message); }) .catch(error =\u0026gt; { console.error(\u0026#39;清理录音出错:\u0026#39;, error); }); } function cleanAllRecordings() { fetch(\u0026#39;/clean-all-recordings\u0026#39;, { method: \u0026#39;DELETE\u0026#39; }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(\u0026#39;清理所有录音结果:\u0026#39;, data.message); }) .catch(error =\u0026gt; { console.error(\u0026#39;清理所有录音出错:\u0026#39;, error); }); } function uploadRecording(audioBlob) { loader.style.display = \u0026#39;block\u0026#39;; result.style.display = \u0026#39;none\u0026#39;; similarityValue.style.width = \u0026#39;0%\u0026#39;; lastRequestTime = Date.now(); const formData = new FormData(); formData.append(\u0026#39;audio\u0026#39;, audioBlob, \u0026#39;recording.wav\u0026#39;); fetch(\u0026#39;/compare-recording\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: formData }) .then(response =\u0026gt; { // 检查响应状态 if (!response.ok) { throw new Error(`服务器响应错误: ${response.status} ${response.statusText}`); } return response.json(); }) .then(data =\u0026gt; { // 隐藏加载状态 loader.style.display = \u0026#39;none\u0026#39;; // 如果成功获取到录音文件名，保存它 if (data.filename) { currentRecordingFilename = data.filename; } // 显示匹配度 const similarity = parseFloat(data.similarity); similarityValue.style.width = `${similarity}%`; // 显示结果 result.textContent = `匹配度: ${similarity.toFixed(2)}% - ${data.message}`; result.style.display = \u0026#39;block\u0026#39;; // 根据匹配度设置不同的样式 result.className = \u0026#39;result\u0026#39;; if (similarity \u0026gt;= 98) { result.classList.add(\u0026#39;result-perfect\u0026#39;); } else if (similarity \u0026gt;= 85) { result.classList.add(\u0026#39;result-high\u0026#39;); } else if (similarity \u0026gt;= 70) { result.classList.add(\u0026#39;result-medium\u0026#39;); } else { result.classList.add(\u0026#39;result-low\u0026#39;); } // 如果有FLAG，显示FLAG弹窗 if (data.flag) { showFlagModal(data.flag); } }) .catch(error =\u0026gt; { console.error(\u0026#39;上传录音出错:\u0026#39;, error); loader.style.display = \u0026#39;none\u0026#39;; result.textContent = \u0026#39;评分失败，请稍后重试: \u0026#39; + error.message; result.className = \u0026#39;result result-low\u0026#39;; result.style.display = \u0026#39;block\u0026#39;; }); } function showErrorMessage(message) { warningMessage.textContent = message; warningMessage.style.display = \u0026#39;block\u0026#39;; isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; if (timerInterval) { clearInterval(timerInterval); } } // 显示FLAG弹窗 function showFlagModal(flag) { flagContent.textContent = flag; flagModal.style.display = \u0026#39;block\u0026#39;; } function closeModal() { flagModal.style.display = \u0026#39;none\u0026#39;; } window.onclick = function(event) { if (event.target === flagModal) { flagModal.style.display = \u0026#39;none\u0026#39;; } } // 页面卸载前处理 window.addEventListener(\u0026#39;beforeunload\u0026#39;, function(event) { // 显示确认对话框 exitConfirmModal.style.display = \u0026#39;block\u0026#39;; // 阻止页面立即卸载，显示确认对话框 event.preventDefault(); event.returnValue = \u0026#39;\u0026#39;; // 注意：现代浏览器出于安全考虑可能会忽略自定义消息 return \u0026#39;若您退出当下页面，所有录制的录音都会被删除！\u0026#39;; }); // 用户选择页面 stayButton.addEventListener(\u0026#39;click\u0026#39;, function() { exitConfirmModal.style.display = \u0026#39;none\u0026#39;; }); leaveButton.addEventListener(\u0026#39;click\u0026#39;, function() { cleanAllRecordings(); exitConfirmModal.style.display = \u0026#39;none\u0026#39;; setTimeout(() =\u0026gt; { window.location.href = \u0026#39;about:blank\u0026#39;; }, 500); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 发现flag获取条件如下：\nif (similarity \u0026gt;= 98) { result.classList.add(\u0026#39;result-perfect\u0026#39;); } 但是紧接着又发现：\nif (data.flag) { showFlagModal(data.flag); } 说明flag是从后端传来，改动前端similarity值不能得到flag\n唱歌肯定不行，那么既然网站提供了原音频下载，就可以直接提交原音频\n但网页没有提供提交入口，而代码中是前端将录音文件上传到/compare-recording，那就可以直接与后端建立联系\n使用curl：\ncurl -X POST http://127.0.0.1:xxxx/compare-recording -F \u0026#34;audio=@original.wav\u0026#34; 直接得到返回的flag\n","date":"2025-05-09T01:17:52+08:00","permalink":"https://blog.928330.xyz/p/minil/","title":"MiniL"},{"content":"VIM使用方式 vim键盘图 vim操作文件基本方式 打开文件 单个文件\nvim file1 多个文件\nvim file1 file2 ... filen 该方式打开文件，显示屏默认显示第一个文件也就是 file1\n文件之间的切换 :ls \u0026ndash; 列出 VIM 打开的所有文件 :bn \u0026ndash; 显示屏上显示第n个文件 显示多个文件 左右分屏\nvim -On file1 file2 ... filen 这里的 n 是代表有几个文件需要分屏，从左至右依次显示 n 个文件\n上下分屏\nvim -on file1 file2 ... filen 跟上一个命令不同的是 -on 中的 o 是小写，这样将会上下依次显示 n 个文件\n分屏操作（ctrl+w系列） 左右分屏 Ctrl+w+s \u0026ndash; 上下分割当前打开的文件 :sp file \u0026ndash; 上下分割当前文件和新打开的 file 上下分屏 Ctrl+w+v \u0026ndash; 左右分割当前打开的文件 :vsp file \u0026ndash; 左右分割当前文件和新打开的 file 移动分屏 大写字母\nCtrl+w+H \u0026ndash; 将当前的分屏移动到左边 Ctrl+w+L \u0026ndash; 将当前的分屏移动到右边 Ctrl+w+J \u0026ndash; 将当前的分屏移动到上边 Ctrl+w+K \u0026ndash; 将当前的分屏移动到下边 在文件间切换光标 小写字母\nCtrl+w+h \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+l \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+j \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+k \u0026ndash; 将当前光标定位到左边的屏幕 关闭分屏 Ctrl+w+c \u0026ndash; 关闭当前的分屏(多个分屏就只关闭光标所在的分屏) Ctrl+w+q \u0026ndash; 关闭当前的分屏，如果是最后一个分屏将会退出 VIM vim五大模式 普通模式 用户刚刚启动 vi/vim，便进入了普通模式\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符\n普通模式移动光标 快速移动光标\n输入[数字n＋方向]，代表向某个方向移动n\nh / ← / [backspace]：向左移动光标 j / ↓：向下移动光标 k / ↑：向上移动光标 l / → / [space]：向右移动光标 在当前行上移动光标\n0 或功能键[Home] \u0026ndash; 移动到行头 ^ \u0026ndash; 移动到本行的第一个不是 blank 字符 $ 或功能键[End] \u0026ndash; 移动到行尾 g_ \u0026ndash; 移动到本行最后一个不是 blank 字符的位置 w \u0026ndash; 光标移动到下一个单词的开头 e \u0026ndash; 光标移动到下一个单词的结尾 fa \u0026ndash; 移动到本行下一个为 a 的字符处 nfa \u0026ndash; 移动到本行光标处开始的第 n 个 字符为 a 的地方 Fa \u0026ndash; 同fa一样，光标移动方向同fa相反 nFa \u0026ndash; 同 nfa 类似，光标移动方向同 nfa相反 ta \u0026ndash; 移动光标至 a 字符的前一个字符 nta \u0026ndash; 移动到第n个 a 字符的前一个字符处 Ta \u0026ndash; 同ta移动光标方向相反 nTa \u0026ndash; 同 nta 移动光标方向相反 ; \u0026amp; , \u0026ndash; 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用**；可以快速跳转到下一个指定的字符，,** 是跳到前一个指定的字符 跨行移动光标\nnG \u0026ndash; 光标定位到第 n 行的行首 gg \u0026ndash; 光标定位到第一行的行首 G \u0026ndash; 光标定位到最后一行的行首 H \u0026ndash; 光标定位到当前屏幕的第一行行首 M \u0026ndash; 光标移动到当前屏幕的中间 L \u0026ndash; 光标移动到当前屏幕的尾部 zt \u0026ndash; 把当前行移动到当前屏幕的最上方，也就是第一行 zz \u0026ndash; 把当前行移动到当前屏幕的中间 zb \u0026ndash; 把当前行移动到当前屏幕的尾部 % \u0026ndash; 匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上 * \u0026amp; # \u0026ndash; 匹配光标当前所在的单词， ***** 是下一个，# 是上一个 翻页操作\nctrl+u \u0026ndash; 向上滚动半页 ctrl+b \u0026ndash; 向上滚动一页 ctrl+d \u0026ndash; 向下滚动半页 ctrl+f \u0026ndash; 向下滚动一页 普通模式操作文本 删除\nd 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下：\ndw \u0026ndash; 删除一个单词 dnw \u0026ndash; 删除 n 个单词， dfa \u0026ndash; 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ） dnfa \u0026ndash; 删除光标处到第 n 个 a 的字符处 dd \u0026ndash; 删除一整行 ndd \u0026ndash; 删除光标处开始的 n 行 d$ \u0026ndash; 删除光标到本行的结尾 d0 \u0026ndash; 删除游标所在处到该行的最前面一个字符 dH \u0026ndash; 删除屏幕显示的第一行文本到光标所在的行 d1G \u0026ndash; 删除光标所在到第一行的所有数据 dG \u0026ndash; 删除光标所在到最后一行的所有数据 x \u0026ndash; 删除光标当前所在的字符**(delete)** X \u0026ndash; 删除光标前面的一个字符**(backspace)** nx \u0026ndash; 向后连续删除n个字符 复制\ny 是复制的意思，通常搭配一个字符（复制范围）实现复制的功能，常用的如下：\nyw \u0026ndash; 复制一个单词，还有ynw yfa \u0026ndash; 复制光标到下一个 a 的字符处,还有ynfa yy \u0026ndash; 复制一行，还有nyy y$ \u0026ndash; 复制光标到本号的结尾 yH \u0026ndash; 复制屏幕显示的第一行文本到光标所在的行 y1G \u0026ndash; 复制光标所在行到第一行的所有数据 yG \u0026ndash; 复制光标所在行到最后一行的所有数据 粘贴\np是黏贴的意思，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来\np(小写) \u0026ndash; 在光标后开始黏贴\nP(大写) \u0026ndash; 在光标前开始粘贴\n撤销操作和恢复\nu \u0026ndash; 撤销刚才的操作 ctrl+r \u0026ndash; 恢复撤销操作 大小写转换\n~ \u0026ndash; 将光标下的字母改变大小写 3~ \u0026ndash; 将光标位置开始的3个字母改变其大小写 g~~ \u0026ndash; 改变当前行字母的大小写 gUU \u0026ndash; 将当前行的字母改成大写 guu \u0026ndash; 将当前行的字母全改成小写 3gUU \u0026ndash; 将从光标开始到下面3行字母改成大写 gUw \u0026ndash; 将光标下的单词改成大写 guw \u0026ndash; 将光标下的单词改成小写 重复操作\n. \u0026ndash; 重复上一个操作的命令 n\u0026lt;command\u0026gt; \u0026ndash; 重复某个命令 n 次，如 10p复制 10 次，10dd 删除十次 其他\nJ \u0026ndash; 将光标所在行与下一行的数据结合成同一行 c \u0026ndash; 重复删除多个数据，例如向下删除 10 行，10cj 插入模式 进入插入模式 命令 说明 i, I i \u0026ndash; 从目前光标所在处输入\nI \u0026ndash; 在目前所在行的第一个非空格符处开始输入 a, A a \u0026ndash; 从目前光标所在的下一个字符处开始输入\nA \u0026ndash; 从光标所在行的最后一个字符处开始输入 o, O o \u0026ndash; 在目前光标所在的下一行处输入新的一行\nO \u0026ndash; 在目前光标所在的上一行处输入新的一行 s，S s \u0026ndash; 删除光标所在处的字符然后插入需要录入的文本\nS \u0026ndash; 删除光标所在行，在当前行的行首开始插入需要录入的文本 cw 删除从光标处开始到该单词结束的所有字符，然后插入需要录入的文本 插入模式的命令 必须知道的：#是vim中的注释符号\n在输入模式中，可以使用以下按键：\n字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 替换模式 进入替换模式 R \u0026ndash; 进入替换模式，此时新输入的文本将直接替代/覆盖已经存在的内容，点击ESC键返回常规模式\nr \u0026ndash; 进入单字符替换模式，此时新输入的字符将替代光标之下的当前字符，然后自动返回到常规模式\ngR \u0026ndash; 进入虚拟替换模式，其与替换模式最主要的区别在于，对\u0026lt;Tab\u0026gt;键和换行符的不同处理方式\ngr \u0026ndash; 进入单字符虚拟替换模式，在替换光标下的当前字符之后，将自动返回到常规模式\n虚拟替换模式 \u0026lt;Tab\u0026gt;键\n替换模式（REPLACE）下，在原有\u0026lt;Tab\u0026gt;键处输入字母\u0026rsquo;a\u0026rsquo;，将直接替代\u0026lt;Tab\u0026gt;键所占用的所有空格的位置\n虚拟替换模式（VREPLACE）下，在原有\u0026lt;Tab\u0026gt;键处输入字母\u0026rsquo;a\u0026rsquo;，将仅仅替代单个空格\n\u0026lt;NL\u0026gt;换行\n替换模式（REPLACE）下，输入\u0026lt;Enter\u0026gt;回车键将增加新行：\n虚拟替换模式（VREPLACE）下，输入\u0026lt;Enter\u0026gt;回车键将用新行替代当前行内容（即清空当前行）：\n命令模式 在命令模式下按下 :（英文冒号）就进入了底线命令模式\n有的命令要输入 / 执行\n命令模式常用命令 :w \u0026ndash; 保存文件 :q \u0026ndash; 退出 Vim 编辑器 :wq \u0026ndash; 保存文件并退出 Vim 编辑器 :q! \u0026ndash; 强制退出Vim编辑器，不保存修改 :set nu \u0026ndash; 显示行号 :set nonu \u0026ndash; 取消行号 :n \u0026ndash; 定位到第n行 :n1,n2d \u0026ndash; 删除行号n1至n2之间的内容（n1和n2都代表数字） 按 ESC 键可随时退出底线命令模式\n命令模式处理文件 :w [filename] \u0026ndash; 将编辑的数据储存成另一个文件（类似另存新档） :r [filename] \u0026ndash; 在编辑的数据中，读入另一个档案的数据，即将filenam的内容加到光标所在行后面 :n1,n2 w [filename] \u0026ndash; 将 n1 到 n2 的内容储存成 filename 命令模式搜索文本 ?{目标字符串} \u0026ndash; 向光标之上寻找一个目标字符串 /{目标字符串} \u0026ndash; 向光标之下寻找一个目标字符串 n \u0026ndash; 重复前一个搜寻的动作 N \u0026ndash; 反向进行前一个搜寻动作 :set ic \u0026ndash; 编辑器将不会区分大小写 :set noic \u0026ndash; 编辑器将区分大小写 命令模式替换文本 格式：:(作用范围)s/{目标}/{替换}(/替换的标志)\n替换的作用范围\n标志 作用 s 当前行替换 %s 全文替换 n1,n2s 指定行替换，替换n1到n2间所有行的目标，n2可以是$，代指最后一行 \u0026rsquo;\u0026lt;,\u0026rsquo;\u0026gt;s 指定区域替换 替换的标志\n标志 作用 [无] 只替换作用范围内，每行第一次出现的目标 g 一次性替换所有作用范围内所有的目标 i 大小写不敏感查找 I 大小写敏感查找 c 对作用范围内的目标逐个替换，替换前需进行确认 替换标志可以使用多个，比如/gic\n命令模式执行linux命令 :![command]\n打开终端窗口并打印执行命令的结果，不会改变当前编辑的文件的内容\n可以使用:!bash打开bash shell并执行命令\n:!date\t//执行 date 命令显示时间，执行完命令以后按下键盘上的 Enter 就会返回到文件 :r ![command]\n将shell命令command的结果插入到当前行的下一行\n:r !date\t//读取系统时间并插入到当前行的下一行 n1,n2 ![command]\n将n1至n2行范围内的内容交给命令command处理，并将处理结果替换起始行号和结束行号指定范围中的内容\n:1,4 !sort\t//将第1行到第4行的内容进行排序 可以只指定起始行\n:1 !tr [a-z] [A-Z]\t//将第1行的小写字母转为大写字母 可以用.表示当前光标所在行 (输入!!会变成:.!)\n:. !tr [a-z] [A-Z]\t//将当前行的小写转为大写 n1,n2 w ![command]\n将起始行号和结束行号所指定范围的内容作为命令command的输入，不会改变当前编辑的文件的内容\n可以使用:1 w !bash，将会把第1行的内容作为bash命令来执行并显示结果，而且不会改变当前编辑的文件的内容\n同样的 : . w !bash将当前行的内容作为bash命令来执行\n!!\n重新执行最近一次运行过的命令\n:shell / :terminal\n打开命令终端（输入exit结束并返回vim）\n使用:version命令（按q退出），查看是否包含+terminal关键字，以确认是否能使用 :terminal\n命令模式定义快捷键 基本格式\n模式 基本格式 描述 普通模式 :nmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 仅在普通模式下有效，定义普通模式下的快捷键 插入模式 :imap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义插入模式下的快捷键 可视模式 :vmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义可视模式下的快捷键 命令行模式 :cmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义命令行模式下的快捷键 总体映射 :map \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 定义快捷键，适用于普通、可视、操作和选择模式，但不建议用于有冲突的情况。 总体不可递归映射 :noremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 类似:map，但是不会递归地扩展已经存在的映射，避免意外行为。 普通模式不可递归 :nnoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在普通模式下使用，避免递归映射 插入模式不可递归 :inoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在插入模式下使用，避免递归映射 可视模式不可递归 :vnoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在可视模式下使用，避免递归映射 缩写 :ab [缩写] [完整文本] 输入缩写后空格，自动扩展为完整文本。例如：:ab email xxxx@gmail.com 什么是\u0026lt;key\u0026gt;？\n\u0026lt;key\u0026gt; 对应的是 ^[A-Z] ， 定义快捷键时使用ctrl+v+[a-z]，使用快捷键时用对应的ctrl+[a-z]\n什么是递归映射？\n:nmap j gg :nmap Q j 如果已经做了以上映射，那么按下Q，执行的将是gg而不是j\n为了避免以上问题，应该这样定义：\n:nnoremap j gg :nnoremap Q j 几个例子\n:map ^D Ahelloworld\u0026lt;ESC\u0026gt; 在文件的光标所在行的行尾，添加 helloworld 字符串，按住组合键 ctrl + d 就会执行操作\n:map ^M I#\u0026lt;ESC\u0026gt; 在文件光标处所在行的行首插入#，按住组合键 ctrl + m 就会执行操作\n:ab email xxxx@gmail.com 输入 email+空格 会把输入的 email 自动替换成 xxxx @gmail.com\n可视化模式 进入可视化模式 可视化模式可以分为以下三种：\nv \u0026ndash; 字符可视化模式，文本选择是以字符为单位的 V \u0026ndash; 行可视化模式，文本选择是以行为单位的 ctrl-V \u0026ndash; 块可视化模式，可以选择一个矩形内的文本 在任意可视化模式下使用以上命令，将会切换到对应模式\n在任意可视化模式下使用I（大写i），将会切换到插入模式\ngv \u0026ndash; 进入上一次的可视化模式，并选中当时选中的文本**（命令模式也能用此命令）** 按 ESC 键可随时退出可视化模式\n可视化模式下移动光标 命令模式下的光标移动方法仍然适用\n进入任意可视化模式，移动光标，会从当前位置开始，以相应方式高亮选中字符\no \u0026ndash; 移动光标到已经选取的文本的结尾处或者开头处（根据现在光标所在位置确定）\n如果是块可视化模式，移动光标到对角处 O \u0026ndash; 在块可视化模式下，移动光标到同一行的结尾处或者开头处\n可视化模式下编辑 大部分命令模式对内容操作的命令都能在可视化模式下使用，比如：\nd \u0026ndash; 删除高亮文本\nD \u0026ndash; 删除一整行文本，即使只有一部分被选中了\nc \u0026ndash; 删除高亮文本并进入插入模式\ny \u0026ndash; 复制高亮文本\nY \u0026ndash; 复制一整行文本\np \u0026ndash; 黏贴复制的文本\n~ \u0026ndash; 对高亮文本进行大小写转换\n\u0026gt; / \u0026lt; \u0026ndash; 对高亮文本增加/减少缩进，幅度为一个Tab键\nr \u0026ndash; 输入单个字符，把高亮文本所有字符逐个替换为该字符\nvim宏录制 宏录制的录制操作 假设需要将文本的每一行的行首插入入一个 tab 键\n先将光标移动到第一行，在普通模式下按下 q 键（宏录制是 q 键启动的) 按一个 a （字母随意）,表示该宏注册为 a 按下 I 在行首插入一个 tab 键 按下ESC退出编辑模式 按下 j 将光标移动到下一行行首 按下 q 键完成录制操作（宏录制是 q 键结束的） 主要步骤：q(开始）-\u0026gt; a(命名) -\u0026gt; 操作 -\u0026gt; q(结束)\n宏录制的使用 @a \u0026ndash; 执行a宏录制的一系列动作，注意a是录制的操作名称 n@a \u0026ndash; 执行n次a宏 @@ \u0026ndash; 重复上一次使用的宏操作 VIM相关案例 VIM缓存泄露 vim交换文件 在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容\n现在用vim打开文件1.txt，直接关闭终端，再次试图用vim打开1.txt时会出现如下提示：\n选择恢复（R），弹出如下提示：\nVim 中，当处理同一个文件发生多次异常退出时，它会依次使用不同的后缀来命名交换文件。按照你给出的模式，首次产生的交换文件名为 .index.php.swp，再次意外退出后产生 .index.php.swo，第三次产生的交换文件为 .index.php.swn。\n从第四次开始及之后的交换文件，Vim 会循环使用这三个后缀（.swp, .swo, .swn）\n例题 使用以下命令获取网站中的vim文件缓存：\nwget http://xxx/.index.php.swp -P /home //-P指定下载位置 使用vim -r恢复文件并打开:\nvim -r .index.php.swp 获取到网站源码后，进行代码审计即可\n","date":"2025-05-08T15:28:02+08:00","permalink":"https://blog.928330.xyz/p/vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Vim编辑器完全使用教程"}]