[{"content":"模式 定义模式 CREATE SCHEMA 模式名 AUTHORIZATION 用户名\neg:为用户ZHANG定义一个S-T模式：\nCREATE SCHEMA \u0026#34;S-T\u0026#34; AUTHORIZATION ZHANG eg:为用户ZHANG定义一个未命名的模式：\nCREATE SCHEMA AUTHORIZATION ZHANG 未定义模式名称的时候，默认模式为用户名\n删除模式 DROP SCHEAM 模式名\n普通：用于删除空的模式，如果模式下面有对象（表、视图）等，拒绝删除\nDROP SCHEAM 模式名 CASCADE\n级联：把模式里面的对象一并删除\nDROP SCHEAM 模式名 RESTRICT\n限制：会把对象转移到公共模式保留并删除模式，但如果对象和模式有联系，则拒绝删除模式\n基本表 定义基本元素 数据类型 数据类型 表示内容 CHAR(n) 长度为n的字符型 VARCHAR(n) 最大长度为n的变长字符型 NUMBER(n) 长度为n的数字型 INT 长整型(4B) SMALLINT 短整型(4B) BIGINT 大整型(8B) FLOAT(n) 精度至少为n位的浮点数 DATE 日期，格式为YYYY-MM-DD TIME 时间，格式为HH:MM:SS 列级完整性约束条件 约束条件 意义 PRIMARY KEY 主码（元素唯一不能重复）：当只有一个主码时，可直接在对应的属性列标注 NOT NULL 非空：表示该属性列不能取空值 UNIQUE 唯一值：表示该属性列只能取唯一值 CHECK 检查：检查该列是否满足某个条件，比如CHECK(某属性\u0026gt;20) 表级完整性约束条件 约束条件 意义 PRIMARY KEY(列名1,\u0026hellip;,列名n) 多个主码：当主码由多个属性构成时，\n必须作为表级完整性定义 FOREIGN KEY(列名1) REFERENCES 被参照表(列名1) 外码：被参照的列必须是 PRIMARY KEY 或 UNIQUE 约束 的列，\n本表所有值来源于被参照的列 定义基本表 CREATE TABLE 表名 (列名1 数据类型 列级完整性约束条件, 列名n 数据类型 列级完整性约束条件, 表级完整性约束条件1, 表级完整性约束条件n );\neg:\nCREATE TABLE TAB1 (Ch VARCHAR(10), Nu NUMBER(10), Grade INT NOT NULL, PRIMARY KEY(Ch,Nu), -- 多个主码 FOREIGN KEY(Ch) REFERENCES TAB2(Ch) ); 在模式中定义表 一个模式包含很多基本表，有三种方式在模式里面定义基本表\n创建表的时候指出模式 CREATE TABLE 模式名.表名();\n创建模式时直接定义表 CREATE SCHEMA 模式名 AUTHORIZATION 用户名 CREATE TABLE 表名();\n事先设置所属的模式 SET SCHEMA \u0026lsquo;my_schema\u0026rsquo;\neg.\nSET SCHEMA \u0026#39;my_schema\u0026#39;; CREATE TABLE my_table ( id INT PRIMARY KEY, name VARCHAR(100) ); my_table 将被创建在 my_schema 模式下\n修改基本表 同样的，修改表时想要指定模式里面的表，就使用“模式名.表名”的方式指定表名\n增加新的属性列 ALTER TABLE 表名 ADD 新列名 数据类型 完整性约束条件;\neg.向TAB1里增加时间列Time：\nALTER TABLE TAB1 ADD Time DATE; 当然，还能在ADD后面加上修饰词COLUMN，这样会更容易理解是在添加列，对功能没有影响：\nALTER TABLE TAB1 COLUMN Time DATE; ~~~~~~ 增加列级完整性约束条件 ALTER TABLE SC ADD 列级完整性约束条件;\neg.向TAB1里增加Grade列必须取唯一值的条件：（Grade必须要已经存在）\nALTER TABLE TAB1 ADD UNIQUE(Grade); 增加表级完整性约束条件 ALTER TABLE SC ADD 表级完整性约束条件;\neg.向TAB1里增加Ch为外码的条件，参照表是TAB2：\nALTER TABLE TAB1 ADD FOREIGN KEY(Ch) REFERENCES TAB2(Ch); 删除列 ALTER TABLE 表名 DROP CASCADE;\n级联：引用了该列的其他对象（例如视图）一起删除\nALTER TABLE 表名 DROP RESTRICT;\n限制：若该列被其他对象引用，则拒绝删除\n删除指定的完整性约束条件 ALTER TABLE 表名 DROP CONSTRAINT 完整性约束名 CASCADE/RESTRICT;\n修改列 ALTER TABLE 表名 ALTER COLUMN 列名 数据类型;\neg.把Grade由INT型修改成字符型：\nALTER TABLE 表名 ALTER COLUMN 列名 数据类型； 删除基本表 DROP TABLE 表名 CASCADE;\n级联：把表相关的依赖对象（比如视图）一并删除\nDROP TABLE 表名 RESTRICT;\n限制：如果此表被其他表依赖（外码）或者有视图等，拒绝被删除\n索引 建立索引 建立唯一索引 CREATE UNIQUE INDEX 索引名 ON 表名(列名1 次序,列名n 次序);\n唯一索引 是关于数据值是否唯一的，它强制数据的唯一性，并帮助快速查找特定值\neg.为表TAB1按照学号升序和时间降序建立唯一的索引：\nCREATE UNIQUE INDEX NewIndex ON TAB1(Nu ASC,Time DESC); ASC：asceding，升序 DESC：descending，降序\n建立聚簇索引 CREATE CLUSTER INDEX 索引名 ON 表名(列名1 次序,列名n 次序);\n聚簇索引 是关于数据如何物理存储的，它把数据和索引紧密地绑定在一起，让查找和范围查询非常快\n重命名索引 ALTER INDEX 旧索引名 RENAME TO 新索引名;\neg.把TAB1表的NewIndex索引重命名为OldIndex：\nALTER INDEX NewIndex RENAME TO OldIndex; 删除索引 DROP INDEX 索引名;\n查询数据\u0026ndash;SELECT语句 一般格式 SELECT ALL/DISTINCT 目标列表达式\nFROM 表名/视图名\nWHERE 条件表达式\nGROUP BY 列名 HAVING 条件表达式\nORDER BY 列名 次序;\nSELECT 目标列表达式 查询指定的列 SELECT 列名1，列名n\neg.查询TAB1的Ch列和Nu列：\nSELECT Ch,Nu FROM TAB1; 查询全部的列 SELECT *\neg.查询TAB1的全部记录：\nSELECT * FROM TAB1; 查询计算后的值 SELECT 表达式\n表达式可以是算术表达式（+、-\u0026hellip;)，字符串常量，函数等等\neg.查询TAB1里面所有Grade减去2的值：\nSELECT Grade-2 FROM TAB1; 改变查询结果的列标题 SELECT 列名 别名\neg.查询TAB1里面的Ch列和Nu列，在结果里面使用Chinese和Num显示\nSELECT Ch Chinese,Nu Number FROM TAB1; 去除查询结果的重复行 SELECT DISTINCT 列名\n如果没有使用DISTINCT，默认为ALL\n聚集函数 聚集函数只处理非空值\n聚集函数只能用于SELECT语句和CROUP BY中的HAVING子句\n统计元组个数 COUNT(*)\n某个元组的一个或者部分取空值的时候，不影响统计结果\neg.查询TAB1里面的总数：\nSELECT COUNT(*) FROM TAB1; 统计某一列值的个数 COUNT(DISTINCT/ALL 列名)\n指定DISTINCT会去重，NULL不计入总数\n计算某一列值的平均数（该列必须为数值型） AVG(DISTINCT/ALL 列名)\neg.查询TAB1里面的Grade平均值：\nSELECT AVG(ALL Grade) FROM TAB1; 计算某一列值的总和（该列必须为数值型） SUM(DISTINCT/ALL 列名)\n计算某一列值的最大值/最小值 MAX/MIN(DISTINCT/ALL 列名)\nWHERE 条件表达式 比较大小 WHERE 列名 运算式\n常用运算符：=\t\u0026gt;\t\u0026lt;\t\u0026gt;=\t\u0026lt;=\t!=/\u0026lt;\u0026gt;\t!\u0026gt;\t!\u0026laquo;/mark\u0026gt;\neg.查询TAB1里面所有三年级（Grade=3）的学生的姓名：\nSELECT Ch FROM TAB1 WHERE Grade=3; eg.查询TAB1里面所有学号2300开头学生（Nu\u0026gt;23000）的学生的年级：\nSELECT Grade FROM TAB1 WHERE Nu\u0026gt;23000; 确定范围 WHERE 列名 BETWEEN 最小值 AND 最大值\nWHERE 列名 NOT BETWEEN 最小值 AND 最大值\neg.查询TAB1里面年级在1到3之间的学生的姓名：\nSELECT Ch FROM TAB1 WHERE Grade BETWEEN 1 AND 3; eg.查询学号不在23000到24000之间的学生的姓名：\nSELECT Ch FROM TAB1 WHERE NOT Nu BETWEEN 23000 AND 24000; 确定集合 WHERE 列名 IN (\u0026lsquo;列值1\u0026rsquo;,\u0026lsquo;列值n\u0026rsquo;)\nWHERE 列名 NOT IN (\u0026lsquo;列值1\u0026rsquo;,\u0026lsquo;列值n\u0026rsquo;)\neg.查询学号不是23001也不是23002的学生年级：\nSELECT Grade FROM TAB1 WHERE Nu NOT IN (\u0026#39;23001\u0026#39;,\u0026#39;23002\u0026#39;); 相当于多重条件查询的=语句\n字符匹配 百分号 % 表示任意长度的字符串(类似正则.*)，比如a%b就是以a开头，b结尾的任意长度字符串\n下划线 _ 表示单个字符，比如a_ _ _b（不用空格，这里方便看）是以a开头b结尾的长度为5的字符串\n在ASCII码表里，一个汉字长度为2，需要两个下划线\n反斜杠 \\ 表示转义，跟在 % 和 _ 前面（\\% 、\\_）让他们变成普通字符而非通配符\n使用 ESCAPE \u0026lsquo;符号\u0026rsquo; 设置转义字符，但一般使用反斜杠 根据环境决定要不要加上ESCAPE（有的数据库默认由\\转义）\nWHERE 列名 LIKE \u0026lsquo;字符串\u0026rsquo; ESCAPE \u0026lsquo;\\\u0026rsquo;\nWHERE 列名 NOT LIKE \u0026lsquo;字符串\u0026rsquo; ESCAPE \u0026lsquo;\\\u0026rsquo;\neg.查询TAB1中姓名满足a%i_e的学生的年级：\nSELECT Grade FROM TAB1 WHERE Ch LIKE \u0026#39;a%i_e\u0026#39;; 空值查询 WHERE 列名 IS NULL\nWHERE 列名 IS NOT NULL\neg.查询TAB1中缺少学号的学生的年级：\nSELECT Grade FROM TAB1 WHERE Nu IS NULL; 多重条件查询 WHERE 条件表达式1 AND 条件表达式2\nWHERE 条件表达式1 OR 条件表达式2\n可以把AND和OR组合使用，其中AND优先级大于OR\nGROUP BY 列名 HAVING 条件表达式 用于将查询结果按某一列或多列的值分组，值相等的为一组 目的是细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，每一组都有一个函数值\nGROUP BY 列名 eg.求TAB1表里面各个年级和对应的人数：\nSELECT Grade,COUNT(Ch) FROM TAB1 GROUP BY Grade; 以Grade分组，在每一组中求取Ch的数量\nGROUP BY 列名 HAVING 筛选条件 HAVING用于从组中选择满足条件的组 WHERE用于从基本表或视图中选择满足条件的元组（注意：WHERE子句不可以接聚集函数）\neg.求TAB1表里面各个年级和对应的人数：\nSELECT Grade,COUNT(Ch) FROM .TAB1 GROUP BY Grade HAVING GRADE\u0026gt;=2; 以Grade分组，在每一组中求取Ch的数量\nORDER BY 次序 ORDER BY 列名1 列名n ASC\nORDER BY 列名1 列名n DESC\n如果不设置，默认升序（ASC）\neg.查询TAB1中学生的年级，按照降序排列：\nSELECT Grade FROM TAB1 ORDER BY GRADE DESC; 连接查询 两表连接查询 WHERE 表名1.列名1 比较运算符 表名2.列名2\n当列名在参与连接的各表中唯一时，可省去表名前缀\neg.查询TAB1和TAB2中所有数据，并在一个查询结果里面展示\nSELECT STUDY.TAB1.*,STUDY.TAB2.* FROM STUDY.TAB1,STUDY.TAB2 WHERE TAB1.Nu=TAB2.Nu; 若想获得自然连接，则列举全部属性列，并去掉一个相同的属性列即可。可以将上述SELECT语句改写如下：\nSELECT Ch,Grade,Cla,Hom,STUDY.TAB2.Nu -- 去掉了其中一个Nu FROM STUDY.TAB1,STUDY.TAB2 WHERE TAB1.Nu=TAB2.Nu; eg.在TAB1和TAB2里查询选了英语课，并且是三年级的学生的学号:\nSELECT STUDY.TAB1.Nu FROM STUDY.TAB1,STUDY.\u0026#34;tab2\u0026#34; WHERE CLA=\u0026#39;ENGLISH\u0026#39; AND GRADE=3; 单表连接查询 通过取两个别名，对同一个表进行自连接\neg.查询cla和cla2相同的学生学号：\nSELECT FIRST.*,SECOND.* FROM STUDY.TAB2 FIRST,STUDY.tab2 SECOND WHERE FIRST.CLA=SECOND.CLA2; 外连接查询 左外连接保留左表的所有记录，并尽可能地匹配右表中的记录 右外连接保留右表的所有记录，并尽可能地匹配左表中的记录\n将悬浮元组保留在结果关系中，没有属性值的位置填上NULL\nSELECT 列名 FROM 表名1 LEFT OUTER JOIN 表名2 ON(连接条件)\nSELECT 列名 FROM 表名1 RIGHT OUTER JOIN 表名2 ON(连接条件)\neg.以TAB1为主体，列出每个学生选课cla的结果\nSELECT STUDY.TAB1.Ch,CLA FROM STUDY.TAB1 LEFT OUTER JOIN STUDY.TAB2 ON(STUDY.TAB1.Nu=STUDY.TAB2.Nu); 此时会保留TAB1里面的所有记录，匹配对应的TAB2记录\n多表连接查询 WHERE 表名1.列名1 = 表名2.列名2 AND 表名2.列名2 = 表名3.列名3\n多表连接一般是先进行两个表的连接操作，再将其连接结果与第三个表执行连接\n嵌套查询 查询块：SELECT-FROM-WHERE 嵌套查询：将一个查询块嵌套在另一个查询块的WHERE子句或者HAVING子句 上层的查询块称为外层查询/父查询；下层的查询块称为内层查询/子查询 子查询的SELECT语句中不能使用ORDERBY子句，ORDERBY子句只能对最终查询结果排序\n集合判断IN子查询 WHERE 列名 IN (子查询)\neg.查询alice的年级：\nSELECT GRADE FROM STUDY.TAB1 WHERE CH=\u0026#39;alice\u0026#39;; 查询结果为alice在三年级，再查找三年级的其他学生：\nSELECT CH,NU FROM STUDY.TAB1 WHERE GRADE=3; 上面两个查询结合为嵌套查询：\nSELECT CH,NU FROM STUDY.TAB1 WHERE GRADE IN (SELECT GRADE FROM STUDY.TAB1 WHERE CH=\u0026#39;alice\u0026#39; ); 本例的子查询条件不依赖于父查询，这类子查询称为不相关子查询\n比较运算符子查询 WHERE 列名 比较运算符 (子查询)\n当明确知道子查询结果是单个值而不是集合的时候使用\neg．在SC表中，找出每个学生（Sno）超过他自己选修课程平均成绩（Grade）的课程号（Cno)\nSELECT Sno, Cno FROM SC x -- x是表 SC 的别名，又称为元组变量，可以用来表示 SC 的一个元组 WHERE Grade \u0026gt;= (SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); 这里必须加上WHERE y.Sno=x.Sno这个条件，此时内外对应的sno才会相同，否则求的不是单个学生的平均成绩，而是所有学生的平均成绩\n本例的子查询条件依赖于父查询，这类子查询称为相关子查询，整个查询称为相关嵌套查询\nANY/ALL子查询 WHERE 列名 比较运算符 ANY/ALL (子查询)\n谓词 语义 与聚集函数或 IN 的等价转换 \u0026gt;ANY 大于子查询结果中的某个值 \u0026gt;MIN \u0026gt;ALL 大于子查询结果中的所有值 \u0026gt;MAX \u0026lt;ANY 小于子查询结果中的某个值 \u0026lt;MAX \u0026lt;ALL 小于子查询结果中的所有值 \u0026lt;MIN \u0026gt;=ANY 大于等于子查询结果中的某个值 \u0026gt;=MIN \u0026gt;=ALL 大于等于子查询结果中的所有值 \u0026gt;=MAX \u0026lt;=ANY 小于等于子查询结果中的某个值 \u0026lt;=MAX \u0026lt;=ALL 小于等于子查询结果中的所有值 \u0026lt;=MIN =ANY 等于子查询结果中的某个值 IN =ALL 等于子查询结果中的所有值（通常无实际意义） \u0026ndash; !=(或\u0026lt;\u0026gt;)ANY 不等于子查询结果中的某个值 \u0026ndash; !=(或\u0026lt;\u0026gt;)ALL 不等于子查询结果中的任何值 NOT IN eg.查询TAB1里面三年级学生学号大于23000的：\nSELECT Ch FROM STUDY.TAB1 WHERE Nu\u0026gt;=ANY (SELECT Nu FROM STUDY.\u0026#34;tab1\u0026#34; WHERE Grade=3 ); EXISTS子查询 EXISTS代表存在量词，对应的为NOT EXISTS\nEXISTS谓词的子查询不返回数据，只返回逻辑\u0026rsquo;true\u0026rsquo;和\u0026rsquo;false\u0026rsquo;\neg1.在SC表中查询至少选修了1号学生选修的全部课程（Cno）的学生的学号（Sno)\n查询学号为 x 的学生，对所有的课程 y，只要 1 号学生选修了课程 y，则 x 也选修了 y。\n令 p 表示\u0026quot;学生 1 号选修了课程 y\u0026quot;\n令 q 表示\u0026quot;学生 x 选修了课程 y\u0026quot;\n则上述查询可以表示为(∀y)p→q\n通过等价转换，可得(∀y)p→q ≡ ¬(∃y(¬(p→q))) ≡ ¬(∃y(¬(¬p∨q))) ≡ ¬∃y(p∧¬q)\n最终用 SQL 实现的表达式 ¬∃y(p∧¬q)，语义：不存在这样的课程 y，学生 1 号选修了 y，而学生 x 没有选修\nSELECT DISTINCT Sno FROM SC SCX WHERE NOT EXISTS (SELECT * -- 由EXISTS引I出的子查询，其目标列表达式通常都用* FROM SC SCY WHERE SCY.Sno=\u0026#39;1\u0026#39; AND NOT EXISTS (SELECT * FROM SC SCZ WHERE SCZ.Sno = SCX.Sno AND SCZ.Cno = SCY.Cno) -- 保证内外指向相同的学生 ); eg2.基于 SC 表，查询选修了全部课程（Course 表）的学生姓名（Student 表）\n令 p 表示\u0026quot;课程 x 被学生 y 选修了\u0026quot;，则有(∀x)p ≡ ¬(∃x(¬p))，语义：查询没有任何课程是其不选修的学生 y\nSELECT Sname FROM Student WHERE NOT EXISTS (SELECT * FROM Course WHERE NOT EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=Course.Cno) ); 集合查询 多个SELECT语句的结果可以进行集合的并（UNION)、交（INTERSECT)、差（EXCEPT） 参加集合操作的各查询结果的列数必须相同，对应项的数据类型也必须相同\nUNION并操作（满足前者或满足后者） UNION合并查询结果时，系统会自动去掉重复元组，若需保留，则采用UNIONALL\neg.在TAB2中查询学号大于等于23003的学生和选择了MATH科目的学生\nSELECT * FROM STUDY.TAB2 WHERE Nu\u0026gt;=23003 UNION SELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;MATH\u0026#39; OR CLA2=\u0026#39;MATH\u0026#39;; INTERSECT交操作（前后都满足） eg.在TAB2中查询选了MATH又选了history的学生\nSELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;history\u0026#39; OR CLA2=\u0026#39;history\u0026#39; INTERSECT SELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;MATH\u0026#39; OR CLA2=\u0026#39;MATH\u0026#39;; EXCEPT差操作（满足前者，不满足后者） eg.在TAB2中查询学号大于23002的学生和选修了MATH的学生的差集\nSELECT * FROM STUDY.TAB2 WHERE Nu\u0026gt;23002 EXCEPT SELECT * FROM STUDY.TAB2 WHERE CLA=\u0026#39;MATH\u0026#39; OR CLA2=\u0026#39;MATH\u0026#39;; 基于派生表的查询 子查询出现在FROM子句时，子查询将生成临时的派生表，成为主查询的查询对象\nFROM (子查询) AS 别名 (属性列名1,属性列名2)\n如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其默认属性 AS可以省略，但必须为派生表关系指定一个别名\neg1.找出每个学生超过他自己选修课程平均成绩的课程号\nSELECT Sno, Cno FROM SC, (SELECT Sno, Avg(Grade) FROM SC GROUP BY Sno ) AS Avg_sc(avg_sno, avg_grade) WHERE SC.Sno = Avg_sc.avg_sno AND SC.Grade\u0026gt; =Avg_sc.avg_grade; eg2.查询所有选修了1号课程的学生姓名\nSELECT Sname FROM Student, (SELECT Sno FROM SC WHERE Cno=\u0026#39;1\u0026#39; ) AS SC1 WHERE Student.Sno=SC1.Sno; 插入数据\u0026ndash;INSERT语句 插入元组 一般格式 INSERT\nINTO 表名(列名1,列名n)\nVALUES(常量1,常量n); //字符串常量要用单引号\u0026rsquo;\u0026lsquo;括起来\n假设现在有TAB1表，有C1到C4四列，其中C4列是字符串常量： 情况1：明确给出新增元组要在哪些属性上赋值（插入数据包含全部属性列） INSERT INTO TAB1(C1,C2,C3,C4) VALUES(1,2,3,\u0026#39;4\u0026#39;); 情况2：明确给出新增元组要在哪些属性上赋值（插入数据只包含部分属性列） INSERT INTO TAB1(C1,C2,C3) VALUES(1,2,3) 这种情况下C4列会被赋值NULL，如果C4有约束条件NOT NULL则会报错\n情况3：仅指出要在TAB1表上插入元组（插入数据包含全部属性列） INSERT INTO TAB1 VALUES(1,2,3\u0026#39;4\u0026#39;); 这种情况表示要在全部属性列上赋值，插入数据顺序必须和列的顺序对应\n情况4：仅指出要在TAB1表上插入元组（插入数据只包含部分属性列） INSERT INTO TAB1 VALUES(1,2,3,NULL); 这种情况必须明确未赋值的属性列为NULL\n插入子查询结果 一般格式 INSERT\nINTO TAB1(属性列1,属性列2)\n子查询;\neg.假设现有TAB1表（如上），并按C1列分组求C2列的平均值，并存入TAB2表（其中TAB2表的C1列存放 C1，avg_C2列存放C2列的均值)\nINSERT INTO TAB2 (C1, avg_C2) SELECT C1, AVG(C2) FROMTAB1 GROUP BY C1; 修改数据\u0026ndash;UPDATE语句 一般格式 UPDATE 表名\n==SET 列名1=表达式1,列名n=表达式n\nWHERE 条件;==\nWHERE语句若省略，则表示修改表中所有元组\n情况1：修改某一个元组的值 UPDATE TAB1 SET C4=\u0026#39;0\u0026#39; WHERE C1=1; 情况2：修改多个元组的值 UPDATE TAB1 SET C3=C3+1; 情况3：带子查询的修改语句 UPDATE TAB1 SET C4=\u0026#39;0\u0026#39; WHERE C1 IN (SELECT C1 FROM TAB2 WHERE avg_C2=2 ); 删除语句\u0026ndash;DELETE语句 一般格式 DELETE\nFROM 表名\nWHERE 条件;\nWHERE语句若省略，则表示删除表中所有元组\n情况1：删除某一个元组的值 DELETE FROM TAB1 WHERE C1=1; 情况2：修改多个元组的值 DELETE FROM TAB1 情况3：带子查询的修改语句 DELETE FROM TAB1 WHERE C1 IN (SELECT C1 FROM TAB2 WHERE avg_C2=2 ); VIEW 视图 建立视图 一般格式 CREATE VIEW 视图名 (列名1,列名n)\nAS 子查询\nWITH CHECK OPTION;\n若省略视图名后的列名，则该视图由子查询中SELECT的目标列字段组成\n若添加WITH句，则表示对视图进行增删改时要满足子查询中的条件表达式\n在以下情况中必须明确指定组成视图的列名： 1.某个目标列不是单纯的列名，而是聚集函数或列表达式 2.多表连接时选出了几个同名列作为视图的字段 3.需要在视图中为某个列启用新的更合适的名字\n行列子集视图：由单个基本表导出，仅去掉了基本表的某些行和某些列，但保留了主码\n若某些视图是建立在另一个表的全部属性列上的（视图与基本表的各列是一一对应的）那么当修改基本表的结构时，基本表和视图的映像关系会被破坏。这种情况最好在修改基本表后删除该视图，然后重建该视图\n情况1：建立完全视图 eg1.建立C1为1时TAB1的视图\nCREATE VIEW V_TAB1 AS SELECT C1,C2,C3,C4 FROM TAB1 WHERE C1=1; 情况2：建立带有增删改条件的视图 eg2.建立C4为4时TAB1的视图，并且以后每次增删改时都要满足C4=4\nCREATE VIEW V_TAB2 AS SELECT C1,C2,C3,C4 FROM TAB1 WHERE C4=\u0026#39;4\u0026#39; WITH CHECK OPTION; 情况3：由视图新建视图 eg3.建立在一个或多个已定义的视图上\nCREATE VIEW V_TAB3 AS SELECT C1,C2,C3 FROM V_TAB1 WHERE C2=2; 情况4：带有派生数据的视图 减少冗余数据，定义基本表时一般只存放基本数据。当需要使用计算得出的派生数据时，可以设置在视图 中的派生属性列上，也称为虚拟列。带虚拟列的视图也称为带表达式的视图\neg4.建立有派生数据的视图\nCREATE VIEW V_TAB4(C1,new_C2) AS SELECT C1,10+C2 FROM TAB1; 情况5：带有聚集函数和GROUP BY的分组视图 eg5.建立包含聚集函数的分组视图\nCREATE VIEW V_TAB5(C1,avg_C2) AS SELECT C1,AVG(C2) FROM TAB1; GROUP BY C1; 删除视图 DROP VIEW 视图名 CASCADE;\n如果使用了CASCADE级联删除语句，则将把该视图导出的所有视图一并删除\n查询和更新视图 视图定义后，对视图进行查询和更新的语句和语法与基本表相同 视图的查询与更新最终都会转换为对基本表的查询和更新，这一过程也被称为视图消解 一般来说，行列子集视图的查询和更新都可以顺利转换，其他则不一定\n空值 判断属性为空值 这部分和WHERE语句里面空值判断一样啦\n属性 IS NULL;\n属性 IS NOT NULL;\neg.查找TAB1中名字为空的学生：\nSELECT * FROM STUDY.TAB1 WHERE Ch IS NULL; 空值的运算 算数运算 空值与另一个值的算术运算结果为空值\nSELECT 5 + NULL; -- 结果为 NULL SELECT 10 / NULL; -- 结果为 NULL 比较运算 空值与另一个值的比较运算结果为 UNKNOWN\nSELECT 5 = NULL; -- 结果为 UNKNOWN SELECT 5 \u0026lt;\u0026gt; NULL; -- 结果为 UNKNOWN SELECT 5 \u0026gt; NULL; -- 结果为 UNKNOWN 在查询语句中的处理 在查询语句中，只有使WHERE和HAVING子句的选择条件为TRUE的元组才会被选出作为输出结果（即不包括UNKNOWN的情况)\neg1:\nSELECT * FROM employees WHERE salary \u0026gt; 50000 AND commission IS NOT NULL; 这个查询会返回所有工资大于 50000 且佣金不为 NULL 的员工记录\neg2:\nSELECT * FROM employees WHERE commission \u0026lt;\u0026gt; 0; 查询过程中commission可能为NULL，这部分运算后产生UNKNOWN，对应元组会被忽略\n要让所有都能被输出，最好做如下改动：\nSELECT * FROM employees WHERE commission \u0026lt;\u0026gt; 0 OR commission IS NULL; 数据库安全 授权 授予用户权限 GRANT 权限 ON 对象类型 对象名 TO 用户名 [WITH GRANT OPTION];\n权限：查询权限 SELECT，全部操作权限 ALL PRIVILEGES\n对象类型：TABLE/VIEW\n对象名：表和视图的名称\n用户名：可以指定用户，也可以全体用户PUBLIC\n如果没有WITH GRANT OPTION语句，那么用户不能传播这个权限\nSQL不允许循环授权，被授权者不能把权限传递给授权者或其祖先\neg.假设我们有一个名为employees的表，现在想让用户user_A只能查询这张表\nGRANT SELECT ON TABLE employees TO user_A; 如果要让A还能把权限授权给别人：\nGRANT SELECT ON TABLE employees TO user_A WITH GRANT OPTION; 收回用户权限 REVOKE 权限 ON 对象类型 对象名 FROM 用户名 [CASCADE/RESTRICT];\nCASCADE：级联回收，把用户传播出去的权限一并收回\nRESTRICT：受限回收，如果用户传播过该权限，回收会失败（默认行为）\neg.收回user_A的权限\nREVOKE SELECT ON TABLE employees FROM user_A; 创建数据库模式的权限 对创建数据库模式一类的数据库对象的授权在数据库管理员创建用户的时候实现\nCREATE USER 用户名 [WITH DBA|RESOURCE|CONNECT];\nDBA：可以创建新用户、模式、表、视图等，还可以把这些权限授予其他用户\nRESOURCE：可以创建表、视图，但是不能创建新的模式和用户\nCONNECT：只能登录数据库，或者被授予权限后操作\n数据库角色 角色是权限的集合，可以为一组相同权限的用户创建同一个角色，使用角色管理权限，简化授权过程\n创建角色 CREATE ROLE 角色名;\n给角色添加角色/用户 GRANT 角色 TO 某角色/某用户 [WITH ADMIN OPTION];\n给角色授权 GRANT 权限 ON 对象类型 对象名 TO 角色；\n收回角色权限 REVOKE 权限 ON 对象类型 对象名 FROM 角色;\n","date":"2025-06-03T01:14:02+08:00","permalink":"https://blog.928330.xyz/p/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AAsql%E9%80%9F%E9%80%9F%E7%9A%84%E9%80%9A/","title":"进行一个SQL速速的通"},{"content":"wireshark过滤语法 运算符 比较运算符 操作符 别名 类C风格 描述 示例 eq any_eq == 等于 ip.src == 10.0.0.5 ne all_ne != 不等于 ip.src != 10.0.0.5 all_eq === 全等 ip.src === 10.0.0.5 any_ne !== 不全等 ip.src !== 10.0.0.5 gt \u0026gt; 大于 frame.len \u0026gt; 10 lt \u0026lt; 小于 frame.len \u0026lt; 128 ge \u0026gt;= 大于或等于 frame.len ge 0x100 le \u0026lt;= 小于或等于 frame.len \u0026lt;= 0x20 contains 协议、字段或切片包含某个值 sip.To contains \u0026ldquo;a1762\u0026rdquo; matches ~ 右侧的正则表达式将被用来匹配左侧的字符串 http.host matches \u0026ldquo;acme.(org|com|net)\u0026rdquo; 等于（==）和全等（===）的区别：\n== 是一种宽松的比较，只要有一个值匹配即可（any if more than one）\n=== 是一种严格的比较，所有可能的值都必须匹配（all if more than one）\n同一个包，使用等于（==）可以过滤出源或目的端口为80报文，使用全等（===）则会匹配源目的端口都为80的报文\nip.addr == 10.0.0.0/8 等价于 ip.src==10.0.0.0/8 || ip.dst==10.0.0.0/8 ip.addr === 10.0.0.0/8 等价于 ip.src==10.0.0.0/8 \u0026amp;\u0026amp; ip.dst==10.0.0.0/8 逻辑运算符 操作符 类C风格 描述 示例 and \u0026amp;\u0026amp; 逻辑与 ip.src == 10.0.0.5 and tcp.flags.fin == 1 or || 逻辑或 ip.src == 10.0.0.5 or ip.src == 192.1.1.1 xor ^^ 逻辑异或，能且只能满足其中一个 tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29 not ! 逻辑非 ! udp […] 不涉及 [a:b]：从第a个字符开始取b个字符 http.request.method**[0:3]**==\u0026ldquo;GET\u0026rdquo; in 不涉及 匹配集合内的元素，代替== http.request.method in {\u0026ldquo;HEAD\u0026rdquo;, \u0026ldquo;GET\u0026rdquo;} 函数 函数 描述 upper 将字符串字段转换为大写 lower 将字符串字段转换为小写 len 返回字符串字段或字节字段的字节长度 count 返回帧中字段的出现次数 string 将非字符串字段转换为字符串 vals 将字段值转换为其值字符串（如果有） dec 将无符号整数字段转换为十进制字符串 hex 将无符号整数字段转换为十六进制字符串 max 返回参数的最大值 min 返回参数的最小值 abs 返回参数的绝对值 upper()、lower() 可以使用这两个函数，将字符串转化为大小写，再进行正则匹配，做到不区分大小写的功能\nlower(http.server) ~ \u0026#34;apache\u0026#34; //过滤HTTP响应头的server字段为apache的 upper(http.request.method) ~ \u0026#34;post|get\u0026#34; //过滤http请求方法为POST或GET len() len()函数将返回字段的字节大小，因此可以和比较操作符配合使用，过滤某个报文字段符合大小要求的报文\nlen(http.request.uri) \u0026gt;= 10 //过滤http头部的URI字段，大于等于10字节的报文 len(http.host) \u0026gt;= 20 //过滤HTTP主机名大于等于20字节的报文 string() 当字段为非字符串类型，而又想转换为字符串字段再进行正则匹配时，很方便\nstring(ip.addr) ~ \u0026#34;^10|^11\u0026#34; //过滤IP为10网段开头或者23网段开头的IP string(ip.dst) matches r\u0026#34;^172\\.(1[6-9]|2[0-9]|3[0-1])\\.[0-9]{1,3}\\.255\u0026#34; //匹配目的IP中以255结尾的IP地址(172.16到172.31) max()、min() max()和min()接受相同类型的任意数量的参数，并分别返回集合中最大/最小的参数\nmax(tcp.srcport,tcp.dstport) \u0026lt;= 1024 //过滤tcp源端口、目的端口，最大不能超过1024的报文 min(tcp.srcport+tcp.dstport) \u0026gt;= 1024 //过滤tcp源端口+目的端口大于等于1024的报文 过滤IP 1）源地址为192.168.0.1的包\nip.src == 192.168.0.1 2）目的地址为192.168.0.1的包\nip.dst == 192.168.0.1 3）源地址或目的地址是192.168.0.1的包\nip.addr == 192.168.0.1 要原地址和目标地址一样就用===\n4）排除上述包\n!(表达式) 过滤协议 1）仅捕获某种协议的包\n直接写协议名即可，如http（区分大小写）\n2）捕获多种协议的包\n使用逻辑或\nhttp or telent 3）排除某种协议的包\n使用逻辑非\nnot http ! http 过滤端口（需要指明协议） 1）捕获某一端口的包\ntcp.port == 80 2）捕获多端口的包\n可以用and来表示多端口并列\ntcp.port == 80 and 8080 也可以用比较运算符\nudp.port \u0026gt;= 2048 过滤长度、内容 1）长度（数据段的长度）\nudp.length \u0026gt;= 30 //udp的payload长度 http.content_length \u0026lt;= 20 //http消息体长度 2）数据包内容\n使用matches/contains\n过滤时间 frame.time \u0026gt;= \u0026#34;Apr 16, 2021 06:00:00.0\u0026#34; \u0026amp;\u0026amp; frame.time \u0026lt;= \u0026#34;Apr 16, 2021 06:59:00.0\u0026#34; frame.time \u0026gt; \u0026#34;2024-04-11 11:00:00\u0026#34; and frame.time \u0026lt; \u0026#34;2024-04-11 11:01:00\u0026#34; 注意：时间是字符串，要用双引号括起来\ntshark基本命令 -r \u0026ndash; 从一个已有的捕获文件读取数据包进行分析 **-r 111.pcap：**从名为 111.pcap 的文件中读取数据包并简略打印出来\neg:\n1.837951 192.168.1.12 -\u0026gt;192.168.1.5 TCP 72 8080 -\u0026gt; 45940 [FIN, ACK] Seq=1 ... ​ 时间戳 原IP 目标IP 协议 数据包长度 源端口 目标端口 报文标头信息\n-n/-N \u0026ndash; 禁止反向解析 -n \u0026ndash; 禁用域名解析，不对 IP 地址和端口号进行名称解析 默认情况下，tshark 会尝试将捕获到的 IP 地址解析为主机名（192.168.1.1-\u0026gt;exaple.com），同时也会将端口号转换为服务名称（如 80 变成 http，443 变成 https 等）\n通过使用 -n 参数，可以避免这些解析，直接显示原始的 IP 地址和端口号\neg:\ntshark -r file.pcap //直接输出 192.168.1.1 -\u0026gt; example.com 80 tshark -n -r file.pcap //-n输出 192.168.1.1 -\u0026gt; 93.184.216.34 80 -N \u0026ndash; 精准控制解析哪些层级 格式：-N \u0026lt;反向解析flag1\u0026gt; -N \u0026lt;反向解析flag2\u0026gt;\u0026hellip;\nflag取值 含义 d 对于DNS包启用解析 m 启用MAC地址解析 n 启用网络地址解析 N 使用外部解析器（例如DNS）进行网络地址解析，n需要被同时启用才有效果 t 启用传输层端口解析 v 启用VLAN ID的名称解析 eg：\ntshark -r file.pcap //直接输出 1.837951 192.168.1.12 -\u0026gt; 192.168.1.5 TCP 72 45940 -\u0026gt; 80 [FIN, ACK] Seq=1 Ack=2 ... tshark -N t -r file.pcap //-N t(解析传输层端口)输出 1.837951 192.168.1.12 -\u0026gt; 192.168.1.5 TCP 72 45940 -\u0026gt;(http)80 [FIN, ACK] Seq=1 Ack=2 ... ↑ -T \u0026ndash; 指定输出格式 **-T fields：**仅输出指定的字段（需配合 -e 使用）\n**-T text：**以普通文本格式输出（默认）\n**-T json：**以 JSON 格式输出\n**-T jsonraw：**以 JSON（包含原始数据）格式输出\n**-T ek：**以 ElasticSearch 格式输出\n-e \u0026ndash; 指定显示数据包中的特定字段 格式：-e \u0026ldquo;字段1\u0026rdquo; -e \u0026ldquo;字段2\u0026rdquo;\u0026hellip;\n**ip.src：**显示源 IP 地址\n**ip.dst：**显示目标 IP 地址\n**http.host：**显示 HTTP 请求中的主机名\n**http.request.uri：**显示 HTTP 请求中的 URI（即请求的 URL 路径）\n**usbhid.data：**只提取USB HID 设备数据\n**frame.number：**显示数据包的报文帧数\n**frame.time：**显示数据包捕获的时间戳\n**frame.len：**显示数据包的长度\neg:\ntshark -n -r file.pcap -e \u0026#34;frame.number\u0026#34; -e \u0026#34;ip.addr\u0026#34; -e \u0026#34;tcp.port\u0026#34; -e tcp -T fields //输出报文帧数、ip地址、端口、tcp协议的字段 1 192.168.1.12,192.168.1.8 37546,80 Transmission Control Protocol,SrcPort: ... 报文帧数 ip地址 端口 tcp协议的字段 -Y \u0026ndash; 筛选过滤报文 格式：-Y \u0026ldquo;过滤条件\u0026rdquo;\n用来过滤分析符合过滤表达式的报文，相当于wireshark最上面的过滤筛选栏功能\neg:\ntshark -n -r \u0026lt;filename\u0026gt; -Y \u0026#34;http.host == \u0026#34;web-server1\u0026#34;\u0026#34; //通过http.host过滤 tshark -n -r http-keep-alive.pcap -Y \u0026#34;tcp.flags.syn==1\u0026amp;\u0026amp;tcp.flags.ack==0\u0026#34; //过滤第一次握手的请求 -E \u0026ndash; 设置输出的控制字段 通过-T参数来输出特定格式时，可以配合-E参数来设置一些选项\n参数选项 默认 含义 bom=y|n n 在输出前加上UTF-8字节顺序标记（十六进制ef、bb、bf） header=y|n n 打印一个使用-e作为输出第一行的字段名称头部 separator=/t|/s|\u0026lt;character\u0026gt; /t 设置字段分隔符，默认为/t，可以指定/s，即单个空格，或者自定义的其它字符 occurrence=f|l|a a 打印每个字段的第一次(f)/最后一次(l)/或所有出现的内容(a) aggregator=,|/s|\u0026lt;character\u0026gt; , 设置用于每个字段内的分割字符 quote=d|s|n n 设置用于环绕字段的引号字符 n是null，无设置\neg:\ntshark -n -r file.pcap -E header=y -E occurrence=l -Y \u0026#39;icmp.seq==21\u0026#39; -e \u0026#39;icmp.seq\u0026#39; ... -T fields |column -t // -E occurrence=l：包通过IPIP封装，occurrence=l指定输出外层IP // -Y \u0026#39;icmp.seq==21\u0026#39;：指定icmp.seq等于21的ICMP包 // | column -t：将输出通过管道传输给 column 命令，使结果以表格的形式对齐 icmp.seq ip.src ip.dst ip 21 114.132.116.32 113.145.123.23 Internet Protocol Version 4，Src:，Dst: -2 \u0026ndash; 二次依赖分析 没有2以外的参数\ntshark会根据上下文报文的依赖关系（tshark称之为two-pass，即进行两次分析），来显示相关报文关联信息，如：response in frame #、reply in frame、TCP Port numbers reused\n-i \u0026ndash; 指定要捕获数据的网络接口 **-i eth0：**表示从 eth0 网络接口捕获数据包\n**-i wlan0：**表示从无线网卡 wlan0 捕获数据包\n**-i any：**表示捕获所有接口的流量\n**-：**表示从标准输入（stdin）捕获数据流\n-f \u0026ndash; 应用捕获过滤器，只捕获特定的流量 **-f \u0026quot;tcp\u0026quot;：**只捕获 TCP 流量\n**-f \u0026quot;port 80\u0026quot;：**只捕获端口为 80（HTTP）的流量\n**-f \u0026quot;src host 192.168.1.1\u0026quot;：**只捕获源地址为 192.168.1.1 的流量\n-w \u0026ndash; 将捕获的数据包写入到文件中 **-w output.pcap：**将捕获的数据包保存到 output.pcap 文件\n**-：**将捕获的内容输出到标准输出（stdout）\noptions \u0026ndash; 其他可选参数 **-V：**显示详细的包信息\n**-c \u0026lt;count\u0026gt;：**捕获指定数量的包后停止\n**-n：**禁止域名解析，使用 IP 地址而不是主机名显示\n\u0026lt;filter\u0026gt; 指定显示过滤器 如果要用过滤器，一定要放到最后\n**ip.addr == 192.168.1.1：**仅显示源或目标地址为 192.168.1.1 的包。\n**tcp.port == 443：**仅显示端口为 443 的 TCP 数据包（通常用于 HTTPS 流量）。\n**http：**仅显示 HTTP 协议的数据包\n","date":"2025-05-14T01:15:30+08:00","permalink":"https://blog.928330.xyz/p/wiresharktshark%E7%AE%80%E6%98%93%E6%8C%87%E5%8C%97/","title":"wireshark\u0026tshark简易指北"},{"content":"吃豆人 连上环境后f12,发现脚本game.js:\nfunction startGame() { document.getElementById(\u0026#34;start-screen\u0026#34;).style.display = \u0026#34;none\u0026#34;; document.getElementById(\u0026#34;game\u0026#34;).style.display = \u0026#34;block\u0026#34;; initGame(); } const canvas = document.getElementById(\u0026#34;game\u0026#34;); const ctx = canvas.getContext(\u0026#34;2d\u0026#34;); const box = 20; let people, balls, score, dx, dy, isGameOver, game; let redBallCount, blueBallCount; let hasGotFlag = false; function initGame() { people = [{ x: 200, y: 200 }]; dx = box; dy = 0; score = 0; isGameOver = false; hasGotFlag = false; redBallCount = 1000; blueBallCount = 1; balls = []; spawnBalls(); if (game) clearInterval(game); game = setInterval(draw, 150); } document.addEventListener(\u0026#34;keydown\u0026#34;, dir); function dir(e) { if (e.key === \u0026#34;ArrowUp\u0026#34; \u0026amp;\u0026amp; dy === 0) { dx = 0; dy = -box; } else if (e.key === \u0026#34;ArrowDown\u0026#34; \u0026amp;\u0026amp; dy === 0) { dx = 0; dy = box; } else if (e.key === \u0026#34;ArrowLeft\u0026#34; \u0026amp;\u0026amp; dx === 0) { dx = -box; dy = 0; } else if (e.key === \u0026#34;ArrowRight\u0026#34; \u0026amp;\u0026amp; dx === 0) { dx = box; dy = 0; } else if (e.key === \u0026#34; \u0026#34;) { // 空格重开 initGame(); } } function draw() { if (isGameOver) return; ctx.clearRect(0, 0, 400, 400); ctx.strokeStyle = \u0026#34;white\u0026#34;; ctx.lineWidth = 2; ctx.strokeRect(0, 0, 400, 400); // ren ctx.fillStyle = \u0026#34;lime\u0026#34;; ctx.fillRect(people[0].x, people[0].y, box, box); // 画球 balls.forEach(ball =\u0026gt; { ctx.fillStyle = ball.color; ctx.beginPath(); ctx.arc(ball.x + box / 2, ball.y + box / 2, box / 2 - 2, 0, Math.PI * 2); ctx.fill(); }); // 人移动 let head = { x: people[0].x + dx, y: people[0].y + dy }; // 碰撞判断 if (head.x \u0026lt; 0 || head.x \u0026gt;= 400 || head.y \u0026lt; 0 || head.y \u0026gt;= 400) { gameOver(); return; } // 吃球逻辑 let ateIndex = balls.findIndex(b =\u0026gt; b.x === head.x \u0026amp;\u0026amp; b.y === head.y); if (ateIndex !== -1) { const eaten = balls[ateIndex]; if (eaten.color === \u0026#34;red\u0026#34;) { score += 1; redBallCount--; } else if (eaten.color === \u0026#34;blue\u0026#34;) { score = score * 5; blueBallCount--; } balls.splice(ateIndex, 1); } people[0] = head; // 胜利检测 if (score \u0026gt;= 5000 \u0026amp;\u0026amp; !hasGotFlag) { fetch(\u0026#39;/submit_score\u0026#39;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ score: score }) }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { if (data.flag) { alert(\u0026#34;🎉 恭喜！你的flag是：\u0026#34; + data.flag); } else { alert(\u0026#34;未达到指定分数！\u0026#34;); } }); hasGotFlag = true; } // 球吃光了 if (balls.length === 0) { if (redBallCount === 0 \u0026amp;\u0026amp; blueBallCount === 0) { if (score \u0026gt;= 5000) { alert(\u0026#34;你赢了！\u0026#34;); } else { alert(\u0026#34;球全吃完了，但分数不足，游戏失败！\u0026#34;); } isGameOver = true; return; } else { spawnBalls(); } } if ( redBallCount \u0026gt; 0 \u0026amp;\u0026amp; balls.every(b =\u0026gt; b.color !== \u0026#34;red\u0026#34;) \u0026amp;\u0026amp; balls.length \u0026gt; 0 ) { spawnBalls(); } ctx.fillStyle = \u0026#34;white\u0026#34;; ctx.fillText(\u0026#34;Score: \u0026#34; + score, 10, 20); ctx.fillText(\u0026#34;Red left: \u0026#34; + redBallCount, 10, 40); ctx.fillText(\u0026#34;Blue left: \u0026#34; + blueBallCount, 10, 60); } function spawnBalls() { let num = Math.floor(Math.random() * 5) + 1; // 即使红球或蓝球库存为 0，也要刷新蓝球位置（如果还在场上） const blueIndex = balls.findIndex(b =\u0026gt; b.color === \u0026#34;blue\u0026#34;); if (blueIndex !== -1) { balls.splice(blueIndex, 1); } if (redBallCount \u0026lt;= 0 \u0026amp;\u0026amp; blueBallCount \u0026lt;= 0) return; // 特例：只生成一个球 if (num === 1) { if (redBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;red\u0026#34;)); } else if (blueBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;blue\u0026#34;)); } return; } // 多于1个球时，先加蓝球（前提：蓝球还未被吃掉） if (blueBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;blue\u0026#34;)); num--; } // 加红球（前提：库存足够） while (num \u0026gt; 0 \u0026amp;\u0026amp; redBallCount \u0026gt; 0) { balls.push(createBall(\u0026#34;red\u0026#34;)); num--; } } function createBall(color) { let x, y; do { x = box * Math.floor(Math.random() * 20); y = box * Math.floor(Math.random() * 20); } while (balls.some(b =\u0026gt; b.x === x \u0026amp;\u0026amp; b.y === y) || (people[0].x === x \u0026amp;\u0026amp; people[0].y === y)); return { x, y, color }; } function gameOver() { alert(\u0026#34;你撞墙了，游戏失败！得分：\u0026#34; + score + \u0026#34;\\n按空格键重新开始\u0026#34;); isGameOver = true; } // 启动 //initGame(); 看下面这一段：\nif (score \u0026gt;= 5000 \u0026amp;\u0026amp; !hasGotFlag) { fetch(\u0026#39;/submit_score\u0026#39;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ score: score }) }) 只要满足score\u0026gt;=5000就能获取 flag\n控制台输入以下命令即可：\nscore = 5000; 麦霸评分 审查代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;f4k3 KTY 评分系统\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; } .container { background-color: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); } .header { text-align: center; margin-bottom: 30px; } .header h1 { color: #e74c3c; margin-bottom: 10px; } .controls { display: flex; flex-direction: column; align-items: center; gap: 20px; margin-bottom: 30px; } .button { padding: 12px 25px; font-size: 16px; background-color: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; } .button:hover { background-color: #c0392b; } .button:disabled { background-color: #95a5a6; cursor: not-allowed; } .result { margin-top: 20px; padding: 15px; border-radius: 4px; text-align: center; } .result-low { background-color: #d6eaf8; color: #2980b9; } .result-medium { background-color: #fdebd0; color: #e67e22; } .result-high { background-color: #d5f5e3; color: #27ae60; } .result-perfect { background-color: #ebdef0; color: #8e44ad; } .audio-container { margin: 20px 0; display: flex; flex-direction: column; align-items: center; } .audio-container h3 { margin-bottom: 10px; } .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); } .modal-content { position: relative; background-color: #fefefe; margin: 15% auto; padding: 30px; border-radius: 8px; width: 70%; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.2); animation: modalopen 0.4s; } @keyframes modalopen { from {opacity: 0; transform: translateY(-30px);} to {opacity: 1; transform: translateY(0);} } .close-button { position: absolute; top: 10px; right: 15px; color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; } .close-button:hover { color: #333; } .flag { margin: 30px 0; padding: 15px; font-size: 20px; font-weight: bold; color: #e74c3c; background-color: #f9ebea; border: 2px dashed #e74c3c; border-radius: 5px; } .timer { font-size: 24px; font-weight: bold; margin: 10px 0; color: #e74c3c; } .visualizer { width: 100%; height: 60px; margin: 20px 0; background-color: #f5f5f5; border-radius: 4px; } .similarity-meter { width: 100%; height: 20px; background-color: #ecf0f1; border-radius: 10px; margin: 15px 0; overflow: hidden; } .similarity-value { height: 100%; width: 0%; background: linear-gradient(to right, #3498db, #2ecc71, #f1c40f, #e74c3c); border-radius: 10px; transition: width 0.5s ease-in-out; } .loader { border: 5px solid #f3f3f3; border-top: 5px solid #e74c3c; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; display: none; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } .cooldown { font-size: 18px; margin-top: 10px; color: #e74c3c; font-weight: bold; } .warning { background-color: #fadbd8; padding: 10px; border-radius: 5px; margin: 10px 0; color: #c0392b; } /* 添加退出确认对话框样式 */ .exit-confirm-modal { display: none; position: fixed; z-index: 2; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); } .exit-confirm-content { position: relative; background-color: #fff2cc; margin: 15% auto; padding: 30px; border-radius: 8px; width: 70%; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.2); animation: modalopen 0.4s; border-left: 5px solid #e74c3c; } .exit-confirm-title { color: #e74c3c; font-size: 20px; margin-bottom: 15px; } .exit-confirm-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 20px; } .exit-confirm-buttons button { padding: 10px 20px; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; } .exit-confirm-stay { background-color: #3498db; color: white; } .exit-confirm-leave { background-color: #e74c3c; color: white; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;KTV 录音评分系统\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;大家都会逆战吧, have a try \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;audio-container\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;逆战\u0026amp;张杰:\u0026lt;/h3\u0026gt; \u0026lt;audio id=\u0026#34;originalAudio\u0026#34; controls\u0026gt; \u0026lt;source id=\u0026#34;originalAudioSource\u0026#34; src=\u0026#34;/original.wav\u0026#34; type=\u0026#34;audio/wav\u0026#34;\u0026gt; 您的浏览器不支持音频播放 \u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;warningMessage\u0026#34; class=\u0026#34;warning\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;timer\u0026#34; class=\u0026#34;timer\u0026#34;\u0026gt;00:00\u0026lt;/div\u0026gt; \u0026lt;canvas id=\u0026#34;visualizer\u0026#34; class=\u0026#34;visualizer\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div class=\u0026#34;similarity-meter\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;similarityValue\u0026#34; class=\u0026#34;similarity-value\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;recordButton\u0026#34; class=\u0026#34;button\u0026#34;\u0026gt;开始录音\u0026lt;/button\u0026gt; \u0026lt;div id=\u0026#34;cooldownTimer\u0026#34; class=\u0026#34;cooldown\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;loader\u0026#34; class=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34; class=\u0026#34;result\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 录音预览 --\u0026gt; \u0026lt;div class=\u0026#34;audio-container\u0026#34; id=\u0026#34;recordingContainer\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;你的录音:\u0026lt;/h3\u0026gt; \u0026lt;audio id=\u0026#34;recordedAudio\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- FLAG弹窗 --\u0026gt; \u0026lt;div id=\u0026#34;flagModal\u0026#34; class=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;modal-content\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;close-button\u0026#34; onclick=\u0026#34;closeModal()\u0026#34;\u0026gt;\u0026amp;times;\u0026lt;/span\u0026gt; \u0026lt;h2\u0026gt;恭喜你！歌神级别！\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;你的演唱简直完美，获得了最高评价！\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;flag\u0026#34; id=\u0026#34;flagContent\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; onclick=\u0026#34;closeModal()\u0026#34;\u0026gt;谢谢\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;exitConfirmModal\u0026#34; class=\u0026#34;exit-confirm-modal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-title\u0026#34;\u0026gt;⚠️ 警告\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;若您退出当下页面，所有录制的录音都会被删除！\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;exit-confirm-buttons\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;stayButton\u0026#34; class=\u0026#34;exit-confirm-stay\u0026#34;\u0026gt;留在页面\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;leaveButton\u0026#34; class=\u0026#34;exit-confirm-leave\u0026#34;\u0026gt;确认退出\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let audioContext; let analyser; let microphone; let mediaRecorder; let audioChunks = []; let isRecording = false; let startTime; let timerInterval; let visualizerContext; // 时间 let lastRequestTime = 0; const MIN_REQUEST_INTERVAL = 10000; // 10秒，与服务器端保持一致 let cooldownInterval = null; // DOM元素 const recordButton = document.getElementById(\u0026#39;recordButton\u0026#39;); const timer = document.getElementById(\u0026#39;timer\u0026#39;); const visualizer = document.getElementById(\u0026#39;visualizer\u0026#39;); const recordingContainer = document.getElementById(\u0026#39;recordingContainer\u0026#39;); const recordedAudio = document.getElementById(\u0026#39;recordedAudio\u0026#39;); const result = document.getElementById(\u0026#39;result\u0026#39;); const loader = document.getElementById(\u0026#39;loader\u0026#39;); const similarityValue = document.getElementById(\u0026#39;similarityValue\u0026#39;); const flagModal = document.getElementById(\u0026#39;flagModal\u0026#39;); const flagContent = document.getElementById(\u0026#39;flagContent\u0026#39;); const cooldownTimer = document.getElementById(\u0026#39;cooldownTimer\u0026#39;); const warningMessage = document.getElementById(\u0026#39;warningMessage\u0026#39;); const originalAudio = document.getElementById(\u0026#39;originalAudio\u0026#39;); const originalAudioSource = document.getElementById(\u0026#39;originalAudioSource\u0026#39;); originalAudio.addEventListener(\u0026#39;error\u0026#39;, function(e) { console.error(\u0026#39;音频加载失败:\u0026#39;, e); warningMessage.textContent = \u0026#39;原始音频加载失败，请刷新页面重试\u0026#39;; warningMessage.style.display = \u0026#39;block\u0026#39;; fetch(\u0026#39;/get-original-audio\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { if (data \u0026amp;\u0026amp; data.url) { console.log(\u0026#39;从API获取音频URL:\u0026#39;, data.url); originalAudioSource.src = data.url + \u0026#39;?t=\u0026#39; + new Date().getTime(); // 添加时间戳防止缓存 originalAudio.load(); } }) .catch(err =\u0026gt; { console.error(\u0026#39;获取音频URL失败:\u0026#39;, err); }); }); // 添加退出确认对话框元素 const exitConfirmModal = document.getElementById(\u0026#39;exitConfirmModal\u0026#39;); const stayButton = document.getElementById(\u0026#39;stayButton\u0026#39;); const leaveButton = document.getElementById(\u0026#39;leaveButton\u0026#39;); let currentRecordingFilename = null; visualizerContext = visualizer.getContext(\u0026#39;2d\u0026#39;); visualizer.width = visualizer.offsetWidth; visualizer.height = visualizer.offsetHeight; recordButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (!isRecording) { if (!canMakeRequest()) { showCooldownMessage(); return; } // 如果有上一段录音，先清理 if (currentRecordingFilename) { cleanRecording(currentRecordingFilename); currentRecordingFilename = null; } startRecording(); } else { stopRecording(); } }); // 检查是否可以发送请求 function canMakeRequest() { const now = Date.now(); return now - lastRequestTime \u0026gt;= MIN_REQUEST_INTERVAL; } // 限时，避免过度请求 function showCooldownMessage() { const now = Date.now(); const remainingTime = Math.ceil((MIN_REQUEST_INTERVAL - (now - lastRequestTime)) / 1000); cooldownTimer.textContent = `请等待 ${remainingTime} 秒后再试`; cooldownTimer.style.display = \u0026#39;block\u0026#39;; if (cooldownInterval) { clearInterval(cooldownInterval); } cooldownInterval = setInterval(() =\u0026gt; { const currentTime = Date.now(); const remaining = Math.ceil((MIN_REQUEST_INTERVAL - (currentTime - lastRequestTime)) / 1000); if (remaining \u0026lt;= 0) { clearInterval(cooldownInterval); cooldownTimer.style.display = \u0026#39;none\u0026#39;; cooldownTimer.textContent = \u0026#39;\u0026#39;; } else { cooldownTimer.textContent = `请等待 ${remaining} 秒后再试`; } }, 1000); } function updateTimer() { const elapsedTime = Math.floor((Date.now() - startTime) / 1000); const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, \u0026#39;0\u0026#39;); const seconds = (elapsedTime % 60).toString().padStart(2, \u0026#39;0\u0026#39;); timer.textContent = `${minutes}:${seconds}`; } // 可视化音频输入 function visualize() { if (!audioContext || audioContext.state === \u0026#39;closed\u0026#39;) return; const bufferLength = analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); const draw = () =\u0026gt; { if (!isRecording) return; requestAnimationFrame(draw); analyser.getByteFrequencyData(dataArray); visualizerContext.clearRect(0, 0, visualizer.width, visualizer.height); const barWidth = (visualizer.width / bufferLength) * 2.5; let x = 0; for (let i = 0; i \u0026lt; bufferLength; i++) { const barHeight = (dataArray[i] / 255) * visualizer.height; // 使用彩色渐变效果 const hue = i / bufferLength * 360; visualizerContext.fillStyle = `hsl(${hue}, 100%, 50%)`; visualizerContext.fillRect(x, visualizer.height - barHeight, barWidth, barHeight); x += barWidth + 1; } }; draw(); } async function startRecording() { try { result.style.display = \u0026#39;none\u0026#39;; recordingContainer.style.display = \u0026#39;none\u0026#39;; warningMessage.style.display = \u0026#39;none\u0026#39;; try { const prepareResponse = await fetch(\u0026#39;/prepare-recording\u0026#39;); if (!prepareResponse.ok) { console.warn(\u0026#39;预清理请求失败，继续录音:\u0026#39;, prepareResponse.statusText); } else { // 检查内容类型 const contentType = prepareResponse.headers.get(\u0026#39;content-type\u0026#39;); if (contentType \u0026amp;\u0026amp; contentType.includes(\u0026#39;application/json\u0026#39;)) { const data = await prepareResponse.json(); console.log(\u0026#39;预清理结果:\u0026#39;, data.message); } else { console.warn(\u0026#39;预清理响应不是JSON格式，继续录音\u0026#39;); } } } catch (cleanError) { console.warn(\u0026#39;预清理出错，继续录音:\u0026#39;, cleanError); } if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { throw new Error(\u0026#39;您的浏览器不支持录音功能。请使用Chrome, Firefox或Edge的最新版本。\u0026#39;); } try { // 获取录音权限 const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); audioContext = new (window.AudioContext || window.webkitAudioContext)(); analyser = audioContext.createAnalyser(); microphone = audioContext.createMediaStreamSource(stream); microphone.connect(analyser); analyser.fftSize = 256; const bufferLength = analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength); if (typeof MediaRecorder === \u0026#39;undefined\u0026#39;) { throw new Error(\u0026#39;您的浏览器不支持MediaRecorder API。请使用Chrome, Firefox或Edge的最新版本。\u0026#39;); } // 创建媒体记录器 let mimeType = \u0026#39;audio/wav\u0026#39;; // 检查浏览器是否支持指定的MIME类型 if (!MediaRecorder.isTypeSupported(mimeType)) { console.warn(\u0026#39;浏览器不支持audio/wav格式，使用默认格式\u0026#39;); mimeType = \u0026#39;\u0026#39;; } const mediaRecorderOptions = mimeType ? { mimeType: mimeType, audioBitsPerSecond: 16000 } : { audioBitsPerSecond: 16000 }; mediaRecorder = new MediaRecorder(stream, mediaRecorderOptions); audioChunks = []; // 收集录音数据 mediaRecorder.ondataavailable = (event) =\u0026gt; { audioChunks.push(event.data); }; // 录音停止后的处理 mediaRecorder.onstop = () =\u0026gt; { const audioBlob = new Blob(audioChunks, { type: \u0026#39;audio/wav\u0026#39; }); const audioUrl = URL.createObjectURL(audioBlob); recordedAudio.src = audioUrl; recordingContainer.style.display = \u0026#39;block\u0026#39;; uploadRecording(audioBlob); }; mediaRecorder.start(); isRecording = true; recordButton.textContent = \u0026#39;停止录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#c0392b\u0026#39;; startTime = Date.now(); updateTimer(); timerInterval = setInterval(updateTimer, 1000); visualize(); } catch (mediaError) { handleMediaError(mediaError); } } catch (error) { console.error(\u0026#39;录音功能错误:\u0026#39;, error); showErrorMessage(error.message || \u0026#39;无法访问麦克风，请确保您已授予录音权限。\u0026#39;); } } // 停止录音 function stopRecording() { console.log(\u0026#39;停止录音函数被调用，当前状态:\u0026#39;, { isRecording: isRecording, mediaRecorderExists: !!mediaRecorder, mediaRecorderState: mediaRecorder ? mediaRecorder.state : \u0026#39;undefined\u0026#39; }); try { if (!mediaRecorder) { console.error(\u0026#39;MediaRecorder对象不存在，无法停止录音\u0026#39;); showErrorMessage(\u0026#39;录音设备异常，请刷新页面重试\u0026#39;); isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; return; } if (!isRecording) { console.warn(\u0026#39;状态显示未在录音中，但停止录音按钮被点击\u0026#39;); return; } // 确保MediaRecorder处于录音状态才能停止 if (mediaRecorder.state === \u0026#39;recording\u0026#39; || mediaRecorder.state === \u0026#39;paused\u0026#39;) { // 请求数据 mediaRecorder.requestData(); // 停止录音 mediaRecorder.stop(); console.log(\u0026#39;MediaRecorder已停止\u0026#39;); } else { console.warn(`MediaRecorder状态异常: ${mediaRecorder.state}`); } //UI更新 isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; // 停止计时器 if (timerInterval) { clearInterval(timerInterval); console.log(\u0026#39;计时器已停止\u0026#39;); } // 关闭音频流 if (audioContext \u0026amp;\u0026amp; audioContext.state !== \u0026#39;closed\u0026#39;) { if (microphone) { microphone.disconnect(); console.log(\u0026#39;麦克风已断开连接\u0026#39;); } } if (audioChunks.length \u0026gt; 0 \u0026amp;\u0026amp; mediaRecorder.state !== \u0026#39;recording\u0026#39;) { console.log(\u0026#39;手动处理录音数据\u0026#39;); const audioBlob = new Blob(audioChunks, { type: \u0026#39;audio/wav\u0026#39; }); const audioUrl = URL.createObjectURL(audioBlob); recordedAudio.src = audioUrl; recordingContainer.style.display = \u0026#39;block\u0026#39;; // 上传录音 uploadRecording(audioBlob); } } catch (error) { console.error(\u0026#39;停止录音时出错:\u0026#39;, error); showErrorMessage(\u0026#39;停止录音时出错，请刷新页面重试\u0026#39;); isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; } } // 处理媒体访问错误 function handleMediaError(error) { console.error(\u0026#39;麦克风访问错误:\u0026#39;, error); let errorMessage = \u0026#39;无法访问麦克风，请确保您已授予录音权限。\u0026#39;; // 根据错误类型提供具体的错误信息 if (error.name === \u0026#39;NotAllowedError\u0026#39; || error.name === \u0026#39;PermissionDeniedError\u0026#39;) { errorMessage = \u0026#39;您已拒绝麦克风访问权限。请点击浏览器地址栏的锁图标，更改麦克风权限设置，然后刷新页面。\u0026#39;; } else if (error.name === \u0026#39;NotFoundError\u0026#39; || error.name === \u0026#39;DevicesNotFoundError\u0026#39;) { errorMessage = \u0026#39;未检测到麦克风设备。请确认您的麦克风已正确连接，并且没有被系统禁用。\u0026#39;; } else if (error.name === \u0026#39;NotReadableError\u0026#39; || error.name === \u0026#39;TrackStartError\u0026#39;) { errorMessage = \u0026#39;麦克风正在被其他应用程序使用。请关闭可能正在使用麦克风的其他应用，然后刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;OverconstrainedError\u0026#39;) { errorMessage = \u0026#39;麦克风设置约束条件无法满足。请使用其他麦克风设备重试。\u0026#39;; } else if (error.name === \u0026#39;TypeError\u0026#39;) { errorMessage = \u0026#39;录音参数错误。请刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;AbortError\u0026#39;) { errorMessage = \u0026#39;麦克风访问请求被中断。请刷新页面重试。\u0026#39;; } else if (error.name === \u0026#39;SecurityError\u0026#39;) { errorMessage = \u0026#39;浏览器安全设置阻止了麦克风访问。请使用HTTPS连接或localhost访问本站点。\u0026#39;; } showErrorMessage(errorMessage); } // 清理录音 function cleanRecording(filename) { if (!filename) return; fetch(`/clean-recording/${filename}`, { method: \u0026#39;DELETE\u0026#39; }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(\u0026#39;清理录音结果:\u0026#39;, data.message); }) .catch(error =\u0026gt; { console.error(\u0026#39;清理录音出错:\u0026#39;, error); }); } function cleanAllRecordings() { fetch(\u0026#39;/clean-all-recordings\u0026#39;, { method: \u0026#39;DELETE\u0026#39; }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { console.log(\u0026#39;清理所有录音结果:\u0026#39;, data.message); }) .catch(error =\u0026gt; { console.error(\u0026#39;清理所有录音出错:\u0026#39;, error); }); } function uploadRecording(audioBlob) { loader.style.display = \u0026#39;block\u0026#39;; result.style.display = \u0026#39;none\u0026#39;; similarityValue.style.width = \u0026#39;0%\u0026#39;; lastRequestTime = Date.now(); const formData = new FormData(); formData.append(\u0026#39;audio\u0026#39;, audioBlob, \u0026#39;recording.wav\u0026#39;); fetch(\u0026#39;/compare-recording\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: formData }) .then(response =\u0026gt; { // 检查响应状态 if (!response.ok) { throw new Error(`服务器响应错误: ${response.status} ${response.statusText}`); } return response.json(); }) .then(data =\u0026gt; { // 隐藏加载状态 loader.style.display = \u0026#39;none\u0026#39;; // 如果成功获取到录音文件名，保存它 if (data.filename) { currentRecordingFilename = data.filename; } // 显示匹配度 const similarity = parseFloat(data.similarity); similarityValue.style.width = `${similarity}%`; // 显示结果 result.textContent = `匹配度: ${similarity.toFixed(2)}% - ${data.message}`; result.style.display = \u0026#39;block\u0026#39;; // 根据匹配度设置不同的样式 result.className = \u0026#39;result\u0026#39;; if (similarity \u0026gt;= 98) { result.classList.add(\u0026#39;result-perfect\u0026#39;); } else if (similarity \u0026gt;= 85) { result.classList.add(\u0026#39;result-high\u0026#39;); } else if (similarity \u0026gt;= 70) { result.classList.add(\u0026#39;result-medium\u0026#39;); } else { result.classList.add(\u0026#39;result-low\u0026#39;); } // 如果有FLAG，显示FLAG弹窗 if (data.flag) { showFlagModal(data.flag); } }) .catch(error =\u0026gt; { console.error(\u0026#39;上传录音出错:\u0026#39;, error); loader.style.display = \u0026#39;none\u0026#39;; result.textContent = \u0026#39;评分失败，请稍后重试: \u0026#39; + error.message; result.className = \u0026#39;result result-low\u0026#39;; result.style.display = \u0026#39;block\u0026#39;; }); } function showErrorMessage(message) { warningMessage.textContent = message; warningMessage.style.display = \u0026#39;block\u0026#39;; isRecording = false; recordButton.textContent = \u0026#39;开始录音\u0026#39;; recordButton.style.backgroundColor = \u0026#39;#e74c3c\u0026#39;; if (timerInterval) { clearInterval(timerInterval); } } // 显示FLAG弹窗 function showFlagModal(flag) { flagContent.textContent = flag; flagModal.style.display = \u0026#39;block\u0026#39;; } function closeModal() { flagModal.style.display = \u0026#39;none\u0026#39;; } window.onclick = function(event) { if (event.target === flagModal) { flagModal.style.display = \u0026#39;none\u0026#39;; } } // 页面卸载前处理 window.addEventListener(\u0026#39;beforeunload\u0026#39;, function(event) { // 显示确认对话框 exitConfirmModal.style.display = \u0026#39;block\u0026#39;; // 阻止页面立即卸载，显示确认对话框 event.preventDefault(); event.returnValue = \u0026#39;\u0026#39;; // 注意：现代浏览器出于安全考虑可能会忽略自定义消息 return \u0026#39;若您退出当下页面，所有录制的录音都会被删除！\u0026#39;; }); // 用户选择页面 stayButton.addEventListener(\u0026#39;click\u0026#39;, function() { exitConfirmModal.style.display = \u0026#39;none\u0026#39;; }); leaveButton.addEventListener(\u0026#39;click\u0026#39;, function() { cleanAllRecordings(); exitConfirmModal.style.display = \u0026#39;none\u0026#39;; setTimeout(() =\u0026gt; { window.location.href = \u0026#39;about:blank\u0026#39;; }, 500); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 发现flag获取条件如下：\nif (similarity \u0026gt;= 98) { result.classList.add(\u0026#39;result-perfect\u0026#39;); } 但是紧接着又发现：\nif (data.flag) { showFlagModal(data.flag); } 说明flag是从后端传来，改动前端similarity值不能得到flag\n唱歌肯定不行，那么既然网站提供了原音频下载，就可以直接提交原音频\n但网页没有提供提交入口，而代码中是前端将录音文件上传到/compare-recording，那就可以直接与后端建立联系\n使用curl：\ncurl -X POST http://127.0.0.1:xxxx/compare-recording -F \u0026#34;audio=@original.wav\u0026#34; 直接得到返回的flag\n","date":"2025-05-09T01:17:52+08:00","permalink":"https://blog.928330.xyz/p/minil/","title":"MiniL"},{"content":"VIM使用方式 vim键盘图 vim操作文件基本方式 打开文件 单个文件\nvim file1 多个文件\nvim file1 file2 ... filen 该方式打开文件，显示屏默认显示第一个文件也就是 file1\n文件之间的切换 :ls \u0026ndash; 列出 VIM 打开的所有文件 :bn \u0026ndash; 显示屏上显示第n个文件 显示多个文件 左右分屏\nvim -On file1 file2 ... filen 这里的 n 是代表有几个文件需要分屏，从左至右依次显示 n 个文件\n上下分屏\nvim -on file1 file2 ... filen 跟上一个命令不同的是 -on 中的 o 是小写，这样将会上下依次显示 n 个文件\n分屏操作（ctrl+w系列） 左右分屏 Ctrl+w+s \u0026ndash; 上下分割当前打开的文件 :sp file \u0026ndash; 上下分割当前文件和新打开的 file 上下分屏 Ctrl+w+v \u0026ndash; 左右分割当前打开的文件 :vsp file \u0026ndash; 左右分割当前文件和新打开的 file 移动分屏 大写字母\nCtrl+w+H \u0026ndash; 将当前的分屏移动到左边 Ctrl+w+L \u0026ndash; 将当前的分屏移动到右边 Ctrl+w+J \u0026ndash; 将当前的分屏移动到上边 Ctrl+w+K \u0026ndash; 将当前的分屏移动到下边 在文件间切换光标 小写字母\nCtrl+w+h \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+l \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+j \u0026ndash; 将当前光标定位到左边的屏幕 Ctrl+w+k \u0026ndash; 将当前光标定位到左边的屏幕 关闭分屏 Ctrl+w+c \u0026ndash; 关闭当前的分屏(多个分屏就只关闭光标所在的分屏) Ctrl+w+q \u0026ndash; 关闭当前的分屏，如果是最后一个分屏将会退出 VIM vim五大模式 普通模式 用户刚刚启动 vi/vim，便进入了普通模式\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符\n普通模式移动光标 快速移动光标\n输入[数字n＋方向]，代表向某个方向移动n\nh / ← / [backspace]：向左移动光标 j / ↓：向下移动光标 k / ↑：向上移动光标 l / → / [space]：向右移动光标 在当前行上移动光标\n0 或功能键[Home] \u0026ndash; 移动到行头 ^ \u0026ndash; 移动到本行的第一个不是 blank 字符 $ 或功能键[End] \u0026ndash; 移动到行尾 g_ \u0026ndash; 移动到本行最后一个不是 blank 字符的位置 w \u0026ndash; 光标移动到下一个单词的开头 e \u0026ndash; 光标移动到下一个单词的结尾 fa \u0026ndash; 移动到本行下一个为 a 的字符处 nfa \u0026ndash; 移动到本行光标处开始的第 n 个 字符为 a 的地方 Fa \u0026ndash; 同fa一样，光标移动方向同fa相反 nFa \u0026ndash; 同 nfa 类似，光标移动方向同 nfa相反 ta \u0026ndash; 移动光标至 a 字符的前一个字符 nta \u0026ndash; 移动到第n个 a 字符的前一个字符处 Ta \u0026ndash; 同ta移动光标方向相反 nTa \u0026ndash; 同 nta 移动光标方向相反 ; \u0026amp; , \u0026ndash; 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用**；可以快速跳转到下一个指定的字符，,** 是跳到前一个指定的字符 跨行移动光标\nnG \u0026ndash; 光标定位到第 n 行的行首 gg \u0026ndash; 光标定位到第一行的行首 G \u0026ndash; 光标定位到最后一行的行首 H \u0026ndash; 光标定位到当前屏幕的第一行行首 M \u0026ndash; 光标移动到当前屏幕的中间 L \u0026ndash; 光标移动到当前屏幕的尾部 zt \u0026ndash; 把当前行移动到当前屏幕的最上方，也就是第一行 zz \u0026ndash; 把当前行移动到当前屏幕的中间 zb \u0026ndash; 把当前行移动到当前屏幕的尾部 % \u0026ndash; 匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上 * \u0026amp; # \u0026ndash; 匹配光标当前所在的单词， ***** 是下一个，# 是上一个 翻页操作\nctrl+u \u0026ndash; 向上滚动半页 ctrl+b \u0026ndash; 向上滚动一页 ctrl+d \u0026ndash; 向下滚动半页 ctrl+f \u0026ndash; 向下滚动一页 普通模式操作文本 删除\nd 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下：\ndw \u0026ndash; 删除一个单词 dnw \u0026ndash; 删除 n 个单词， dfa \u0026ndash; 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ） dnfa \u0026ndash; 删除光标处到第 n 个 a 的字符处 dd \u0026ndash; 删除一整行 ndd \u0026ndash; 删除光标处开始的 n 行 d$ \u0026ndash; 删除光标到本行的结尾 d0 \u0026ndash; 删除游标所在处到该行的最前面一个字符 dH \u0026ndash; 删除屏幕显示的第一行文本到光标所在的行 d1G \u0026ndash; 删除光标所在到第一行的所有数据 dG \u0026ndash; 删除光标所在到最后一行的所有数据 x \u0026ndash; 删除光标当前所在的字符**(delete)** X \u0026ndash; 删除光标前面的一个字符**(backspace)** nx \u0026ndash; 向后连续删除n个字符 复制\ny 是复制的意思，通常搭配一个字符（复制范围）实现复制的功能，常用的如下：\nyw \u0026ndash; 复制一个单词，还有ynw yfa \u0026ndash; 复制光标到下一个 a 的字符处,还有ynfa yy \u0026ndash; 复制一行，还有nyy y$ \u0026ndash; 复制光标到本号的结尾 yH \u0026ndash; 复制屏幕显示的第一行文本到光标所在的行 y1G \u0026ndash; 复制光标所在行到第一行的所有数据 yG \u0026ndash; 复制光标所在行到最后一行的所有数据 粘贴\np是黏贴的意思，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来\np(小写) \u0026ndash; 在光标后开始黏贴\nP(大写) \u0026ndash; 在光标前开始粘贴\n撤销操作和恢复\nu \u0026ndash; 撤销刚才的操作 ctrl+r \u0026ndash; 恢复撤销操作 大小写转换\n~ \u0026ndash; 将光标下的字母改变大小写 3~ \u0026ndash; 将光标位置开始的3个字母改变其大小写 g~~ \u0026ndash; 改变当前行字母的大小写 gUU \u0026ndash; 将当前行的字母改成大写 guu \u0026ndash; 将当前行的字母全改成小写 3gUU \u0026ndash; 将从光标开始到下面3行字母改成大写 gUw \u0026ndash; 将光标下的单词改成大写 guw \u0026ndash; 将光标下的单词改成小写 重复操作\n. \u0026ndash; 重复上一个操作的命令 n\u0026lt;command\u0026gt; \u0026ndash; 重复某个命令 n 次，如 10p复制 10 次，10dd 删除十次 其他\nJ \u0026ndash; 将光标所在行与下一行的数据结合成同一行 c \u0026ndash; 重复删除多个数据，例如向下删除 10 行，10cj 插入模式 进入插入模式 命令 说明 i, I i \u0026ndash; 从目前光标所在处输入\nI \u0026ndash; 在目前所在行的第一个非空格符处开始输入 a, A a \u0026ndash; 从目前光标所在的下一个字符处开始输入\nA \u0026ndash; 从光标所在行的最后一个字符处开始输入 o, O o \u0026ndash; 在目前光标所在的下一行处输入新的一行\nO \u0026ndash; 在目前光标所在的上一行处输入新的一行 s，S s \u0026ndash; 删除光标所在处的字符然后插入需要录入的文本\nS \u0026ndash; 删除光标所在行，在当前行的行首开始插入需要录入的文本 cw 删除从光标处开始到该单词结束的所有字符，然后插入需要录入的文本 插入模式的命令 必须知道的：#是vim中的注释符号\n在输入模式中，可以使用以下按键：\n字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 替换模式 进入替换模式 R \u0026ndash; 进入替换模式，此时新输入的文本将直接替代/覆盖已经存在的内容，点击ESC键返回常规模式\nr \u0026ndash; 进入单字符替换模式，此时新输入的字符将替代光标之下的当前字符，然后自动返回到常规模式\ngR \u0026ndash; 进入虚拟替换模式，其与替换模式最主要的区别在于，对\u0026lt;Tab\u0026gt;键和换行符的不同处理方式\ngr \u0026ndash; 进入单字符虚拟替换模式，在替换光标下的当前字符之后，将自动返回到常规模式\n虚拟替换模式 \u0026lt;Tab\u0026gt;键\n替换模式（REPLACE）下，在原有\u0026lt;Tab\u0026gt;键处输入字母\u0026rsquo;a\u0026rsquo;，将直接替代\u0026lt;Tab\u0026gt;键所占用的所有空格的位置\n虚拟替换模式（VREPLACE）下，在原有\u0026lt;Tab\u0026gt;键处输入字母\u0026rsquo;a\u0026rsquo;，将仅仅替代单个空格\n\u0026lt;NL\u0026gt;换行\n替换模式（REPLACE）下，输入\u0026lt;Enter\u0026gt;回车键将增加新行：\n虚拟替换模式（VREPLACE）下，输入\u0026lt;Enter\u0026gt;回车键将用新行替代当前行内容（即清空当前行）：\n命令模式 在命令模式下按下 :（英文冒号）就进入了底线命令模式\n有的命令要输入 / 执行\n命令模式常用命令 :w \u0026ndash; 保存文件 :q \u0026ndash; 退出 Vim 编辑器 :wq \u0026ndash; 保存文件并退出 Vim 编辑器 :q! \u0026ndash; 强制退出Vim编辑器，不保存修改 :set nu \u0026ndash; 显示行号 :set nonu \u0026ndash; 取消行号 :n \u0026ndash; 定位到第n行 :n1,n2d \u0026ndash; 删除行号n1至n2之间的内容（n1和n2都代表数字） 按 ESC 键可随时退出底线命令模式\n命令模式处理文件 :w [filename] \u0026ndash; 将编辑的数据储存成另一个文件（类似另存新档） :r [filename] \u0026ndash; 在编辑的数据中，读入另一个档案的数据，即将filenam的内容加到光标所在行后面 :n1,n2 w [filename] \u0026ndash; 将 n1 到 n2 的内容储存成 filename 命令模式搜索文本 ?{目标字符串} \u0026ndash; 向光标之上寻找一个目标字符串 /{目标字符串} \u0026ndash; 向光标之下寻找一个目标字符串 n \u0026ndash; 重复前一个搜寻的动作 N \u0026ndash; 反向进行前一个搜寻动作 :set ic \u0026ndash; 编辑器将不会区分大小写 :set noic \u0026ndash; 编辑器将区分大小写 命令模式替换文本 格式：:(作用范围)s/{目标}/{替换}(/替换的标志)\n替换的作用范围\n标志 作用 s 当前行替换 %s 全文替换 n1,n2s 指定行替换，替换n1到n2间所有行的目标，n2可以是$，代指最后一行 \u0026rsquo;\u0026lt;,\u0026rsquo;\u0026gt;s 指定区域替换 替换的标志\n标志 作用 [无] 只替换作用范围内，每行第一次出现的目标 g 一次性替换所有作用范围内所有的目标 i 大小写不敏感查找 I 大小写敏感查找 c 对作用范围内的目标逐个替换，替换前需进行确认 替换标志可以使用多个，比如/gic\n命令模式执行linux命令 :![command]\n打开终端窗口并打印执行命令的结果，不会改变当前编辑的文件的内容\n可以使用:!bash打开bash shell并执行命令\n:!date\t//执行 date 命令显示时间，执行完命令以后按下键盘上的 Enter 就会返回到文件 :r ![command]\n将shell命令command的结果插入到当前行的下一行\n:r !date\t//读取系统时间并插入到当前行的下一行 n1,n2 ![command]\n将n1至n2行范围内的内容交给命令command处理，并将处理结果替换起始行号和结束行号指定范围中的内容\n:1,4 !sort\t//将第1行到第4行的内容进行排序 可以只指定起始行\n:1 !tr [a-z] [A-Z]\t//将第1行的小写字母转为大写字母 可以用.表示当前光标所在行 (输入!!会变成:.!)\n:. !tr [a-z] [A-Z]\t//将当前行的小写转为大写 n1,n2 w ![command]\n将起始行号和结束行号所指定范围的内容作为命令command的输入，不会改变当前编辑的文件的内容\n可以使用:1 w !bash，将会把第1行的内容作为bash命令来执行并显示结果，而且不会改变当前编辑的文件的内容\n同样的 : . w !bash将当前行的内容作为bash命令来执行\n!!\n重新执行最近一次运行过的命令\n:shell / :terminal\n打开命令终端（输入exit结束并返回vim）\n使用:version命令（按q退出），查看是否包含+terminal关键字，以确认是否能使用 :terminal\n命令模式定义快捷键 基本格式\n模式 基本格式 描述 普通模式 :nmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 仅在普通模式下有效，定义普通模式下的快捷键 插入模式 :imap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义插入模式下的快捷键 可视模式 :vmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义可视模式下的快捷键 命令行模式 :cmap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 用于定义命令行模式下的快捷键 总体映射 :map \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 定义快捷键，适用于普通、可视、操作和选择模式，但不建议用于有冲突的情况。 总体不可递归映射 :noremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 类似:map，但是不会递归地扩展已经存在的映射，避免意外行为。 普通模式不可递归 :nnoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在普通模式下使用，避免递归映射 插入模式不可递归 :inoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在插入模式下使用，避免递归映射 可视模式不可递归 :vnoremap \u0026lt;key\u0026gt; \u0026lt;command\u0026gt; 在可视模式下使用，避免递归映射 缩写 :ab [缩写] [完整文本] 输入缩写后空格，自动扩展为完整文本。例如：:ab email xxxx@gmail.com 什么是\u0026lt;key\u0026gt;？\n\u0026lt;key\u0026gt; 对应的是 ^[A-Z] ， 定义快捷键时使用ctrl+v+[a-z]，使用快捷键时用对应的ctrl+[a-z]\n什么是递归映射？\n:nmap j gg :nmap Q j 如果已经做了以上映射，那么按下Q，执行的将是gg而不是j\n为了避免以上问题，应该这样定义：\n:nnoremap j gg :nnoremap Q j 几个例子\n:map ^D Ahelloworld\u0026lt;ESC\u0026gt; 在文件的光标所在行的行尾，添加 helloworld 字符串，按住组合键 ctrl + d 就会执行操作\n:map ^M I#\u0026lt;ESC\u0026gt; 在文件光标处所在行的行首插入#，按住组合键 ctrl + m 就会执行操作\n:ab email xxxx@gmail.com 输入 email+空格 会把输入的 email 自动替换成 xxxx @gmail.com\n可视化模式 进入可视化模式 可视化模式可以分为以下三种：\nv \u0026ndash; 字符可视化模式，文本选择是以字符为单位的 V \u0026ndash; 行可视化模式，文本选择是以行为单位的 ctrl-V \u0026ndash; 块可视化模式，可以选择一个矩形内的文本 在任意可视化模式下使用以上命令，将会切换到对应模式\n在任意可视化模式下使用I（大写i），将会切换到插入模式\ngv \u0026ndash; 进入上一次的可视化模式，并选中当时选中的文本**（命令模式也能用此命令）** 按 ESC 键可随时退出可视化模式\n可视化模式下移动光标 命令模式下的光标移动方法仍然适用\n进入任意可视化模式，移动光标，会从当前位置开始，以相应方式高亮选中字符\no \u0026ndash; 移动光标到已经选取的文本的结尾处或者开头处（根据现在光标所在位置确定）\n如果是块可视化模式，移动光标到对角处 O \u0026ndash; 在块可视化模式下，移动光标到同一行的结尾处或者开头处\n可视化模式下编辑 大部分命令模式对内容操作的命令都能在可视化模式下使用，比如：\nd \u0026ndash; 删除高亮文本\nD \u0026ndash; 删除一整行文本，即使只有一部分被选中了\nc \u0026ndash; 删除高亮文本并进入插入模式\ny \u0026ndash; 复制高亮文本\nY \u0026ndash; 复制一整行文本\np \u0026ndash; 黏贴复制的文本\n~ \u0026ndash; 对高亮文本进行大小写转换\n\u0026gt; / \u0026lt; \u0026ndash; 对高亮文本增加/减少缩进，幅度为一个Tab键\nr \u0026ndash; 输入单个字符，把高亮文本所有字符逐个替换为该字符\nvim宏录制 宏录制的录制操作 假设需要将文本的每一行的行首插入入一个 tab 键\n先将光标移动到第一行，在普通模式下按下 q 键（宏录制是 q 键启动的) 按一个 a （字母随意）,表示该宏注册为 a 按下 I 在行首插入一个 tab 键 按下ESC退出编辑模式 按下 j 将光标移动到下一行行首 按下 q 键完成录制操作（宏录制是 q 键结束的） 主要步骤：q(开始）-\u0026gt; a(命名) -\u0026gt; 操作 -\u0026gt; q(结束)\n宏录制的使用 @a \u0026ndash; 执行a宏录制的一系列动作，注意a是录制的操作名称 n@a \u0026ndash; 执行n次a宏 @@ \u0026ndash; 重复上一次使用的宏操作 VIM相关案例 vim缓存泄露 vim交换文件 在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容\n现在用vim打开文件1.txt，直接关闭终端，再次试图用vim打开1.txt时会出现如下提示：\n选择恢复（R），弹出如下提示：\nVim 中，当处理同一个文件发生多次异常退出时，它会依次使用不同的后缀来命名交换文件。按照你给出的模式，首次产生的交换文件名为 .index.php.swp，再次意外退出后产生 .index.php.swo，第三次产生的交换文件为 .index.php.swn。\n从第四次开始及之后的交换文件，Vim 会循环使用这三个后缀（.swp, .swo, .swn）\n例题 使用以下命令获取网站中的vim文件缓存：\nwget http://xxx/.index.php.swp -P /home //-P指定下载位置 使用vim -r恢复文件并打开:\nvim -r .index.php.swp 获取到网站源码后，进行代码审计即可\n","date":"2025-05-08T15:28:02+08:00","permalink":"https://blog.928330.xyz/p/vim%E7%BC%96%E8%BE%91%E5%99%A8%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"Vim编辑器完全使用教程"}]