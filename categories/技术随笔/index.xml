<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>技术随笔 on kakahuote</title>
        <link>https://blog.928330.xyz/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/</link>
        <description>Recent content in 技术随笔 on kakahuote</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Tue, 23 Sep 2025 20:37:58 +0800</lastBuildDate><atom:link href="https://blog.928330.xyz/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>常见检材类型</title>
        <link>https://blog.928330.xyz/p/%E5%B8%B8%E8%A7%81%E6%A3%80%E6%9D%90%E7%B1%BB%E5%9E%8B/</link>
        <pubDate>Tue, 23 Sep 2025 20:18:13 +0800</pubDate>
        
        <guid>https://blog.928330.xyz/p/%E5%B8%B8%E8%A7%81%E6%A3%80%E6%9D%90%E7%B1%BB%E5%9E%8B/</guid>
        <description>&lt;img src="http://picture.928330.xyz/typora/2f56641afcc38e8ed63fa3beb6d312cc.jpg" alt="Featured image of post 常见检材类型" /&gt;&lt;p&gt;在电子取证过程中拿到的检材形式各异，它们可能是从硬盘完整复制下来的镜像文件，也可能是RAID阵列中的多个磁盘，或者是手机的逻辑备份，而知道这些检材是是什么怎么用，才是启动分析的第一步&lt;/p&gt;
&lt;p&gt;以弘连火眼证据分析软件为例，选取检材的时候会看见如下选项：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250918095757243&#34; href=&#34;http://picture.928330.xyz/typora/image-20250918095757243.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250918095757243.png&#34; alt=&#34;image-20250918095757243&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;这些都是什么呢？我们先大致说一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;镜像文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常见的证据形式，是物理存储的数字副本，单个的手机、计算机都可能是这个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多镜像文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当单个镜像文件被分割成多个小文件时，就会变成多镜像，有点像分卷压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;物理磁盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接对连接到取证机的原始硬盘或SSD进行分析，或者挂载镜像为系统盘后分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;文件集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非完整的磁盘镜像，仅包含从源设备中提取的特定文件和文件夹，比如手机系统的备份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;移动设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于要使用雷电手机快取软件，我至今没有用过这个功能&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;不过好像是连接手机、平板等进行数据提取分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;磁盘阵列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对由多块硬盘组成的RAID进行重组和分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们系统介绍一些检材常用的格式，以及转换方法&lt;/p&gt;
&lt;h1 id=&#34;计算机取证镜像&#34;&gt;计算机取证镜像
&lt;/h1&gt;&lt;h2 id=&#34;标准镜像文件式&#34;&gt;标准镜像文件式
&lt;/h2&gt;&lt;h3 id=&#34;原始镜像&#34;&gt;原始镜像
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;纯粹的位对位（bit-by-bit）副本，文件大小与源磁盘/分区容量完全一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无元数据、无压缩、无加密（因为本身就是字节流，没有这些标识概念），但是利用命令和工具可以做到&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，就算把他们后缀名去掉，使用方法也是一样的&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;dd&#34;&gt;.dd
&lt;/h4&gt;&lt;p&gt;这个扩展名源自Unix/Linux系统下的**&lt;code&gt;dd&lt;/code&gt;(dataset definition，数据集定义)**命令，它是制作原始镜像最经典、最基础的工具，因此&lt;code&gt;.dd&lt;/code&gt;成为了原始镜像的代名词&lt;/p&gt;
&lt;p&gt;命令行制作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dd &lt;span style=&#34;color:#c678dd&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt;/dev/sda &lt;span style=&#34;color:#e06c75&#34;&gt;of&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt;image.dd &lt;span style=&#34;color:#e06c75&#34;&gt;bs&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt;4M &lt;span style=&#34;color:#e06c75&#34;&gt;conv&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt;noerror,sync
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;意思是把整块硬盘&lt;code&gt;/dev/sda&lt;/code&gt;按照4MB为单位复制到&lt;code&gt;image.dd&lt;/code&gt;文件里，如果遇到坏扇区，不报错不中止，而是用0填充，保证镜像完整且和原盘大小一致&lt;/p&gt;
&lt;p&gt;几乎所有主流取证工具都支持创建和导出为&lt;code&gt;.dd&lt;/code&gt;，非常的常见&lt;/p&gt;
&lt;h4 id=&#34;img--raw--bin&#34;&gt;.img / .raw / .bin
&lt;/h4&gt;&lt;p&gt;这些都是描述性的扩展名，&lt;code&gt;img&lt;/code&gt;代表 &amp;ldquo;镜像&amp;rdquo;，&lt;code&gt;raw&lt;/code&gt;代表 &amp;ldquo;原始&amp;rdquo;，&lt;code&gt;bin&lt;/code&gt;代表 &amp;ldquo;二进制文件&amp;rdquo;&lt;/p&gt;
&lt;p&gt;它们在功能和结构上与&lt;code&gt;.dd&lt;/code&gt;文件完全相同，都是指原始的、逐位的副本，只是使用场景和工具不同叫法也不同&lt;/p&gt;
&lt;p&gt;这些扩展名实际能用于很多场景，遇见了不确定的话就一个个尝试吧，能分析出来就行&lt;/p&gt;
&lt;h3 id=&#34;封装镜像&#34;&gt;封装镜像
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;本质上也包含了原始磁盘或分区的bit-by-bit数据，但是采用了封装数据 + 元数据（采集者、采集时间、硬盘序列号、哈希值）的形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也正因此，他们支持压缩、加密等形式来节约空间，支持分卷存储大型镜像文件，部分可随机访问（如AFF）&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;e01-ex01&#34;&gt;.E01, .Ex01
&lt;/h4&gt;&lt;p&gt;由EnCase Forensic开发的证据文件格式，已成为事实上的行业标准，也就是说法庭认可度最高！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.Ex01&lt;/code&gt;是其更新的“专家见证”格式，支持更强的AES-256加密和更大的文件大小&lt;/p&gt;
&lt;p&gt;它主要通过EnCase Forensic软件制作，同时，绝大多数第三方取证工具也都支持直接采集为 &lt;code&gt;.E01&lt;/code&gt; 格式以保证兼容性&lt;/p&gt;
&lt;h4 id=&#34;aff--aff4af4&#34;&gt;.aff / .aff4(.af4)
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.aff&lt;/code&gt;，全称是高级取证格式 (Advanced Forensic Format)&lt;/strong&gt;，它是一个开源项目，旨在克服&lt;code&gt;.dd&lt;/code&gt;格式无元数据和&lt;code&gt;.E01&lt;/code&gt;格式专有的缺点&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;.aff4&lt;/code&gt;是&lt;code&gt;.aff&lt;/code&gt;的第四代版本，是一个经过大幅重新设计的格式，可以存储多种数据流，包括磁盘映像、内存映像、逻辑文件，甚至是网络流量，也被简写成&lt;code&gt;.af4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;他们都是通过支持AFFLIB库的工具制作的，比如Evimetry等&lt;/p&gt;
&lt;h4 id=&#34;ad1&#34;&gt;.ad1
&lt;/h4&gt;&lt;p&gt;由AccessData开发的证据文件格式，&lt;strong&gt;全称AccessData Evidence Container&lt;/strong&gt;，主要用于他的产品FTK系列&lt;/p&gt;
&lt;p&gt;大多数主流取证软件都能识别导入&lt;code&gt;.ad1&lt;/code&gt;文件&lt;/p&gt;
&lt;h3 id=&#34;多镜像文件&#34;&gt;多镜像文件
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;扩展名可能是上面的任意一种+序列号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当单个大镜像被分割存储时，会看到一组序列文件：&lt;/p&gt;
&lt;p&gt;可能是&lt;code&gt;disk_part1.dd&lt;/code&gt;、&lt;code&gt;disk_part2.dd&lt;/code&gt;、 &lt;code&gt;disk_part3.dd&lt;/code&gt;这样的原始文件分卷&lt;/p&gt;
&lt;p&gt;也能是&lt;code&gt;case.E01&lt;/code&gt;、&lt;code&gt;case.E02&lt;/code&gt;、&lt;code&gt;case.E03&lt;/code&gt;，或者&lt;code&gt;case001.E01&lt;/code&gt;、&lt;code&gt;case002.E01&lt;/code&gt;、&lt;code&gt;case003.E01&lt;/code&gt;这样的封装镜像分卷&lt;/p&gt;
&lt;p&gt;它们必须放在一起才能被完整加载，也就是之前提到的“多镜像文件”这一栏&lt;/p&gt;
&lt;h2 id=&#34;物理磁盘与磁盘阵列&#34;&gt;物理磁盘与磁盘阵列
&lt;/h2&gt;&lt;h3 id=&#34;物理磁盘&#34;&gt;物理磁盘
&lt;/h3&gt;&lt;p&gt;这不是一种文件格式，而是一种证据源&lt;/p&gt;
&lt;p&gt;比如把一块嫌疑人电脑里的硬盘拔下来，接到自己电脑，或者某块硬盘里面有着线索，直接对他分析&lt;/p&gt;
&lt;p&gt;也有可能是使用FTK等工具挂载镜像成为系统盘&lt;/p&gt;
&lt;h3 id=&#34;磁盘阵列-raid&#34;&gt;磁盘阵列 (RAID)
&lt;/h3&gt;&lt;p&gt;RAID（Redundant Array of Independent/Inexpensive Disks，独立冗余磁盘阵列）是一种将多块物理磁盘组合成一个逻辑磁盘的技术，用于提升容错能力，抗数据丢失&lt;/p&gt;
&lt;p&gt;遇到这类检材，一般是考察RAID的磁盘重组，也就是把分散的块组合成可以&lt;/p&gt;
&lt;p&gt;这部分内容有点多，后面单开一篇学习&lt;/p&gt;
&lt;h1 id=&#34;逻辑镜像&#34;&gt;逻辑镜像
&lt;/h1&gt;&lt;p&gt;与获取整个磁盘不同，这类检材只包含从源系统中选择性提取的部分数据（特定文件和文件夹）&lt;/p&gt;
&lt;h2 id=&#34;l01--lx01&#34;&gt;.L01 / .Lx01
&lt;/h2&gt;&lt;p&gt;同样来自EnCase，是它的逻辑证据文件格式&lt;/p&gt;
&lt;p&gt;在EnCase软件中选择要导出的文件条目，再通过添加至逻辑证据文件功能创建&lt;code&gt;.L01&lt;/code&gt;文件&lt;/p&gt;
&lt;h2 id=&#34;ad1-1&#34;&gt;.ad1
&lt;/h2&gt;&lt;p&gt;嗯，就是之前提到过的那个&lt;/p&gt;
&lt;p&gt;使用FTK软件时，选择获取逻辑证据，然后添加特定的文件/文件夹就能创建&lt;code&gt;.ad1&lt;/code&gt;文件&lt;/p&gt;
&lt;h2 id=&#34;zip--tar--rar&#34;&gt;.zip / .tar / .rar
&lt;/h2&gt;&lt;p&gt;其实就是手动打包一系列要分析的文件，不使用专业软件而已&lt;/p&gt;
&lt;h1 id=&#34;系统备份&#34;&gt;系统备份
&lt;/h1&gt;&lt;h2 id=&#34;tib--tibx&#34;&gt;.tib / .tibx
&lt;/h2&gt;&lt;p&gt;由Acronis True Image软件创建的备份镜像格式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.tib&lt;/code&gt;是旧版格式，而&lt;code&gt;.tibx&lt;/code&gt;是较新版本引入的格式，提供了更强的性能和可靠性&lt;/p&gt;
&lt;p&gt;这类文件包含了整个磁盘或分区的完整快照，可以通过Acronis软件进行恢复或挂载浏览&lt;/p&gt;
&lt;h2 id=&#34;gho&#34;&gt;.gho
&lt;/h2&gt;&lt;p&gt;来自Symantec Ghost软件的磁盘克隆镜像&lt;/p&gt;
&lt;p&gt;在21世纪初非常流行，现在虽然少见，但在一些旧的系统备份中仍可能遇到&lt;/p&gt;
&lt;h2 id=&#34;bkf&#34;&gt;.bkf
&lt;/h2&gt;&lt;p&gt;由旧版Windows（如 XP, Server 2003）自带的NTBackup工具创建的备份文件&lt;/p&gt;
&lt;p&gt;它主要用于备份文件和系统状态，而不是完整的磁盘镜像&lt;/p&gt;
&lt;h2 id=&#34;bak&#34;&gt;.bak
&lt;/h2&gt;&lt;p&gt;通用的备份文件扩展名，它没有统一的格式标准，具体内容取决于创建它的应用程序，不过一般是移动设备&lt;/p&gt;
&lt;h1 id=&#34;虚拟磁盘镜像&#34;&gt;虚拟磁盘镜像
&lt;/h1&gt;&lt;p&gt;虚拟机镜像是案件中的常见角色，它们本身就是完整的操作系统环境&lt;/p&gt;
&lt;p&gt;它们一样能被当成整个的镜像文件被分析&lt;/p&gt;
&lt;h2 id=&#34;vmdk&#34;&gt;.vmdk
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;全称Virtual Machine Disk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是VMware公司为其虚拟化产品开发的格式，在VMware产品中创建新虚拟机时自动生成&lt;/p&gt;
&lt;p&gt;也可以使用其命令行工具&lt;code&gt;vmware-vdiskmanager.exe&lt;/code&gt;手动创建&lt;/p&gt;
&lt;h2 id=&#34;vhd--vhdx&#34;&gt;.vhd / .vhdx
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;全称Virtual Hard Disk&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.vhd&lt;/code&gt;源于Connectix公司，后被微软收购用于Virtual PC&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.vhdx&lt;/code&gt;是其现代化的后继者，随Windows Server 2012推出，支持更大容量和更好的性能&lt;/p&gt;
&lt;p&gt;在Windows的Hyper-V管理器或“磁盘管理”工具中（操作 -&amp;gt; 创建VHD）可以直接创建&lt;/p&gt;
&lt;h2 id=&#34;avhd--avhdx&#34;&gt;.avhd / .avhdx
&lt;/h2&gt;&lt;p&gt;这是Microsoft Hyper-V的快照文件&lt;/p&gt;
&lt;p&gt;当为虚拟机创建快照后，系统会创建一个&lt;code&gt;.avhd(x)&lt;/code&gt;文件，之后所有对虚拟磁盘的增量修改都会写入这个文件，而原始的&lt;code&gt;.vhd(x)&lt;/code&gt;文件则保持只读&lt;/p&gt;
&lt;p&gt;将快照文件与父磁盘文件（&lt;code&gt;.vhd&lt;/code&gt;/&lt;code&gt;.vhdx&lt;/code&gt;）合并，才能看到虚拟机在快照时间点的完整状态&lt;/p&gt;
&lt;h2 id=&#34;vdi&#34;&gt;.vdi
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;全称Virtual Disk Image&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是Oracle公司为其开源虚拟化软件VirtualBox开发，在VirtualBox中创建新虚拟机时自动生成&lt;/p&gt;
&lt;h2 id=&#34;qcow--qcow2--qcow3&#34;&gt;.qcow / .qcow2 / .qcow3
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.qcow&lt;/code&gt;全称QEMUCopy-On-Write&lt;/strong&gt;，来自开源的QEMU项目（后面会提到）&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;.qcow2&lt;/code&gt;是第二版，也是目前的主流，&lt;code&gt;.qcow3&lt;/code&gt;则是实验性版本，同样不太使用&lt;/p&gt;
&lt;p&gt;主要通过&lt;code&gt;qemu-img&lt;/code&gt;命令行工具创建，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-img create -f qcow2 image.qcow2 20G
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;意思是创建一个大小为20GB、格式为qcow2的虚拟磁盘文件&lt;code&gt;image.qcow2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;dmg--sparseimage&#34;&gt;.dmg / .sparseimage
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;.dmg&lt;/code&gt;全称Apple Disk Image&lt;/strong&gt;，是macOS下标准的磁盘映像格式，用于软件分发和数据归档，类似于Windows下的ISO（不过ISO没办法被火眼解析，真是很奇怪了）&lt;/p&gt;
&lt;p&gt;**&lt;code&gt;.sparseimage&lt;/code&gt;**是&lt;code&gt;.dmg&lt;/code&gt;的一种稀疏捆绑磁盘映像，它的特点是文件大小会根据实际存储数据的增多而动态增长，而不是一开始就占用全部分配空间，非常节省存储，类似growable的&lt;code&gt;.vmdk&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;这两种格式都是通过macOS系统自带的磁盘工具应用程序创建&lt;/p&gt;
&lt;h2 id=&#34;zvhd2&#34;&gt;.zvhd2
&lt;/h2&gt;&lt;p&gt;这是Parallels Desktop虚拟机软件使用的专有虚拟磁盘格式&lt;/p&gt;
&lt;p&gt;Parallels是一款在macOS上运行Windows和其他操作系统的流行软件，虚拟机硬盘会以&lt;code&gt;.zvhd2&lt;/code&gt;格式存储&lt;/p&gt;
&lt;h2 id=&#34;xva&#34;&gt;.xva
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;全称Xen Virtual Appliance&lt;/strong&gt;，是Citrix XenServer/XCP-ng虚拟化平台的虚拟机导出格式&lt;/p&gt;
&lt;p&gt;它不仅仅是一个磁盘镜像，而是一个包含了虚拟机完整配置（CPU、内存、网络）和所有虚拟磁盘（VHD格式）的归档包（实际上是一个TAR归档文件），用于虚拟机的备份和迁移&lt;/p&gt;
&lt;h1 id=&#34;内存镜像&#34;&gt;内存镜像
&lt;/h1&gt;&lt;h2 id=&#34;mem--raw&#34;&gt;.mem / .raw
&lt;/h2&gt;&lt;p&gt;通用描述性名称，代表原始内存数据&lt;/p&gt;
&lt;p&gt;使用专业的内存获取工具，如DumpIt等能够制作，在Linux中也可从&lt;code&gt;/dev/mem&lt;/code&gt;等设备文件转储&lt;/p&gt;
&lt;p&gt;这是最为常见的一类，使用频繁&lt;/p&gt;
&lt;h2 id=&#34;dmp&#34;&gt;.dmp
&lt;/h2&gt;&lt;p&gt;常见于Microsoft Windows系统崩溃（也就是蓝屏）时由系统自动生成&lt;code&gt;MEMORY.DMP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也可以通过任务管理器（针对单个进程）或WinDbg等调试工具手动创建&lt;/p&gt;
&lt;h2 id=&#34;vmem&#34;&gt;.vmem
&lt;/h2&gt;&lt;p&gt;VMware的内存镜像格式&lt;/p&gt;
&lt;p&gt;这是虚拟机的内存文件，当一个正在运行的VM被挂起时，其内存内容会被写入&lt;code&gt;.vmem&lt;/code&gt;文件&lt;/p&gt;
&lt;h2 id=&#34;vmsn&#34;&gt;.vmsn
&lt;/h2&gt;&lt;p&gt;同样被使用于VMware&lt;/p&gt;
&lt;p&gt;为虚拟机创建一个快照时生成，&lt;code&gt;.vmsn&lt;/code&gt;文件保存了虚拟机在快照那一刻的运行状态，其中就包含了内存数据&lt;/p&gt;
&lt;h1 id=&#34;移动设备镜像&#34;&gt;移动设备镜像
&lt;/h1&gt;&lt;h2 id=&#34;ios&#34;&gt;iOS
&lt;/h2&gt;&lt;h3 id=&#34;文件夹集合&#34;&gt;文件夹集合
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;就是文件的集合，没有任何格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过iTunes或Finder连接执行备份操作时创建，部分第三方取证工具也能调用此协议进行提取&lt;/p&gt;
&lt;p&gt;主文件夹名通常是设备的UUID（一长串十六进制字符），内部包含大量以两位哈希值命名的子文件夹和散列文件名，里面有&lt;code&gt;Info.plist&lt;/code&gt;，&lt;code&gt;Manifest.db&lt;/code&gt;，&lt;code&gt;Status.plist&lt;/code&gt;等关键索引文件&lt;/p&gt;
&lt;p&gt;看到这种结构，即可100%确定为iOS的官方备份&lt;/p&gt;
&lt;h3 id=&#34;zip--tar&#34;&gt;.zip / .tar
&lt;/h3&gt;&lt;p&gt;移动取证工具供应商，如Cellebrite, Grayshift, Magnet Forensics等都能制作，或者使用别的办法直接导出&lt;/p&gt;
&lt;p&gt;解压后会看到完整的iOS文件系统目录结构，如&lt;code&gt;/private/var/&lt;/code&gt;等&lt;/p&gt;
&lt;p&gt;这比上面备份操作得到的集合包含更多系统文件、应用缓存和数据库&lt;/p&gt;
&lt;h3 id=&#34;bin--raw--dd--img&#34;&gt;.bin / .raw / .dd / .img
&lt;/h3&gt;&lt;p&gt;和计算机镜像文件一样，是对闪存芯片最底层的、逐位的完整复制&lt;/p&gt;
&lt;h2 id=&#34;android&#34;&gt;Android
&lt;/h2&gt;&lt;h3 id=&#34;ab&#34;&gt;.ab
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;全称Android Backup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在电脑上通过Android调试桥(ADB)工具执行&lt;code&gt;adb backup&lt;/code&gt;命令创建&lt;/p&gt;
&lt;h3 id=&#34;zip--tar-1&#34;&gt;.zip / .tar
&lt;/h3&gt;&lt;p&gt;和ios一样来源于移动取证工具供应商，或者通过完全root的手段导出&lt;/p&gt;
&lt;p&gt;压缩包内包含了&lt;code&gt;/data&lt;/code&gt;分区的完整目录结构，也就是很多&lt;code&gt;com.&lt;/code&gt;开头的包，包含了所有用户安装的应用和数据&lt;/p&gt;
&lt;h3 id=&#34;bin--raw--dd--img-1&#34;&gt;.bin / .raw / .dd / .img
&lt;/h3&gt;&lt;p&gt;无需多言&lt;/p&gt;
&lt;h1 id=&#34;安卓模拟器镜像&#34;&gt;安卓模拟器镜像
&lt;/h1&gt;&lt;p&gt;模拟器本质是运行在PC上的虚拟机&lt;/p&gt;
&lt;p&gt;多数模拟器既可以直接获取其运行中的磁盘文件，也可以处理其专有的备份文件&lt;/p&gt;
&lt;p&gt;备份文件通常是包含了磁盘文件的压缩包，如同&lt;code&gt;.apk&lt;/code&gt;格式一样，改后缀名就能解压得到其中的虚拟磁盘文件&lt;/p&gt;
&lt;p&gt;需要注意的是，不同模拟器使用的虚拟磁盘格式也有出入&lt;/p&gt;
&lt;h2 id=&#34;雷电模拟器&#34;&gt;雷电模拟器
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虚拟磁盘格式：&lt;code&gt;.vmdk&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;磁盘文件位于安装目录的&lt;code&gt;vms&lt;/code&gt;文件夹下，点进对应模拟器也能得到&lt;code&gt;.vmdk&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922202115478&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922202115478.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922202115478.png&#34; alt=&#34;image-20250922202115478&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份格式：&lt;code&gt;.ldbk&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.ldbk&lt;/code&gt;文件是一个ZIP压缩包，修改扩展名为&lt;code&gt;.zip&lt;/code&gt;后解压，就能得到&lt;code&gt;data.vmdk&lt;/code&gt;和&lt;code&gt;sdcard.vmdk&lt;/code&gt;两个虚拟磁盘文件&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922202353214&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922202353214.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922202353214.png&#34; alt=&#34;image-20250922202353214&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;mumu模拟器v12&#34;&gt;MuMu模拟器（v12）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虚拟磁盘格式：&lt;code&gt;.vdi&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;磁盘位置和雷电模拟器如出一辙，位于安装目录的&lt;code&gt;vms&lt;/code&gt;文件夹下，不多赘述&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份格式：&lt;code&gt;.mumudata&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.mumudata&lt;/code&gt;也是一个ZIP压缩包，按同样方法改名解压后可获取&lt;code&gt;.vdi&lt;/code&gt;磁盘文件：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922203347610&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922203347610.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922203347610.png&#34; alt=&#34;image-20250922203347610&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;夜神模拟器&#34;&gt;夜神模拟器
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虚拟磁盘格式：&lt;code&gt;.vmdk&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不过它的磁盘位置是位于安装目录的&lt;code&gt;BignoxVMS&lt;/code&gt;文件夹下：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922210328577&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922210328577.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922210328577.png&#34; alt=&#34;image-20250922210328577&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份格式：&lt;code&gt;.npdk&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方文档说32位是&lt;code&gt;.npbk&lt;/code&gt;，64位是&lt;code&gt;.anpbk&lt;/code&gt;，我测试下来64位是&lt;code&gt;.npbk&lt;/code&gt;，32位没找到下载方式&lt;/p&gt;
&lt;p&gt;解压方式不变：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922210404888&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922210404888.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922210404888.png&#34; alt=&#34;image-20250922210404888&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;逍遥模拟器&#34;&gt;逍遥模拟器
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虚拟磁盘格式：&lt;code&gt;.vmdk&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的磁盘位置也不一样，或者说它的文件目录构造就和上面三个不一样&lt;/p&gt;
&lt;p&gt;它的磁盘位于安装目录的&lt;code&gt;\MEmu\MemuHyperv VMs&lt;/code&gt;文件夹下：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922212347566&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922212347566.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922212347566.png&#34; alt=&#34;image-20250922212347566&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份格式：&lt;code&gt;.ova&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解压方式不变：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922213411215&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922213411215.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922213411215.png&#34; alt=&#34;image-20250922213411215&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;bluestacks蓝叠5&#34;&gt;BlueStacks(蓝叠5)
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虚拟磁盘格式：&lt;code&gt;.vhd&lt;/code&gt;、&lt;code&gt;vhdx&lt;/code&gt;、&lt;code&gt;.vdi&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的磁盘位置完全就和上面这些不是一个构造了&lt;/p&gt;
&lt;p&gt;它的虚拟机统一放在安装目录下的Engine文件夹中：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922224220777&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922224220777.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922224220777.png&#34; alt=&#34;image-20250922224220777&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Engine文件夹下也放置了一些json/cfg格式配置文件，以及Manager和UserData文件夹，所有虚拟机共用&lt;/p&gt;
&lt;p&gt;同时，他的磁盘似乎是分开存储的，fastboot使用的是&lt;code&gt;.vdi&lt;/code&gt;，而数据和root使用&lt;code&gt;.vhd&lt;/code&gt;和&lt;code&gt;.vhdx&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Data.vhdx ≈ 用户数据分区&lt;/li&gt;
&lt;li&gt;Root.vhd ≈ 系统分区&lt;/li&gt;
&lt;li&gt;fastboot.vdi ≈ fastboot引导镜像&lt;/li&gt;
&lt;li&gt;.bstk / .cfg 文件 ≈ 配置与快照&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922224340909&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922224340909.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922224340909.png&#34; alt=&#34;image-20250922224340909&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份格式：文件集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;蓝叠备份文件不会压缩，而是直接导出一整个原始文件夹，包含Engine文件夹下的所有必要配置：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250922224729609&#34; href=&#34;http://picture.928330.xyz/typora/image-20250922224729609.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250922224729609.png&#34; alt=&#34;image-20250922224729609&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h1 id=&#34;格式转换&#34;&gt;格式转换
&lt;/h1&gt;&lt;h2 id=&#34;虚拟磁盘之间转换&#34;&gt;虚拟磁盘之间转换
&lt;/h2&gt;&lt;h3 id=&#34;命令行工具--qemu-img&#34;&gt;命令行工具 —— qemu-img
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;qemu-img&lt;/code&gt; 是 QEMU 虚拟化套件中的一个功能极其强大的命令行工具，被誉为虚拟磁盘管理的“瑞士军刀”。它支持几乎所有主流虚拟磁盘格式的读写和转换&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a class=&#34;link&#34; href=&#34;https://qemu.weilnetz.de/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;QEMU
    
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.7em&#34;
        height=&#34;.7em&#34; viewBox=&#34;0 0 21 21&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
        &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
        &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
            fill=&#34;currentColor&#34;&gt;
    &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;查看镜像信息&#34;&gt;查看镜像信息
&lt;/h4&gt;&lt;p&gt;在转换前，最好先用&lt;code&gt;info&lt;/code&gt;命令检查源文件的格式和参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-img info source_disk.vmdk
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出会显示格式 (file format)、虚拟大小 (virtual size)、物理大小 (disk size) 等信息&lt;/p&gt;
&lt;h4 id=&#34;格式转换-1&#34;&gt;格式转换
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;基本语法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-img convert &lt;span style=&#34;color:#56b6c2&#34;&gt;[&lt;/span&gt;options&lt;span style=&#34;color:#56b6c2&#34;&gt;]&lt;/span&gt; -f &amp;lt;source_fmt&amp;gt; -O &amp;lt;output_fmt&amp;gt; &amp;lt;source_file&amp;gt; &amp;lt;target_file&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;常用参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;：显示转换进度条&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f &amp;lt;format&amp;gt;&lt;/code&gt;：指定源文件格式（通常可自动识别，但显式指定更可靠）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-O &amp;lt;format&amp;gt;&lt;/code&gt;：指定输出文件格式（必填！）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;支持格式 keyword：&lt;/strong&gt;&lt;code&gt;vmdk&lt;/code&gt;, &lt;code&gt;vhdx&lt;/code&gt;, &lt;code&gt;vdi&lt;/code&gt;, &lt;code&gt;qcow2&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt; (对应.dd或.img) 等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;vmdk转 vhdx&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-img convert -p -f vmdk -O vhdx source.vmdk target.vhdx
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;需要注意的是VMware分片vmdk需要用描述文件&lt;code&gt;.vmdk&lt;/code&gt;，单独&lt;code&gt;s001.vmdk&lt;/code&gt;这样的文件不能直接转换&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vdi 转 vmdk&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-img convert -p -f vdi -O vmdk source.vdi target.vmdk
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;qcow2 转 raw&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-img convert -p -f qcow2 -O raw source.qcow2 target.img
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;raw/dd/img 转 vmdk&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;qemu-img convert -p -f raw -O vmdk source.dd target.vmdk
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;图形化工具--starwind-v2v-converter&#34;&gt;图形化工具 —— StarWind V2V Converter
&lt;/h3&gt;&lt;p&gt;一款功能强大的免费工具，界面直观，非常轻量化，支持多种物理和虚拟格式的互相转换&lt;/p&gt;
&lt;h4 id=&#34;选择要转换的镜像&#34;&gt;选择要转换的镜像
&lt;/h4&gt;&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250923171013911&#34; href=&#34;http://picture.928330.xyz/typora/image-20250923171013911.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250923171013911.png&#34; alt=&#34;image-20250923171013911&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h4 id=&#34;选择转换目标&#34;&gt;选择转换目标
&lt;/h4&gt;&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250923171314141&#34; href=&#34;http://picture.928330.xyz/typora/image-20250923171314141.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250923171314141.png&#34; alt=&#34;image-20250923171314141&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;growable是&lt;strong&gt;动态扩展磁盘&lt;/strong&gt;，磁盘文件初始体积较小，随着写入数据逐渐增大&lt;/p&gt;
&lt;p&gt;Pre-allocated是&lt;strong&gt;预分配磁盘&lt;/strong&gt;，创建时会一次性占用所有空间，性能更稳定，但占用磁盘空间大&lt;/p&gt;
&lt;p&gt;ESX是专门为VMware ESX/ESXi虚拟化平台使用的vmdk格式，和Workstation/Player用的vmdk略有不同&lt;/p&gt;
&lt;h4 id=&#34;选择虚拟机磁盘接口类型&#34;&gt;选择虚拟机磁盘接口类型
&lt;/h4&gt;&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250923171644294&#34; href=&#34;http://picture.928330.xyz/typora/image-20250923171644294.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250923171644294.png&#34; alt=&#34;image-20250923171644294&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;接下来选择保存位置即可&lt;/p&gt;
&lt;h3 id=&#34;图形化工具--vmware-vcenter-converter&#34;&gt;图形化工具 —— VMware vCenter Converter
&lt;/h3&gt;&lt;p&gt;VMware官方工具，需要单独下载安装：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250923181919052&#34; href=&#34;http://picture.928330.xyz/typora/image-20250923181919052.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250923181919052.png&#34; alt=&#34;image-20250923181919052&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;这个软件功能繁多，还能做到物理磁盘到虚拟磁盘的迁移（P2V），由于主题不在此，就不多赘述&lt;/p&gt;
&lt;h2 id=&#34;不同镜像格式转换&#34;&gt;不同镜像格式转换
&lt;/h2&gt;&lt;p&gt;实际上，使用上面提到过的VMware vCenter Converter就能做到这一点&lt;/p&gt;
&lt;p&gt;先用挂载工具把源镜像挂载为物理磁盘，然后使用VMware vCenter Converter导出为虚拟磁盘即可&lt;/p&gt;
&lt;p&gt;以及使用一些软件，比如火眼仿真提供的gho转vmdk：&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;image-20250923182631921&#34; href=&#34;http://picture.928330.xyz/typora/image-20250923182631921.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/image-20250923182631921.png&#34; alt=&#34;image-20250923182631921&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
</description>
        </item>
        <item>
        <title>一文弄懂字符集与编码</title>
        <link>https://blog.928330.xyz/p/%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/</link>
        <pubDate>Wed, 13 Aug 2025 14:32:41 +0800</pubDate>
        
        <guid>https://blog.928330.xyz/p/%E4%B8%80%E6%96%87%E5%BC%84%E6%87%82%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81/</guid>
        <description>&lt;img src="http://picture.928330.xyz/typora/unicode-101-introduction.social.jpg" alt="Featured image of post 一文弄懂字符集与编码" /&gt;&lt;p&gt;在计算机的世界里，我们看到的所有内容 —— 无论是文字、符号还是表情 —— 本质上都是一串串由&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;组成的二进制数字&lt;/p&gt;
&lt;p&gt;那么一个我们能看懂的、有意义的符号，是如何被计算机存储，又是如何被准确无误地显示出来的呢？&lt;/p&gt;
&lt;p&gt;这个过程就是我们今天要讲述的关于“字符”的完整故事&lt;/p&gt;
&lt;h2 id=&#34;基础概念字符字形字节与字&#34;&gt;基础概念：字符、字形、字节与字
&lt;/h2&gt;&lt;p&gt;要理解后续的一切，我们必须先精确区分几个最基本的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象的语义单位 —— &lt;strong&gt;字符（Character）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;具象的视觉单位 —— &lt;strong&gt;字形（Glyph）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;计算机的物理存储单位 —— &lt;strong&gt;字节（Byte）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以及容易混淆的“字”——&lt;strong&gt;计算机的字（Word）&lt;/strong&gt; 与 &lt;strong&gt;人类语言的字&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字符character&#34;&gt;字符（Character）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;字符，是一个抽象的、信息的基本语义单元，是我们用来表达意义的最小符号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;英文字母&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;是字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;是字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标点符号&lt;code&gt;.&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;!&lt;/code&gt;是字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;汉字&lt;code&gt;中&lt;/code&gt;、&lt;code&gt;国&lt;/code&gt;、&lt;code&gt;人&lt;/code&gt;是字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表情符号&lt;code&gt;😂&lt;/code&gt;、&lt;code&gt;👍&lt;/code&gt;也是字符！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个层面，字符是无形的，它只关乎“是什么”，而不关乎“长什么样”或“如何存储”&lt;/p&gt;
&lt;h3 id=&#34;字形glyph&#34;&gt;字形（Glyph）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;字形，是字符的具体视觉表现形式，是我们真正在屏幕上看到的那个“形状”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个字符可以有多种不同的字形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符“拉丁字母A”可以有 &lt;code&gt;A&lt;/code&gt; (正常), &lt;em&gt;&lt;strong&gt;&lt;code&gt;A&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt;(粗斜体), &lt;code&gt;𝔸&lt;/code&gt; (空心) 等多种字形&lt;/li&gt;
&lt;li&gt;同一个汉字“骨”，在宋体、楷体、草书中的字形也完全不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反过来，多个字符也可能组合成一个字形（这被称为“合字”或“连字”，Ligature）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在某些英文字体中，字符 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt; 相邻时，会合并成一个单独的 &lt;code&gt;ﬁ&lt;/code&gt; 字形，以避免 &lt;code&gt;f&lt;/code&gt; 的钩与 &lt;code&gt;i&lt;/code&gt; 的点碰撞。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;简单说：字符是“骨”，字形是“皮肉”。我们操作和存储的是字符，而最终渲染出来给人看的是字形。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;字节byte&#34;&gt;字节（Byte）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;字节，是计算机中数据存储和处理的基本单位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个字节由8个比特（bit）组成，每个比特非0即1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个字节能表示2⁸=256种不同的状态（0-255）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字word&#34;&gt;字（Word）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;计算机的“字”与人类的“字”毫无必然联系&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;计算机中的字word&#34;&gt;计算机中的“字”（Word）
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;在计算机科学中，字（Word）是CPU处理数据的自然单位，是计算机一次性读取、处理或传输的最小数据块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字的大小依赖于计算机架构&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;16 位系统的一个字是 2 个字节（16 位）&lt;/li&gt;
&lt;li&gt;32 位系统的一个字是 4 个字节（32 位）&lt;/li&gt;
&lt;li&gt;64 位系统的一个字是 8 个字节（64 位）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在汇编语言和系统底层编程中，“字”是非常重要的基本数据宽度概念&lt;/p&gt;
&lt;h4 id=&#34;人类语言中的字&#34;&gt;人类语言中的“字”
&lt;/h4&gt;&lt;p&gt;在人类语言里，“字”指的是一个书写符号单位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在中文里，“字”通常是一个汉字，例如&lt;code&gt;中&lt;/code&gt;、&lt;code&gt;国&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在英文里，没有严格对应的“字”概念，通常用&lt;code&gt;letter&lt;/code&gt;（字母）或&lt;code&gt;word&lt;/code&gt;（单词）描述&lt;/li&gt;
&lt;li&gt;在日语里，一个“字”可能是汉字、平假名、片假名中的任意一个符号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在大多数情况下，人类语言里的“字”可以看作是一个字符，但它们并不是严格等同的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以认为一个英语单词是一个“字”，但它却是多个“字符”的组合&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;span style=&#34;color:red;font-size:20px&#34;&gt;&lt;strong&gt;那么此时，矛盾就出现了：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;世界上有成千上万个抽象的“字符”，而计算机的基本存储单元“字节”一次只能表示256种状态！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就需要建立一套完整的映射体系，才能让所有字符都能在计算机上显示&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;字符集&#34;&gt;字符集
&lt;/h2&gt;&lt;p&gt;为了让计算机能够处理字符，人们首先需要做一件事：&lt;/p&gt;
&lt;p&gt;把世界上所有的字符收集起来，排个队，给每个字符分配一个独一无二的编号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符集，就是这样一个“字符的集合”以及“字符与编号的对应表”。可以把它想象成一本为全世界所有字符编写的巨大“字典”，而对应的编号，我们称之为码点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符集本身只是一套标准、一个“名册”，它只规定了“哪个字符对应哪个数字”，但还没有规定这个数字具体应该如何在计算机中用字节来存储&lt;/p&gt;
&lt;h3 id=&#34;字符集的历史演进与兼容性问题&#34;&gt;字符集的历史演进与兼容性问题
&lt;/h3&gt;&lt;h4 id=&#34;ascii时代&#34;&gt;ASCII时代
&lt;/h4&gt;&lt;p&gt;计算机诞生于美国，最早的&lt;strong&gt;ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集&lt;/strong&gt;是为英语环境量身定做的&lt;/p&gt;
&lt;p&gt;它收录了128个最常用的字符，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;95个可打印字符：大小写英文字母（&lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;）、数字（&lt;code&gt;0-9&lt;/code&gt;）、以及各种标点和符号（&lt;code&gt;!&lt;/code&gt;,&lt;code&gt;@&lt;/code&gt;,&lt;code&gt;#&lt;/code&gt;等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;33个不可打印的控制字符：如回车（&lt;code&gt;CR&lt;/code&gt;）、换行（&lt;code&gt;LF&lt;/code&gt;）、制表符（&lt;code&gt;Tab&lt;/code&gt;）等，用于控制打印机等设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它的码点范围是0到127，所以用一个字节（0-255）来存储一个ASCII 字符绰绰有余&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际上，ASCII码只用到了一个字节（8个比特）中的低7位，最高位始终为0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，字符&lt;code&gt;&#39;A&#39;&lt;/code&gt;的码点是 65，其二进制表示为&lt;code&gt;01000001&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个“最高位为0”的特性，为后来的扩展埋下了伏笔&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ASCII码现在依然在被广泛使用，你可以在很多编程语言里面见到它，而且可以说它是现代字符编码体系的根基&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;ASCII 表| 菜鸟教程&#34; href=&#34;http://picture.928330.xyz/typora/ascii-1-1.png&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/ascii-1-1.png&#34; alt=&#34;ASCII 表| 菜鸟教程&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h4 id=&#34;地区性字符集时代&#34;&gt;地区性字符集时代
&lt;/h4&gt;&lt;p&gt;当计算机走向世界，问题出现了：&lt;/p&gt;
&lt;p&gt;欧洲需要 &lt;code&gt;é&lt;/code&gt;, &lt;code&gt;ü&lt;/code&gt;，中国需要汉字，日本需要假名，单一的 ASCII 远远不够用！&lt;/p&gt;
&lt;p&gt;于是，世界各地纷纷利用ASCII留下的“遗产”—— 那个未被使用的最高位比特0，来扩展自己的字符集&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当一个字节的最高位是&lt;code&gt;0&lt;/code&gt;时，它仍然表示一个标准的ASCII字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当最高位是&lt;code&gt;1&lt;/code&gt;时，它就进入了各个地区自定义的“扩展区”（码点范围 128-255）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是一些比较有代表性的编码方案吗，我们后面还会详细说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ISO-8859-1 (Latin-1)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向西欧，它利用了128-255的码点来表示带音标的字母，如&lt;code&gt;é&lt;/code&gt;、&lt;code&gt;ü&lt;/code&gt;、&lt;code&gt;©&lt;/code&gt; 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GB2312/GBK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向中国大陆，由于汉字数量远超128个，它采用&lt;strong&gt;双字节编码&lt;/strong&gt;方案&lt;/p&gt;
&lt;p&gt;当检测到一个字节的最高位是1时，就认为它和紧随其后的下一个字节共同表示一个汉字&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GBK&lt;/code&gt; 是 &lt;code&gt;GB2312&lt;/code&gt; 的扩展，收录了更多汉字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BIG5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向中国台湾地区，同样是双字节方案，用于表示繁体字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Shift_JIS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向日本，是一个更复杂的变长编码方案，用于表示日文汉字和假名&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&#34;color:red&#34;&gt;&lt;strong&gt;虽然这样方便了各个地区的用户，但也是之后乱码问题出现的罪魁祸首&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;unicode时代&#34;&gt;Unicode时代
&lt;/h4&gt;&lt;p&gt;为了终结大家各用各的这种混乱，Unicode应运而生&lt;/p&gt;
&lt;p&gt;它的目标是“天下书同文”，它不是要创造又一个与其它标准竞争的字符集，而是要统一和包容所有字符！&lt;/p&gt;
&lt;p&gt;也就是说，它要为地球上每一种语言的每一个字符都分配一个全球唯一的码点！&lt;/p&gt;
&lt;p&gt;这一伟大的工程&lt;del&gt;应该&lt;/del&gt;造福了全人类·，所以我们也叫他&lt;strong&gt;统一码/万国码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unicode码点的标准表示方法是用&lt;code&gt;U+十六进制数字&lt;/code&gt;来表示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汉字&lt;code&gt;中 &lt;/code&gt;的Unicode码点是&lt;code&gt;U+4E2D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;表情&lt;code&gt;😂 &lt;/code&gt;的Unicode码点是&lt;code&gt;U+1F602&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;你也可能看到另一种方法：&lt;code&gt;\u+十六进制数字&lt;/code&gt;，这是编程语言中的转义字符表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汉字&lt;code&gt;中 &lt;/code&gt;的Unicode转义字符是&lt;code&gt;\u4E2D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;表情&lt;code&gt;😂 &lt;/code&gt;的Unicode转义字符是&lt;code&gt;\u1F602&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何存储如此庞大的字符量呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unicode标准码点范围是从&lt;code&gt;U+0000&lt;/code&gt;到&lt;code&gt;U+10FFFF&lt;/code&gt;，共计约1,114,112个码点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些码点被划分成17 个平面（Planes），每个平面包含65536（即 2¹⁶）个码点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基本多文种平面（BMP, Plane 0）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含了从&lt;code&gt;U+0000&lt;/code&gt;到&lt;code&gt;U+FFFF&lt;/code&gt;的码点，涵盖了世界上绝大多数常用字符，包括常用汉字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;辅助平面（Supplementary Planes, Plane 1–16）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包含了从&lt;code&gt;U+010000&lt;/code&gt;到&lt;code&gt;U+10FFFF&lt;/code&gt;的码点，用于表示生僻字、古代文字以及各种符号，比如Emoji表情&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从此，无论在哪个国家、哪个平台，&lt;code&gt;U+4E2D&lt;/code&gt;永远只代表&lt;code&gt;中&lt;/code&gt;这一个字符&lt;/p&gt;
&lt;h3 id=&#34;字符集标准组织&#34;&gt;字符集标准组织
&lt;/h3&gt;&lt;p&gt;制定这些标准的是一些国际组织，其中最重要的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Unicode联盟（Unicode Consortium）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个非营利组织，其成员包括苹果、谷歌、微软、Adobe等各大科技巨头。它负责开发、维护和推广Unicode标准，包括我们日常使用的Emoji表情的标准化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;国际标准化组织（ISO）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它也发布了与Unicode对应的 ISO/IEC 10646 标准，基本上可以认为Unicode和 ISO/IEC 10646 是同一个字符集标准的不同名称&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;至此，我们通过字符集，成功地将所有抽象的字符转化为了全球统一的数字（码点）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:yellow;&#34;&gt;&lt;strong&gt;一个极其重要的问题&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unicode本身只定义了码点，它并没有规定这个号码在计算机中应该如何用字节来存储！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;编码&#34;&gt;编码
&lt;/h2&gt;&lt;p&gt;现在我们有了“字符”和“码点”的对应关系（字符集），但还有一个最关键、最实际的问题没有解决：&lt;/p&gt;
&lt;p&gt;如何将这些码点（数字），特别是那些大于 255 的庞大数字，高效地用计算机唯一懂的语言来表示？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案是编码 —— 将字符的码点（数字）翻译成字节序列（物理存储）的具体规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果说字符集是字典，那编码就是语法规则，它教我们如何用字节来书写字典里的每一个页码（码点）&lt;/p&gt;
&lt;h3 id=&#34;编码格式&#34;&gt;编码格式
&lt;/h3&gt;&lt;p&gt;在编程领域，为了处理非ASCII字符，历史上形成了两种截然不同的解决思路&lt;/p&gt;
&lt;h4 id=&#34;多字节字符集-mbcs---multi-byte-character-set&#34;&gt;多字节字符集 (MBCS - Multi-byte Character Set)
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;这是一种“让程序变聪明”的编码层面解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串在内存中仍然以&lt;code&gt;char&lt;/code&gt;数组的形式存放，但程序在处理时，必须“意识到”这个字节序列采用了某种特定编码（如 GBK）&lt;/p&gt;
&lt;p&gt;比如，对于C语言字符串 &lt;code&gt;&amp;quot;你好&amp;quot;&lt;/code&gt;，在GBK编码下，它占4个字节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;strlen(&amp;quot;你好&amp;quot;)&lt;/code&gt;会返回4，因为它只认识字节&lt;/li&gt;
&lt;li&gt;而一个特殊的、能识别多字节的函数&lt;code&gt;mbstrlen(&amp;quot;你好&amp;quot;)&lt;/code&gt;则会返回2，因为它知道两个字节才构成一个汉字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方式处理起来非常复杂且极易出错，因为我们不能再想当然地通过&lt;code&gt;str[i]&lt;/code&gt;来访问第i个字符 —— &lt;code&gt;str[i]&lt;/code&gt;可能只是一个汉字的前半部分！字符串的截取、遍历和修改都变得困难了！&lt;/p&gt;
&lt;h4 id=&#34;宽字符-wide-character&#34;&gt;宽字符 (Wide Character)
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;这是一种“让数据类型变强大”的数据类型层面解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它不再让程序去适应复杂的字节流，而是定义了一个新的、足够宽的数据类型，这个类型通常是2或4个字节&lt;/p&gt;
&lt;p&gt;比如我们在C++中定义一个这样的宽字符&lt;code&gt;wchar_t&lt;/code&gt;类型：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5c07b&#34;&gt;wchar_t&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;wide_str&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#98c379&#34;&gt;L&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;你好&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;wide_str&lt;/code&gt;数组的每个元素都能完整地存放一个字符的码点，而&lt;code&gt;L&lt;/code&gt;前缀告诉编译器，这个字符串用宽字符存储，不是普通的&lt;code&gt;char&lt;/code&gt;字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wide_str[0]&lt;/code&gt;就是字符&lt;code&gt;你&lt;/code&gt;，&lt;code&gt;wide_str[1]&lt;/code&gt;就是字符&lt;code&gt;好&lt;/code&gt;，数组长度为2&lt;/p&gt;
&lt;p&gt;这让字符串的索引和遍历恢复了简单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;他也有不少缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空间浪费&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使是存储纯英文 &amp;ldquo;hello&amp;rdquo;，每个字符也要占用2或4个字节，造成空间浪费&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跨平台困难&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然很难以置信，但&lt;code&gt;wchar_t&lt;/code&gt;的具体大小在不同主流操作系统上并不统一！&lt;/p&gt;
&lt;p&gt;在 Windows 上它通常是 2 字节（对应 UTF-16），而在 Linux 和 macOS 上它通常是 4 字节（对应 UTF-32），这使得依赖 &lt;code&gt;wchar_t&lt;/code&gt; 的代码难以跨平台移植！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+++&lt;/p&gt;
&lt;p&gt;正是因为这两种早期方案都有明显的缺陷，现代编程实践大多推荐直接使用UTF-8编码的普通&lt;code&gt;char&lt;/code&gt;字符串，并配合专门、可靠的库（如 ICU）来处理复杂的字符串操作&lt;/p&gt;
&lt;p&gt;至于什么是UTF-8编码，我们接着往下看&lt;/p&gt;
&lt;h3 id=&#34;编码方式&#34;&gt;编码方式
&lt;/h3&gt;&lt;h4 id=&#34;ascii编码&#34;&gt;ASCII编码
&lt;/h4&gt;&lt;p&gt;最简单的编码，码点值就是字节值&lt;/p&gt;
&lt;p&gt;字符&lt;code&gt;&#39;A&#39;&lt;/code&gt;的码点是 65，其编码就是一个值为 65 的字节&lt;/p&gt;
&lt;h4 id=&#34;gbk编码&#34;&gt;GBK编码
&lt;/h4&gt;&lt;p&gt;GBK的全称是国标扩展码拼音“Guóbiāo Kuòzhǎn”的缩写&lt;/p&gt;
&lt;p&gt;这是一种典型的多字节编码（MBCS），解码时检查一个字节的最高位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果为&lt;code&gt;0&lt;/code&gt;（0-127），则它本身就是一个单字节的ASCII字符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果为&lt;code&gt;1&lt;/code&gt;（128-255），则它必须和紧随其后的下一个字节共同组成一个双字节的汉字&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;utf-8编码现代标准&#34;&gt;UTF-8编码（现代标准）
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;这是现代互联网的基石，它是一种针对Unicode的、可变长度的字符编码，其设计堪称精妙绝伦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它兼容ASCII编码&lt;/strong&gt;：对英文字母和数字用1个字节编码，与ASCII完全一样，这意味着一个纯英文的ASCII文件，本身就是一个合法的UTF-8文件，无需任何转换&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它对不同字符有不同字节规定&lt;/strong&gt;：对拉丁文、希腊文用2字节；对常用汉字用3字节；对罕见字符和表情用4字节&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UTF-8通过每个字节开头的几个比特来标记这个字符的长度：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0xxxxxxx&lt;/code&gt;: 单字节，表示U+0000到U+007F(ASCII)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;110xxxxx 10xxxxxx&lt;/code&gt;: 双字节，由一个&lt;code&gt;110&lt;/code&gt;开头的字节和个&lt;code&gt;10&lt;/code&gt;开头的字节组成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/code&gt;: 三字节，由一个&lt;code&gt;1110&lt;/code&gt;开头的字节和两个&lt;code&gt;10&lt;/code&gt;开头的字节组成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/code&gt;: 四字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体对应关系如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Unicode 范围 (十六进制)&lt;/th&gt;
          &lt;th&gt;UTF-8 字节序列 (二进制)&lt;/th&gt;
          &lt;th&gt;字节数&lt;/th&gt;
          &lt;th&gt;常见语言/用途举例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;U+0000&lt;/code&gt; - &lt;code&gt;U+007F&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;0xxxxxxx&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;英语&lt;/strong&gt;（基本拉丁字母）、数字、ASCII 标点、控制字符&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;U+0080&lt;/code&gt; - &lt;code&gt;U+07FF&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;110xxxxx 10xxxxxx&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;拉丁文扩展&lt;/strong&gt;（é ñ 等）、希腊文、俄语西里尔字母、希伯来文、阿拉伯文&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;U+0800&lt;/code&gt; - &lt;code&gt;U+FFFF&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;东亚文字&lt;/strong&gt;（中文、日文假名、韩文音节）、越南文、泰文、天城文（印地语等）、大部分表情符号&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;U+10000&lt;/code&gt; - &lt;code&gt;U+10FFFF&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;11110xxx 10xxxxxx 10xxxxxx 10xxxxxx&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;罕见/扩展字符&lt;/strong&gt;（CJK 扩展汉字、古代文字、乐谱符号、更多表情符号）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;这些&lt;code&gt;x&lt;/code&gt;是实际用来填充字符码点二进制位的地方，从右向左、从低位到高位填充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eg：汉字“中” (&lt;code&gt;U+4E2D&lt;/code&gt;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Unicode 码点&lt;/strong&gt;：&lt;code&gt;U+4E2D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围&lt;/strong&gt;：&lt;code&gt;4E2D&lt;/code&gt;在&lt;code&gt;U+0800&lt;/code&gt; - &lt;code&gt;U+FFFF&lt;/code&gt;之间，所以需要 &lt;strong&gt;3 个字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二进制表示&lt;/strong&gt;：&lt;code&gt;4E2D&lt;/code&gt;的二进制是&lt;code&gt;0100 1110 0010 1101&lt;/code&gt; (16位)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匹配模板&lt;/strong&gt;：三字节模板是&lt;code&gt;1110xxxx 10xxxxxx 10xxxxxx&lt;/code&gt;。这个模板共有4+6+6=16个&lt;code&gt;x&lt;/code&gt;，正好容纳16位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;填充&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;最右边的6个&lt;code&gt;x&lt;/code&gt;填入最低的6位：&lt;code&gt;001101&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中间的6个&lt;code&gt;x&lt;/code&gt;填入接下来的6位：&lt;code&gt;111000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最左边的4个&lt;code&gt;x&lt;/code&gt;填入最高的4位：&lt;code&gt;0100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;得到字节序列&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1110 0100&lt;/code&gt; -&amp;gt; &lt;code&gt;E4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10 111000&lt;/code&gt; -&amp;gt; &lt;code&gt;B8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10 001101&lt;/code&gt; -&amp;gt; &lt;code&gt;AD&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;：汉字“中”的UTF-8编码是**&lt;code&gt;E4 B8 AD&lt;/code&gt;**&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;这种设计确保了程序在任何位置开始读取字节流，都能准确判断出一个字符的起始和结束边界&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;utf-16-编码&#34;&gt;UTF-16 编码
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;UTF-16也是一种用于编码Unicode字符的格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它通常使用2个字节（对于BMP内的字符）或4个字节（对于辅助平面的字符）来表示一个字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于其大部分情况下定长的特性，便于程序内部进行索引，因此被广泛用作许多系统和语言的&lt;strong&gt;内部内存表示&lt;/strong&gt;，例如Windows操作系统内核、Java语言的&lt;code&gt;String&lt;/code&gt;类型&lt;/p&gt;
&lt;h4 id=&#34;utf-32-编码&#34;&gt;UTF-32 编码
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;类似UTF-16，它也是定长的，为每一个字符分配固定的4个字节（32位）来存储其Unicode码点值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它和UTF-16一样，在文件存储和网络传输方面不如UTF-8流行，一个主要原因就是接下来要讲的字节序问题&lt;/p&gt;
&lt;h3 id=&#34;字节序&#34;&gt;字节序
&lt;/h3&gt;&lt;p&gt;当一个字符需要用多个字节来表示时，就必须面对一个问题：&lt;/p&gt;
&lt;p&gt;这些字节应该按什么顺序存储？就像写数字&lt;code&gt;258&lt;/code&gt;，是从左到右写 &lt;code&gt;2, 5, 8&lt;/code&gt;，还是从右到左写&lt;code&gt;8, 5, 2&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;这也就是所谓的&lt;strong&gt;字节序 —— 多字节数据在内存或文件中按字节排列的顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UTF-8的编码规则中，字节内部的位顺序是固定的，没有所谓“高字节”和“低字节”的问题；而UTF-16和UTF-32是定长的，而且字节内部可以交换顺序，所以会有字节序区别&lt;/p&gt;
&lt;p&gt;常见的两种字节序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大端序 (Big-Endian, BE)&lt;/strong&gt;：&lt;strong&gt;高位的有效字节存放在内存的低地址（大头在前）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这符合人类的阅读习惯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小端序 (Little-Endian, LE)&lt;/strong&gt;：&lt;strong&gt;低位的有效字节存放在内存的低地址（小头在前）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这在 x86 架构的计算机（我们日常使用的大多数 PC）中更为常见&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，字符 &lt;code&gt;中&lt;/code&gt;的UTF-16编码 (&lt;code&gt;U+4E2D&lt;/code&gt;) 是两个字节&lt;code&gt;4E&lt;/code&gt;和&lt;code&gt;2D&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在大端序系统上，内存中存储为：&lt;code&gt;... [地址1000]: 4E, [地址1001]: 2D ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在小端序系统上，内存中存储为：&lt;code&gt;... [地址1000]: 2D, [地址1001]: 4E ...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果搞错了字节序，解码就会出错！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了解决这个问题，人们发明了BOM(Byte Order Mark)，它是一个放在文件开头的、不可见的特殊暗号字符（码点为 &lt;code&gt;U+FEFF&lt;/code&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过读取文件开头的几个字节，以BOM为参考，程序就可以判断文件的字节序和编码：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果文件开头是&lt;code&gt;FE FF&lt;/code&gt;，说明是&lt;strong&gt;UTF-16 大端序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果文件开头是&lt;code&gt;FF FE&lt;/code&gt;，说明是&lt;strong&gt;UTF-16 小端序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果文件开头是&lt;code&gt;EF BB BF&lt;/code&gt;，说明是&lt;strong&gt;UTF-8&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;正如前面所说，UTF-8本身没有字节序问题，它的BOM只是用来表明这是一个UTF-8文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，在Web开发和类Unix系统中，普遍推荐使用不带 BOM 的 UTF-8（UTF-8 without BOM），因为某些旧的脚本和工具可能不认识 BOM，并将其作为垃圾内容输出，导致页面顶部出现空行或其他问题&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;理解了前面的字符集和编码，乱码的产生原因就非常清晰了&lt;/p&gt;
&lt;h2 id=&#34;乱码&#34;&gt;乱码
&lt;/h2&gt;&lt;p&gt;&lt;span style=&#34;color:red;font-size:18px&#34;&gt;&lt;strong&gt;乱码的唯一根源在于：用 A 编码方式存储的字节序列，却被当作 B 编码方式去解码和显示。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就像你拿到一份用中文密码本加密的信息，却错误地拿了一本俄文密码本去解密，结果自然是一堆谁也看不懂的天书&lt;/p&gt;
&lt;p&gt;字节本身是无辜的，它们只是一串0和1，真正的罪魁祸首是解码时错误的假设&lt;/p&gt;
&lt;h3 id=&#34;错误的翻译--gbk打开utf-8文件&#34;&gt;错误的翻译 —— GBK打开UTF-8文件
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这是最常见的场景：我们用国际标准的UTF-8创建了文件，但它被一个只认识本地编码的旧程序打开了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们用 Python 写入一句话&lt;code&gt;“你好，世界”&lt;/code&gt;，并明确使用&lt;code&gt;utf-8&lt;/code&gt;编码保存，查看它UTF-8编码字节&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;text&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;你好，世界&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;utf8_bytes&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;text&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;encode&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#c678dd&#34;&gt;with&lt;/span&gt; &lt;span style=&#34;color:#e5c07b&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;utf8.txt&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#c678dd&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;f&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e06c75&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#e06c75&#34;&gt;utf8_bytes&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5c07b&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e06c75&#34;&gt;utf8_bytes&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;hex&lt;/span&gt;()&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;upper&lt;/span&gt;())
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;E4BDA0E5A5BDEFBC8CE4B896E7958C&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们再模拟一个旧程序用&lt;code&gt;gbk&lt;/code&gt;编码去读取这个&lt;code&gt;hello_utf8.txt&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#c678dd&#34;&gt;with&lt;/span&gt; &lt;span style=&#34;color:#e5c07b&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;utf8.txt&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#c678dd&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;f&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e06c75&#34;&gt;byte_data&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;read&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#7f848e&#34;&gt;#errors=&amp;#39;replace&amp;#39; 表示遇到无法解码的字节时，用 &amp;#39;&amp;#39; 替换&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;garbled_text&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;byte_data&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;decode&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;gbk&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e06c75&#34;&gt;errors&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;replace&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5c07b&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#e06c75&#34;&gt;garbled_text&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;浣犲ソ锛屼笘鐣&lt;/span&gt;�
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;这就是典型的乱码，因为utf-8下的&lt;code&gt;E4BDA0...&lt;/code&gt;这串字节在GBK的字典里恰好对应了另一组完全不同的汉字&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;锟斤拷&#34;&gt;“锟斤拷”
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;这个著名的乱码组合，就是源于将UTF-8编码的汉字，错误地用 GBK 或其他本地编码来显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:yellow;&#34;&gt;&lt;strong&gt;它的成因非常特殊，它源于对“错误”本身的再次错误解读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&#34;替换字符&#34;&gt;替换字符
&lt;/h4&gt;&lt;p&gt;这个故事的主角，是一个特殊的Unicode字符 —— &lt;strong&gt;替换字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个程序在解码字节流时，如果遇到了一个不符合当前编码规则的、无法识别的无效字节序列，该怎么办？&lt;/p&gt;
&lt;p&gt;一个设计良好的程序不会崩溃，而是会遵循Unicode标准，在那个出错的位置插入一个官方的&lt;strong&gt;替换字符&lt;/strong&gt;，也就是**&lt;code&gt;U+FFFD&lt;/code&gt;**，它在屏幕上通常显示为一个黑色的菱形中间带一个问号&lt;/p&gt;
&lt;h4 id=&#34;错误的诞生&#34;&gt;错误的诞生
&lt;/h4&gt;&lt;p&gt;现在，让我们用代码来模拟它的产生过程：&lt;/p&gt;
&lt;p&gt;假设一个程序（比如数据库、文本编辑器等）在处理数据时，遇到了它无法理解的字节，作为安全措施，程序在内存中生成了两个Unicode替换字符，我们在Python中可以直接用它的码点 \uFFFD 来表示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;error_text&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;\uFFFD\uFFFD&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，程序将包含这两个替换字符的字符串，以标准的UTF-8格式写入文件，一个&lt;code&gt;U+FFFD&lt;/code&gt;的UTF-8编码是 3个字节：&lt;code&gt;EF&lt;/code&gt; &lt;code&gt;BF&lt;/code&gt; &lt;code&gt;BD&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;utf8_error&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;error_text&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;encode&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;现在，另一个程序（或用户）错误地使用 GBK 编码来读取这串字节，注意这里必须用 gbk 编码，如果用 gb2312会因字符不全而报错：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;text&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;utf8_error&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;decode&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;gbk&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5c07b&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;GBK解码结果: &amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;text&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;锟斤拷&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;其中过程是怎么样的？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序读取 &lt;code&gt;EF BF BD EF BF BD&lt;/code&gt;这6个字节&lt;/li&gt;
&lt;li&gt;GBK 解码器按两个字节一组来处理，因为它认为最高位是 &lt;code&gt;1&lt;/code&gt; 的字节都是双字节字符的一部分：
&lt;ul&gt;
&lt;li&gt;读到**&lt;code&gt;EF BF&lt;/code&gt;&lt;strong&gt;，去查GB码表，这对字节恰好对应了汉字&lt;/strong&gt;&lt;code&gt;锟&lt;/code&gt;**&lt;/li&gt;
&lt;li&gt;接着读到**&lt;code&gt;BD EF&lt;/code&gt;&lt;strong&gt;，再次去查GBK码表，这对字节也恰好有对应汉字&lt;/strong&gt;&lt;code&gt;斤&lt;/code&gt;**&lt;/li&gt;
&lt;li&gt;最后读到**&lt;code&gt;BF BD&lt;/code&gt;&lt;strong&gt;，第三次去查GBK码表，这对字节同样对应了一个汉字&lt;/strong&gt;&lt;code&gt;拷&lt;/code&gt;**&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;就这样，原本代表解码错误的、在UTF-8下有明确含义的字节序列，在 GBK解码器的一系列巧合误解之下，被翻译成了我们在座各位都无比熟悉的三个汉字——&lt;strong&gt;&lt;code&gt;锟斤拷&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;锟斤拷是传播比较广泛的乱码，真正的乱码形式多种多样，网上有人整理了常见的乱码对照表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; data-caption=&#34;乱码对照表_乱码符号-CSDN博客&#34; href=&#34;http://picture.928330.xyz/typora/07e042d16001b86b36b38a36dfaf3475.jpeg&#34;&gt;
&lt;img src=&#34;http://picture.928330.xyz/typora/07e042d16001b86b36b38a36dfaf3475.jpeg&#34; alt=&#34;乱码对照表_乱码符号-CSDN博客&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;如果你不记得什么是ISO-8859-1：&lt;a class=&#34;link&#34; href=&#34;#%e5%9c%b0%e5%8c%ba%e6%80%a7%e5%ad%97%e7%ac%a6%e9%9b%86%e6%97%b6%e4%bb%a3&#34; &gt;地区性字符集时代
    
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表里面提到锟拷码是gbk读取两次的结果，其实就是utf-8 -&amp;gt;错误字符 -&amp;gt; 替换字符 -&amp;gt; 锟斤拷&lt;/p&gt;
&lt;h3 id=&#34;无能的编码检测&#34;&gt;无能的编码检测
&lt;/h3&gt;&lt;p&gt;既然乱码是因编码不匹配产生的，那程序能自动检测文件的编码吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案是可以，但永远不可靠&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编码检测本质上是一种启发式猜测，线索极少&lt;/p&gt;
&lt;p&gt;程序会读取一部分字节，然后用各种常见编码的规则去试，并根据以下线索进行打分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BOM (Byte Order Mark)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是最可靠的线索，如果文件开头有&lt;code&gt;EF BB BF&lt;/code&gt;，那几乎可以100%确定是UTF-8&lt;/p&gt;
&lt;p&gt;但我们上面也说过了，绝大多数文件（特别是网页）为了兼容性，并不带BOM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无效字节序列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编码有其严格的字节组合规则，如果在尝试用GBK解码时，出现了大量不符合其双字节规则的序列（像上面例子中的单个&lt;code&gt;0xAA&lt;/code&gt;），那么程序就会认为这可能不是GBK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;统计学特征&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析字节的分布规律，例如，一段英文文本如果用UTF-8编码，大部分字节都会在0-127范围内。而一段中文GBK文本，则会出现大量连续成对的大于127的字节&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;然而，这种方法是不可靠的：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于短文本，样本太少，统计学方法完全失效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;巧合时有发生，有些字节序列在多种编码下恰好都是“合法”的，只是代表的意义不同&lt;/p&gt;
&lt;p&gt;在早期的windows版本中，如果使用写字板打开txt文件，输入“联通”两个字，此时是以GBK形式保存，但由于他们的编码恰好和utf-8的双字节格式相同（比如“联”是&lt;code&gt;C1&lt;/code&gt; &lt;code&gt;AA&lt;/code&gt;，即&lt;code&gt;11000001&lt;/code&gt; &lt;code&gt;10101010&lt;/code&gt;），阅读器错误的使用utf-8解码它们，就会导致乱码&lt;/p&gt;
&lt;p&gt;还有一个著名的例子就是短语&lt;code&gt;Bush hid the facts&lt;/code&gt;，这也是一个在中文Windows系统上曾广为人知的文本显示乱码，当它以ASCII/UTF-8保存后，如果被程序错误地当作UTF-16LE来打开，会显示出几个汉字&lt;code&gt;联 আরি󏐠&lt;/code&gt;或类似乱码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所以，永远不要依赖自动检测！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与其让接收方去费力猜测，不如让发送方在明确标注语言，现代协议和格式都会提供这种明确指定编码的机制&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP响应头&lt;/strong&gt;：服务器在返回网页时，通过这个头信息告诉浏览器用什么编码来解析&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;Content&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;Type&lt;/span&gt;: &lt;span style=&#34;color:#e06c75&#34;&gt;text&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;html&lt;/span&gt;; &lt;span style=&#34;color:#e06c75&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;utf&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#d19a66&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;HTML文件头&lt;/strong&gt;：在HTML文件内部，通过meta标签再次声明编码，作为服务器未发送上述头信息时的备用方案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-HTML&#34; data-lang=&#34;HTML&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#e06c75&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;XML文件头&lt;/strong&gt;：XML文件在第一行就声明自己的编码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-XML&#34; data-lang=&#34;XML&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#7f848e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;说完了基础的，我们来说点高级的 —— 其实，Unicode远比“一个码点一个字”要复杂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了我们看得见的字符，还存在一套系统，用于处理字符的等价性问题、组合显示以及控制文本的复杂行为&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;字符的变形&#34;&gt;字符的变形
&lt;/h2&gt;&lt;h3 id=&#34;同形异义&#34;&gt;同形异义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;同一个看起来一样的字符，在Unicode中可能有多种表示方式，这在计算机看来就是完全不同的东西&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如一个带扬抑符的字母&lt;code&gt;é&lt;/code&gt;，它就有两种表示方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方式1 —— 预组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用单个码点 &lt;code&gt;U+00E9&lt;/code&gt;（&lt;code&gt;é&lt;/code&gt;），就像一个现成的汉字一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方式2 —— 组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用普通字母&lt;code&gt;e&lt;/code&gt;（&lt;code&gt;U+0065&lt;/code&gt;），后面紧跟一个“组合扬抑符” &lt;code&gt;´&lt;/code&gt;（&lt;code&gt;U+0301&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;这就像汉字的一个偏旁部首，会自动“贴”到前一个字母的身上，组合成需要的样子&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这两种方式渲染出来的字形完全一样，但在计算机内部，它们的身份是完全不同的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你在一个文本中搜索 &lt;code&gt;U+00E9&lt;/code&gt;，将无法匹配到由&lt;code&gt;U+0065&lt;/code&gt; + &lt;code&gt;U+0301&lt;/code&gt;组成的那个&lt;code&gt;é&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;历史渊源&#34;&gt;历史渊源
&lt;/h3&gt;&lt;p&gt;你可能会奇怪为什么它会以两种方式存在，这其实和Unicode在设计时要兼顾的两个目标有关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;兼容性&lt;/strong&gt;
在 Unicode 出现之前，许多老字符集（如 Latin-1）已经有&lt;code&gt;é&lt;/code&gt;这种“预组合”的单个字符&lt;/p&gt;
&lt;p&gt;为了兼容旧标准，Unicode 直接收录了这些单字符形式（U+00E9）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可组合性&lt;/strong&gt;
Unicode 希望支持所有语言的所有字符变化（比如加不同的重音、附加符号、数学标记等），但如果每种变化都单独收一个码点，字符集会无限膨胀&lt;/p&gt;
&lt;p&gt;所以，Unicode 定义了组合字符（Combining Characters）机制，允许用一个基本字母 + 一个或多个附加符号来动态组合成新字形（比如&lt;code&gt;U+0065&lt;/code&gt;+&lt;code&gt;U+0301&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;归一化标准&#34;&gt;归一化标准
&lt;/h3&gt;&lt;p&gt;为了解决这个问题，Unicode 定义了四种归一化标准，用于将“看起来一样但编码不同”的字符串转换为统一的、规范的表示形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NFC (Normalization Form C – Composition)&lt;/strong&gt;：&lt;strong&gt;组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先将字符分解，再尽可能组合为预组合形式（比如 &lt;code&gt;e&lt;/code&gt; + &lt;code&gt;´&lt;/code&gt; → &lt;code&gt;é&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;这是 W3C 推荐在网页存储和传输中使用的标准，能够保证跨平台一致性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NFD (Normalization Form D – Decomposition)&lt;/strong&gt;：&lt;strong&gt;分解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将字符尽可能分解为基本字符和组合标记（比如 &lt;code&gt;é&lt;/code&gt; → &lt;code&gt;e&lt;/code&gt; + &lt;code&gt;´&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;这种形式常用于需要分析字符结构或对附加符号单独处理的场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NFKC (Normalization Form KC – Compatibility Composition)&lt;/strong&gt;：&lt;strong&gt;兼容性组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在NFC的基础上，先进行兼容性分解（把全角字符、特殊样式字符等转换为标准字符），再尽可能组合&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;Ｈｅｌｌｏ&lt;/code&gt;（全角）会被转成&lt;code&gt;Hello&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;适合搜索、匹配、用户输入标准化等场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NFKD (Normalization Form KD – Compatibility Decomposition)&lt;/strong&gt;：&lt;strong&gt;兼容性分解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在NFD的基础上，额外进行兼容性分解，将外观差异但语义等价的字符统一为标准形式，并保持分解状态&lt;/p&gt;
&lt;p&gt;例如，罗马数字 &lt;code&gt;Ⅳ&lt;/code&gt; 会被分解为 &lt;code&gt;I&lt;/code&gt; + &lt;code&gt;V&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;常用于文本分析、去除装饰性差异等任务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;前两种是比较常用的归一化方式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;特殊字符&#34;&gt;特殊字符
&lt;/h2&gt;&lt;p&gt;Unicode中包含很多“看不见”但有特殊功能的字符，我们上面提到的用作BOM的就是其中一种&lt;/p&gt;
&lt;h3 id=&#34;零宽字符&#34;&gt;零宽字符
&lt;/h3&gt;&lt;h4 id=&#34;看不见的字符&#34;&gt;看不见的字符
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;它们不占用任何宽度，肉眼不可见，但能产生特殊效果&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;零宽空格 (ZWSP, U+200B)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它用于在长单词或 URL 的中间建议一个“可以换行”的位置，而不会产生一个可见的空格&lt;/p&gt;
&lt;p&gt;例如，在 URL &lt;code&gt;thisisaverylongurlthatmightoverflow&lt;/code&gt; 中间插入 ZWSP，当容器宽度不够时，浏览器就可以在这里优雅地换行，而不会破坏链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;零宽连字 (ZWJ, U+200D)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它用于“粘合”两个独立的字符，告诉渲染引擎将它们显示为一个组合的字形&lt;/p&gt;
&lt;p&gt;最著名的应用就是 &lt;strong&gt;Emoji&lt;/strong&gt; 的组合： &lt;code&gt;👨&lt;/code&gt; (男人) + &lt;code&gt;ZWJ&lt;/code&gt; + &lt;code&gt;👩&lt;/code&gt; (女人) + &lt;code&gt;ZWJ&lt;/code&gt; + &lt;code&gt;👧&lt;/code&gt; (女孩) + &lt;code&gt;ZWJ&lt;/code&gt; + &lt;code&gt;👦&lt;/code&gt; (男孩) = &lt;code&gt;👨‍👩‍👧‍👦&lt;/code&gt; (家庭) &lt;code&gt;‍&lt;/code&gt; (零宽连字) 本身不可见，但它像胶水一样把前后四个独立的 Emoji 粘合成了一个新的 Emoji&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;零宽非连字 (ZWNJ, U+200C)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与 ZWJ 相反，它用于“切断”本应自动连接的字符&lt;/p&gt;
&lt;p&gt;例如，在波斯语中，某些字母会自动与后面的字母连接，插入 ZWNJ 可以强制它们断开，以显示其非连接形式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从左到右标记 (LRM, U+200E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个不可见字符，用来强制后续字符以从左到右显示&lt;/p&gt;
&lt;p&gt;常用于混合方向文本中，确保英文或数字按正常方向显示。例如，在阿拉伯语句子中插入 LRM 可以保证英文单词正常显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从右到左标记 (RLM, U+200F)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 LRM，但强制后续字符以从右到左方向显示&lt;/p&gt;
&lt;p&gt;常用于拉丁字母或数字出现在阿拉伯语或希伯来语文本时，保证它们正确的右到左排列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从左到右嵌入 (LRE, U+202A)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它开始一段左到右的文本嵌入，后续字符强制从左到右显示，直到遇到对应的结束符&lt;/p&gt;
&lt;p&gt;在主要是阿拉伯语的文本中插入LRE和PDF，可让一段英文保持左到右排列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从右到左嵌入 (RLE, U+202B)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它开始一段右到左的文本嵌入，后续字符强制从右到左显示，直到遇到结束符&lt;/p&gt;
&lt;p&gt;在主要为英文的文本中插入RLE和PDF，使其中一段希伯来语正常右到左排列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;弹出方向格式 (PDF, U+202C)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它用来结束先前的方向嵌入（LRE或RLE），恢复之前的文本方向&lt;/p&gt;
&lt;p&gt;例如：文本中出现LRE&amp;hellip;PDF或RLE&amp;hellip;PDF包裹的区域，PDF结束该嵌入状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从左到右覆盖 (LRO, U+202D)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它强制后续字符全部以从左到右方向显示，覆盖其默认方向，直到遇到PDF&lt;/p&gt;
&lt;p&gt;例如：在包含阿拉伯语或希伯来语的混合文本中，强制某一部分以从左到右显示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从右到左覆盖 (RLO, U+202E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与LRO相反，强制后续字符全部以从右到左方向显示，覆盖默认方向，直到遇到PDF&lt;/p&gt;
&lt;p&gt;这在恶意文本或混淆攻击中经常被用来制造视觉欺骗，因它会反转文字显示方向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可见乘号 (INVISIBLE TIMES, U+2062)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示数学隐式乘法操作，但不显示任何符号，常用于数学公式排版，变量间的隐式相乘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可见分隔符 (INVISIBLE SEPARATOR, U+2063)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用作文本逻辑分隔符，但不显示任何空白或符号，方便文本内部逻辑处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;零宽不间断空格 (ZWNBSP, U+FEFF)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既是零宽的不可换行空格，也常用于Unicode文档的字节顺序标记（BOM）&lt;/p&gt;
&lt;p&gt;在文件开头可标识文本编码，但不应随意插入文本中，以免引起显示问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;qq的反转id&#34;&gt;QQ的反转id
&lt;/h4&gt;&lt;p&gt;相信不少人都看见过qq群里有些人的id后面会跟着一个“喵”之类的恶搞字符&lt;/p&gt;
&lt;p&gt;当你@他时，这个字符竟然脱离了id，出现在了我们输入的话后面！这怎么回事？&lt;/p&gt;
&lt;p&gt;其实这就是使用了上面我们提到的零宽字符的两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;U+202E&lt;/code&gt;：从右至左覆盖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U+202D&lt;/code&gt;：从左至右覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，我有一个id是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;快来艾特我&lt;/span&gt;\&lt;span style=&#34;color:#e06c75&#34;&gt;u202E喵&lt;/span&gt;~\&lt;span style=&#34;color:#e06c75&#34;&gt;u202D&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为是不可见字符，在别人眼里是看不见的（需要使用对应的编码工具，比如：&lt;a class=&#34;link&#34; href=&#34;https://tool.chinaz.com/tools/unicode.aspx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;unicode编码转换
    
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.7em&#34;
        height=&#34;.7em&#34; viewBox=&#34;0 0 21 21&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
        &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
        &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
            fill=&#34;currentColor&#34;&gt;
    &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;快来艾特我喵&lt;/span&gt;~
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当别人@我发言的时候（比如说“你好”，显示应该是&lt;code&gt;@快来艾特我喵 你好&lt;/code&gt;），文字显示默认从左向右&lt;/p&gt;
&lt;p&gt;我们使用&lt;code&gt;[]&lt;/code&gt;代表当前输入光标的位置，左右箭头代表输入方向：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;[]&lt;/span&gt;→
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@[]→
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快&lt;/span&gt;[]→
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来&lt;/span&gt;[]→
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾&lt;/span&gt;[]→
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特&lt;/span&gt;[]→
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特我&lt;/span&gt;[]→
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;读取到这里的时候，文本框看见了控制字符&lt;code&gt;U+202E&lt;/code&gt;，它立刻变成了从左向右输入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特我&lt;/span&gt;←[]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特我&lt;/span&gt;←[]&lt;span style=&#34;color:#e06c75&#34;&gt;喵&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输入“喵”后，他又看见了控制字符&lt;code&gt;U+202D&lt;/code&gt;，又变回了从右向左输入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特我&lt;/span&gt;[]→&lt;span style=&#34;color:#e06c75&#34;&gt;喵&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特我你&lt;/span&gt;[]→&lt;span style=&#34;color:#e06c75&#34;&gt;喵&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特我你好&lt;/span&gt;[]→&lt;span style=&#34;color:#e06c75&#34;&gt;喵&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输入完成之后最终效果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#61afef&#34;&gt;@快来艾特我你好喵&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这就让别人喵喵叫啦&lt;/p&gt;
&lt;h4 id=&#34;零宽字符隐写&#34;&gt;零宽字符隐写
&lt;/h4&gt;&lt;p&gt;这种零宽字符还诞生了一种隐写方式 —— &lt;strong&gt;零宽字符隐写（Zero-Width Character Steganography）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;隐写技术通过在正常文本的字符间插入零宽字符，或者利用不同零宽字符的组合，来编码隐藏信息&lt;/p&gt;
&lt;p&gt;例如，用零宽空格代表二进制的0，零宽非连接符代表1，或者通过插入或不插入零宽字符表示二进制位&lt;/p&gt;
&lt;p&gt;这样，隐藏的信息不会被普通阅读者察觉，因为文本外观没有变化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你可以使用linux的vim编辑器打开，观察到\u这样的隐写痕迹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用的隐写工具：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://330k.github.io/misc_tools/unicode_steganography.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://330k.github.io/misc_tools/unicode_steganography.html
    
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.7em&#34;
        height=&#34;.7em&#34; viewBox=&#34;0 0 21 21&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
        &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
        &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
            fill=&#34;currentColor&#34;&gt;
    &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yuanfux.github.io/zero-width-web/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yuanfux.github.io/zero-width-web/
    
    &lt;span style=&#34;white-space: nowrap;&#34;&gt;&lt;svg width=&#34;.7em&#34;
        height=&#34;.7em&#34; viewBox=&#34;0 0 21 21&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
        &lt;path d=&#34;m13 3l3.293 3.293l-7 7l1.414 1.414l7-7L21 11V3z&#34; fill=&#34;currentColor&#34; /&gt;
        &lt;path d=&#34;M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z&#34;
            fill=&#34;currentColor&#34;&gt;
    &lt;/svg&gt;&lt;/span&gt;
    
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;变体选择符&#34;&gt;变体选择符
&lt;/h3&gt;&lt;p&gt;变体选择符是一类特殊的Unicode码点，通常紧跟在另一个字符后面，作用是“建议”或“指定”该字符的具体显示样式（字形变体），以保证不同平台或字体能正确显示&lt;/p&gt;
&lt;p&gt;常见变体选择符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;U+FE0E&lt;/code&gt;（VS15，Variation Selector-15）表示文本形式，提示字符以普通文本风格显示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;U+FE0F&lt;/code&gt;（VS16，Variation Selector-16）表示表情符号形式，提示字符以彩色Emoji风格显示&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，Unicode字符&lt;code&gt;U+2764&lt;/code&gt;是一个“心形”符号 ❤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单独使用：&lt;code&gt;U+2764&lt;/code&gt;，显示可能是黑白符号，也可能是彩色Emoji，这依赖平台和字体&lt;/li&gt;
&lt;li&gt;加上变体选择符：&lt;code&gt;U+2764 U+FE0F&lt;/code&gt;，强制显示为彩色Emoji❤️&lt;/li&gt;
&lt;li&gt;加上变体选择符：&lt;code&gt;U+2764 U+FE0E&lt;/code&gt;，强制显示为黑白文本 ❤︎&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;讲了这么多，终于到实践的部分了&lt;/p&gt;
&lt;p&gt;到目前为止，我们讨论的都是计算机如何“理解”和“存储”字符&lt;/p&gt;
&lt;p&gt;现在，我们来看看在实际操作中，人类是如何与这个复杂的字符系统进行交互的&lt;/p&gt;
&lt;h2 id=&#34;工具与应用&#34;&gt;工具与应用
&lt;/h2&gt;&lt;h3 id=&#34;输入法input-method-editor-ime&#34;&gt;输入法（Input Method Editor, IME）
&lt;/h3&gt;&lt;p&gt;输入法并非一个普通的应用程序，而是一个&lt;strong&gt;专为文本输入设计的、集成在操作系统中的系统级服务或中间件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的位置恰好位于&lt;strong&gt;物理键盘&lt;/strong&gt;和&lt;strong&gt;当前聚焦的应用程序&lt;/strong&gt;之间，为了让输入法能够“拦截”和“处理”按键，所有现代操作系统都提供了专门的框架来管理和集成它们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;: &lt;strong&gt;文本服务框架 (Text Services Framework, TSF)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个先进的框架，允许输入法、手写识别、语音识别等多种文本服务以统一的方式与应用程序交互&lt;/p&gt;
&lt;p&gt;在早期，Windows使用的是一个较老的系统，名为&lt;strong&gt;输入法管理器 (Input Method Manager, IMM)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;macOS&lt;/strong&gt;: &lt;strong&gt;Input Method Kit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是苹果为开发者提供的、用于构建输入法的官方框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;: &lt;strong&gt;IBus (Intelligent Input Bus)&lt;/strong&gt; &amp;amp; &lt;strong&gt;Fcitx (Flexible Context-aware Input Tool for X)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它们都采用了一种“总线”式的架构，输入法作为服务挂载在总线上，为所有应用程序提供输入服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些框架的核心作用，就是建立一套标准的通信协议，确保任何应用程序（只要它支持该框架）都能与任何输入法进行顺畅的对话，而无需关心对方的具体实现&lt;/p&gt;
&lt;p&gt;当我们在键盘上敲下字母到最终输入文字，经历了什么？&lt;/p&gt;
&lt;p&gt;我们以输入“你好”为例，一步一步看看它的过程：&lt;/p&gt;
&lt;h4 id=&#34;步骤一事件拦截&#34;&gt;步骤一：事件拦截
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;物理按键触发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们按下&lt;code&gt;n&lt;/code&gt;键时，键盘硬件会将该按键对应的&lt;strong&gt;扫描码（Scan Code）&lt;/strong&gt; 通过键盘控制器发送到计算机&lt;/p&gt;
&lt;p&gt;这只是一个硬件级的信号，还不知道“n”是什么意思&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;操作系统接收与封装事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统的输入子系统（如 Windows 的 Keyboard Class Driver、Linux 的 evdev）接收到扫描码，将其转换成虚拟键码&lt;/p&gt;
&lt;p&gt;这一阶段还只是“按下了哪个键”的信息，不涉及语言文字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IME 输入法拦截&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在操作系统将键盘事件传递给当前活动应用程序（比如聊天窗口）之前，事件会先经过&lt;strong&gt;输入法框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果当前有 IME 处于激活状态，它会拦截并消费这个按键事件 —— 这意味着这个按键不会直接传给应用，而是先进入输入法的内部处理逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建立输入上下文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IME会根据当前的焦点控件（例如一个可编辑文本框）建立一个输入上下文，用来记录本轮输入的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已输入的编码（例如拼音串&lt;code&gt;nihao&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;光标位置&lt;/li&gt;
&lt;li&gt;候选词列表&lt;/li&gt;
&lt;li&gt;用户选择历史&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一步相当于输入法开了一个“草稿本”，专门记录你正在打的这段文字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成组合字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入法会将已输入的编码（如&lt;code&gt;n&lt;/code&gt; → &lt;code&gt;ni&lt;/code&gt; → &lt;code&gt;nih&lt;/code&gt; → &lt;code&gt;nihao&lt;/code&gt;）显示在屏幕上&lt;/p&gt;
&lt;p&gt;这段带虚线或高亮的临时文字被称为组合字符串，它不是应用程序缓冲区里的正式文本，而是由输入法通过IME接口直接绘制到光标位置上的&lt;/p&gt;
&lt;p&gt;在这个阶段，应用程序并不知道这些字母是什么 —— 它只知道光标处有一个正在编辑的输入会话&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;步骤二转换引擎&#34;&gt;步骤二：转换引擎
&lt;/h4&gt;&lt;p&gt;这是输入法最核心的部分，转换引擎根据缓冲区中的&lt;code&gt;nihao&lt;/code&gt;，开始计算所有可能的候选结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转换引擎主要依赖两个东西 —— 词库和语言模型&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;color:orange&#34;&gt;&lt;strong&gt;1.词库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;存储大量词语及其拼音（或其他编码）对应关系的数据集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态词库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入法出厂时内置的、包含数百万词条的巨大数据库。它定义了拼音与汉字、词语之间的基础对应关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态/用户词库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录你个人常用词汇的词典。你输入过的名字、昵称、专业术语都会被添加进来，下次输入时就会优先显示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;云端词库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现代输入法的“联网大脑”。它能实时从互联网上抓取最新的流行语、新闻热点、人名地名，让你的输入法永远“与时俱进”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span style=&#34;color:orange&#34;&gt;&lt;strong&gt;2.语言模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果说词典是认字，那么语言模型就是理解语法和语境，它负责从众多同音词中，猜出你最想要的那一个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;N-gram 模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是统计学模型，它通过分析海量文本数据，计算出词语组合的概率&lt;/p&gt;
&lt;p&gt;例如，它知道 &lt;code&gt;P(好 | 你)&lt;/code&gt;（在“你”之后出现“好”的概率）要远远大于 &lt;code&gt;P(耗 | 你)&lt;/code&gt;，因此，&lt;code&gt;你好&lt;/code&gt;的排序会非常靠前&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;更先进的模型（HMM, CRF, AI）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现代输入法普遍采用更复杂的统计模型，甚至是深度学习神经网络（如 RNN/LSTM）&lt;/p&gt;
&lt;p&gt;这些模型不仅看前一个词，还会综合分析整个句子的结构和语义，从而做出惊人准确的预测&lt;/p&gt;
&lt;p&gt;例如，当你输入&lt;code&gt;jintianwanshangwomenyiqiqu&lt;/code&gt;时，它能直接预测出 &lt;code&gt;今天晚上我们一起去&lt;/code&gt;，而不是一堆不相关的单字&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;步骤三候选界面&#34;&gt;步骤三：候选界面
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生成列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;转换引擎将计算出的结果，按照概率从高到低排序，生成一个候选列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;渲染窗口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入法的界面模块（UI）获取这个列表，然后在屏幕上绘制出我们熟悉的候选窗口&lt;/p&gt;
&lt;p&gt;这个窗口是一个独立的、悬浮在所有应用之上的图层，由输入法完全控制&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;步骤四文本提交&#34;&gt;步骤四：文本提交
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户通过按空格、数字键或鼠标点击，在候选窗口中选择了 &lt;code&gt;你好&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;发送指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入法收到用户的选择后，会向操作系统的文本服务框架发送一个提交文本的指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内容交付&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个指令里装的，就是最终确定的字符串 &lt;code&gt;你好&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更底层地看，是这两个字符的Unicode 码点序列 (&lt;code&gt;U+4F60&lt;/code&gt;, &lt;code&gt;U+597D&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用接收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序的文本框接收到这个指令，就像接收到用户用剪贴板粘贴进来一段文本一样&lt;/p&gt;
&lt;p&gt;它将这两个字符插入到自己的文本缓冲区中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最终渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序调用系统的字体渲染引擎，根据当前设置的字体，将&lt;code&gt;U+4F60&lt;/code&gt;和&lt;code&gt;U+597D&lt;/code&gt;对应的字形绘制到屏幕上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，输入法绘制的临时草稿（带下划线的&lt;code&gt;nihao&lt;/code&gt;和候选窗口）消失，&lt;code&gt;你好&lt;/code&gt;这两个字被正式地写入了应用程序，整个输入流程完成&lt;/p&gt;
&lt;h3 id=&#34;编码转换工具和库&#34;&gt;编码转换工具和库
&lt;/h3&gt;&lt;p&gt;在处理来自不同年代、不同地区、不同系统的数据时，编码不一致是家常便饭：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们可能需要将一个使用GBK编码的旧网站数据库，迁移到新的、使用UTF-8的系统中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户可能会上传各种奇奇怪怪编码的文本文件，我们的程序需要有能力正确识别和处理它们&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们调用的某个古老API接口，可能只接受GBK编码的请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;因此，编码转换很重要&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;iconv&#34;&gt;iconv
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;iconv&lt;/code&gt;是一个乎所有类Unix系统都自带的跨平台命令行工具和编程库，专门用于字符编码的转换&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iconv -f &amp;lt;源编码&amp;gt; -t &amp;lt;目标编码&amp;gt; &amp;lt;输入文件&amp;gt; -o &amp;lt;输出文件&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;常用参数：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;参数&lt;/th&gt;
          &lt;th&gt;作用说明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;-f 或 &amp;ndash;from-code&lt;/td&gt;
          &lt;td&gt;指定输入文本的字符编码格式&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-t 或 &amp;ndash;to-code&lt;/td&gt;
          &lt;td&gt;指定输出文本的字符编码格式&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-l 或 &amp;ndash;list&lt;/td&gt;
          &lt;td&gt;列出支持的所有编码格式&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-o 或 &amp;ndash;output&lt;/td&gt;
          &lt;td&gt;指定输出文件（否则输出到标准输出）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-c&lt;/td&gt;
          &lt;td&gt;忽略非法输入字符（转换时跳过错误字符）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;ndash;verbose&lt;/td&gt;
          &lt;td&gt;显示详细的转换过程信息&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;eg：将一个GBK编码的文件转换为UTF-8编码的格式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;iconv -f GBK -t UTF-8 gbk.txt -o utf8.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;icu&#34;&gt;ICU
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;ICU（International Components for Unicode，Unicode国际组件）是一个由IBM（International Business Machines Corporation,国际商业机器公司）开发和维护的、功能极其强大的C/C++和Java库，后来交由了Unicode联盟管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其他语言也可以通过绑定或封装调用ICU库来使用大部分核心功能，但可能需要额外安装或配置&lt;/p&gt;
&lt;p&gt;ICU不止是一个编码转换工具，还是一套全方位的国际化解决方案&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它提供比&lt;code&gt;iconv&lt;/code&gt;更强大、更健壮的编码转换功能，支持超过200种编码，还有以下功能：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字符归一化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以轻松地将字符串转换为NFC或NFD等范式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它能实现真正符合语言习惯的排序&lt;/p&gt;
&lt;p&gt;例如，简单的按字节排序会将&lt;code&gt;b &lt;/code&gt;排在 &lt;code&gt;á&lt;/code&gt; 前面，但ICU知道在西班牙语中它们应该如何正确排序&lt;/p&gt;
&lt;p&gt;对于中文，它可以实现按拼音、部首或笔画排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;日期、时间、数字、货币格式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它可以根据不同国家/地区（Locale）的习惯，将同一个日期&lt;code&gt;2025-08-13&lt;/code&gt;格式化为&lt;code&gt;8/13/2025&lt;/code&gt;(美国)或 &lt;code&gt;13/08/2025&lt;/code&gt;(英国)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;文本边界分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它能准确地识别出单词、句子、段落的边界，这对于文本处理和搜索引擎至关重要&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;编程语言&#34;&gt;编程语言
&lt;/h4&gt;&lt;p&gt;现代主流编程语言都内置了强大的字符串和编码处理能力，通常足以应对日常的转换需求&lt;/p&gt;
&lt;p&gt;比如python内部使用unicode表示字符串，并提供了&lt;code&gt;.encode()&lt;/code&gt;和&lt;code&gt;.decode()&lt;/code&gt;方法，之前的示例中我们也使用过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eg1：将GBK字节流转换为unicode字符串&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;gbk&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#98c379&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;\xc4\xe3\xba\xc3&lt;/span&gt;&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;&lt;/span&gt;  &lt;span style=&#34;color:#7f848e&#34;&gt;# &amp;#34;你好&amp;#34; 的 GBK 字节&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;unicode&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;gbk&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;decode&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;gbk&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;eg2：接上一例，将unicode字符串编码为UTF-8字节流&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;utf8&lt;/span&gt; &lt;span style=&#34;color:#56b6c2&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e06c75&#34;&gt;unicode&lt;/span&gt;&lt;span style=&#34;color:#56b6c2&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#e06c75&#34;&gt;encode&lt;/span&gt;(&lt;span style=&#34;color:#98c379&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Java, JavaScript, Go, Rust 等也都提供了类似的API，使得我们可以方便地在代码层面处理编码问题&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;到这里，一切的一切也就结束了&lt;/p&gt;
&lt;p&gt;这篇文章诞生原因其实是在学linux命令的时候时常涉及字符、字等等东西，再加上以前看过不少相关文章视频，兴趣使然才写下了这些文字&lt;/p&gt;
&lt;p&gt;编码的世界远比我想象的复杂，本文也只是冰山一角、抛砖引玉之作，系统的学习还要综合网上的资料才行&lt;/p&gt;
&lt;p&gt;不管怎么样，希望能对你有所帮助&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
